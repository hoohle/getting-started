
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = "http://202.206.168.131:4466"
var Secret          = ""


      func (client *Client) AirHistoryData (params AirHistoryDataWhereUniqueInput) *AirHistoryDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"AirHistoryDataWhereUniqueInput!", "AirHistoryData"},
          "airHistoryData",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExec{ret}
      }

      type AirHistoryDatasParams struct {
        Where *AirHistoryDataWhereInput `json:"where,omitempty"`
OrderBy *AirHistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AirHistoryDatas (params *AirHistoryDatasParams) *AirHistoryDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"AirHistoryDataWhereInput", "AirHistoryDataOrderByInput", "AirHistoryData"},
          "airHistoryDatas",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExecArray{ret}
      }

      type AirHistoryDatasConnectionParams struct {
        Where *AirHistoryDataWhereInput `json:"where,omitempty"`
OrderBy *AirHistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AirHistoryDatasConnection (params *AirHistoryDatasConnectionParams) (AirHistoryDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) AirLive (params AirLiveWhereUniqueInput) *AirLiveExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"AirLiveWhereUniqueInput!", "AirLive"},
          "airLive",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExec{ret}
      }

      type AirLivesParams struct {
        Where *AirLiveWhereInput `json:"where,omitempty"`
OrderBy *AirLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AirLives (params *AirLivesParams) *AirLiveExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"AirLiveWhereInput", "AirLiveOrderByInput", "AirLive"},
          "airLives",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExecArray{ret}
      }

      type AirLivesConnectionParams struct {
        Where *AirLiveWhereInput `json:"where,omitempty"`
OrderBy *AirLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AirLivesConnection (params *AirLivesConnectionParams) (AirLiveConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) AttendanceRecord (params AttendanceRecordWhereUniqueInput) *AttendanceRecordExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"AttendanceRecordWhereUniqueInput!", "AttendanceRecord"},
          "attendanceRecord",
          []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExec{ret}
      }

      type AttendanceRecordsParams struct {
        Where *AttendanceRecordWhereInput `json:"where,omitempty"`
OrderBy *AttendanceRecordOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AttendanceRecords (params *AttendanceRecordsParams) *AttendanceRecordExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"AttendanceRecordWhereInput", "AttendanceRecordOrderByInput", "AttendanceRecord"},
          "attendanceRecords",
          []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExecArray{ret}
      }

      type AttendanceRecordsConnectionParams struct {
        Where *AttendanceRecordWhereInput `json:"where,omitempty"`
OrderBy *AttendanceRecordOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) AttendanceRecordsConnection (params *AttendanceRecordsConnectionParams) (AttendanceRecordConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) CityCodeInfo (params CityCodeInfoWhereUniqueInput) *CityCodeInfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"CityCodeInfoWhereUniqueInput!", "CityCodeInfo"},
          "cityCodeInfo",
          []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExec{ret}
      }

      type CityCodeInfoesParams struct {
        Where *CityCodeInfoWhereInput `json:"where,omitempty"`
OrderBy *CityCodeInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) CityCodeInfoes (params *CityCodeInfoesParams) *CityCodeInfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"CityCodeInfoWhereInput", "CityCodeInfoOrderByInput", "CityCodeInfo"},
          "cityCodeInfoes",
          []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExecArray{ret}
      }

      type CityCodeInfoesConnectionParams struct {
        Where *CityCodeInfoWhereInput `json:"where,omitempty"`
OrderBy *CityCodeInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) CityCodeInfoesConnection (params *CityCodeInfoesConnectionParams) (CityCodeInfoConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) DataUnit (params DataUnitWhereUniqueInput) *DataUnitExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"DataUnitWhereUniqueInput!", "DataUnit"},
          "dataUnit",
          []string{"id","dataItem","unit"})

        return &DataUnitExec{ret}
      }

      type DataUnitsParams struct {
        Where *DataUnitWhereInput `json:"where,omitempty"`
OrderBy *DataUnitOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) DataUnits (params *DataUnitsParams) *DataUnitExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"DataUnitWhereInput", "DataUnitOrderByInput", "DataUnit"},
          "dataUnits",
          []string{"id","dataItem","unit"})

        return &DataUnitExecArray{ret}
      }

      type DataUnitsConnectionParams struct {
        Where *DataUnitWhereInput `json:"where,omitempty"`
OrderBy *DataUnitOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) DataUnitsConnection (params *DataUnitsConnectionParams) (DataUnitConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) HistoryData (params HistoryDataWhereUniqueInput) *HistoryDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"HistoryDataWhereUniqueInput!", "HistoryData"},
          "historyData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExec{ret}
      }

      type HistoryDatasParams struct {
        Where *HistoryDataWhereInput `json:"where,omitempty"`
OrderBy *HistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) HistoryDatas (params *HistoryDatasParams) *HistoryDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"HistoryDataWhereInput", "HistoryDataOrderByInput", "HistoryData"},
          "historyDatas",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExecArray{ret}
      }

      type HistoryDatasConnectionParams struct {
        Where *HistoryDataWhereInput `json:"where,omitempty"`
OrderBy *HistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) HistoryDatasConnection (params *HistoryDatasConnectionParams) (HistoryDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) IDCardVerifyData (params IDCardVerifyDataWhereUniqueInput) *IDCardVerifyDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"IDCardVerifyDataWhereUniqueInput!", "IDCardVerifyData"},
          "iDCardVerifyData",
          []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExec{ret}
      }

      type IDCardVerifyDatasParams struct {
        Where *IDCardVerifyDataWhereInput `json:"where,omitempty"`
OrderBy *IDCardVerifyDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) IDCardVerifyDatas (params *IDCardVerifyDatasParams) *IDCardVerifyDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"IDCardVerifyDataWhereInput", "IDCardVerifyDataOrderByInput", "IDCardVerifyData"},
          "iDCardVerifyDatas",
          []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExecArray{ret}
      }

      type IDCardVerifyDatasConnectionParams struct {
        Where *IDCardVerifyDataWhereInput `json:"where,omitempty"`
OrderBy *IDCardVerifyDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) IDCardVerifyDatasConnection (params *IDCardVerifyDatasConnectionParams) (IDCardVerifyDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) IDVerifyDeviceInfo (params IDVerifyDeviceInfoWhereUniqueInput) *IDVerifyDeviceInfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"IDVerifyDeviceInfoWhereUniqueInput!", "IDVerifyDeviceInfo"},
          "iDVerifyDeviceInfo",
          []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExec{ret}
      }

      type IDVerifyDeviceInfoesParams struct {
        Where *IDVerifyDeviceInfoWhereInput `json:"where,omitempty"`
OrderBy *IDVerifyDeviceInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) IDVerifyDeviceInfoes (params *IDVerifyDeviceInfoesParams) *IDVerifyDeviceInfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"IDVerifyDeviceInfoWhereInput", "IDVerifyDeviceInfoOrderByInput", "IDVerifyDeviceInfo"},
          "iDVerifyDeviceInfoes",
          []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExecArray{ret}
      }

      type IDVerifyDeviceInfoesConnectionParams struct {
        Where *IDVerifyDeviceInfoWhereInput `json:"where,omitempty"`
OrderBy *IDVerifyDeviceInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) IDVerifyDeviceInfoesConnection (params *IDVerifyDeviceInfoesConnectionParams) (IDVerifyDeviceInfoConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) LocationInfo (params LocationInfoWhereUniqueInput) *LocationInfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"LocationInfoWhereUniqueInput!", "LocationInfo"},
          "locationInfo",
          []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExec{ret}
      }

      type LocationInfoesParams struct {
        Where *LocationInfoWhereInput `json:"where,omitempty"`
OrderBy *LocationInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) LocationInfoes (params *LocationInfoesParams) *LocationInfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"LocationInfoWhereInput", "LocationInfoOrderByInput", "LocationInfo"},
          "locationInfoes",
          []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExecArray{ret}
      }

      type LocationInfoesConnectionParams struct {
        Where *LocationInfoWhereInput `json:"where,omitempty"`
OrderBy *LocationInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) LocationInfoesConnection (params *LocationInfoesConnectionParams) (LocationInfoConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) MAcProbeData (params MacProbeDataWhereUniqueInput) *MacProbeDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"MACProbeDataWhereUniqueInput!", "MACProbeData"},
          "mACProbeData",
          []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExec{ret}
      }

      type MAcProbeDatasParams struct {
        Where *MacProbeDataWhereInput `json:"where,omitempty"`
OrderBy *MacProbeDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MAcProbeDatas (params *MAcProbeDatasParams) *MacProbeDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"MACProbeDataWhereInput", "MACProbeDataOrderByInput", "MACProbeData"},
          "mACProbeDatas",
          []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExecArray{ret}
      }

      type MAcProbeDatasConnectionParams struct {
        Where *MacProbeDataWhereInput `json:"where,omitempty"`
OrderBy *MacProbeDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MAcProbeDatasConnection (params *MAcProbeDatasConnectionParams) (MacProbeDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) MAcProbeRecord (params MacProbeRecordWhereUniqueInput) *MacProbeRecordExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"MACProbeRecordWhereUniqueInput!", "MACProbeRecord"},
          "mACProbeRecord",
          []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExec{ret}
      }

      type MAcProbeRecordsParams struct {
        Where *MacProbeRecordWhereInput `json:"where,omitempty"`
OrderBy *MacProbeRecordOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MAcProbeRecords (params *MAcProbeRecordsParams) *MacProbeRecordExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"MACProbeRecordWhereInput", "MACProbeRecordOrderByInput", "MACProbeRecord"},
          "mACProbeRecords",
          []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExecArray{ret}
      }

      type MAcProbeRecordsConnectionParams struct {
        Where *MacProbeRecordWhereInput `json:"where,omitempty"`
OrderBy *MacProbeRecordOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MAcProbeRecordsConnection (params *MAcProbeRecordsConnectionParams) (MacProbeRecordConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) MACinfo (params MaCinfoWhereUniqueInput) *MaCinfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"MACinfoWhereUniqueInput!", "MACinfo"},
          "mACinfo",
          []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExec{ret}
      }

      type MACinfoesParams struct {
        Where *MaCinfoWhereInput `json:"where,omitempty"`
OrderBy *MaCinfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MACinfoes (params *MACinfoesParams) *MaCinfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"MACinfoWhereInput", "MACinfoOrderByInput", "MACinfo"},
          "mACinfoes",
          []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExecArray{ret}
      }

      type MACinfoesConnectionParams struct {
        Where *MaCinfoWhereInput `json:"where,omitempty"`
OrderBy *MaCinfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MACinfoesConnection (params *MACinfoesConnectionParams) (MaCinfoConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) MonitorNode (params MonitorNodeWhereUniqueInput) *MonitorNodeExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"MonitorNodeWhereUniqueInput!", "MonitorNode"},
          "monitorNode",
          []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExec{ret}
      }

      type MonitorNodesParams struct {
        Where *MonitorNodeWhereInput `json:"where,omitempty"`
OrderBy *MonitorNodeOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MonitorNodes (params *MonitorNodesParams) *MonitorNodeExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"MonitorNodeWhereInput", "MonitorNodeOrderByInput", "MonitorNode"},
          "monitorNodes",
          []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExecArray{ret}
      }

      type MonitorNodesConnectionParams struct {
        Where *MonitorNodeWhereInput `json:"where,omitempty"`
OrderBy *MonitorNodeOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) MonitorNodesConnection (params *MonitorNodesConnectionParams) (MonitorNodeConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) PersonInfo (params PersonInfoWhereUniqueInput) *PersonInfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"PersonInfoWhereUniqueInput!", "PersonInfo"},
          "personInfo",
          []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExec{ret}
      }

      type PersonInfoesParams struct {
        Where *PersonInfoWhereInput `json:"where,omitempty"`
OrderBy *PersonInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) PersonInfoes (params *PersonInfoesParams) *PersonInfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"PersonInfoWhereInput", "PersonInfoOrderByInput", "PersonInfo"},
          "personInfoes",
          []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExecArray{ret}
      }

      type PersonInfoesConnectionParams struct {
        Where *PersonInfoWhereInput `json:"where,omitempty"`
OrderBy *PersonInfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) PersonInfoesConnection (params *PersonInfoesConnectionParams) (PersonInfoConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) RealTimeData (params RealTimeDataWhereUniqueInput) *RealTimeDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"RealTimeDataWhereUniqueInput!", "RealTimeData"},
          "realTimeData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExec{ret}
      }

      type RealTimeDatasParams struct {
        Where *RealTimeDataWhereInput `json:"where,omitempty"`
OrderBy *RealTimeDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) RealTimeDatas (params *RealTimeDatasParams) *RealTimeDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"RealTimeDataWhereInput", "RealTimeDataOrderByInput", "RealTimeData"},
          "realTimeDatas",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExecArray{ret}
      }

      type RealTimeDatasConnectionParams struct {
        Where *RealTimeDataWhereInput `json:"where,omitempty"`
OrderBy *RealTimeDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) RealTimeDatasConnection (params *RealTimeDatasConnectionParams) (RealTimeDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) WeatherAirHistory (params WeatherAirHistoryWhereUniqueInput) *WeatherAirHistoryExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"WeatherAirHistoryWhereUniqueInput!", "WeatherAirHistory"},
          "weatherAirHistory",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExec{ret}
      }

      type WeatherAirHistoriesParams struct {
        Where *WeatherAirHistoryWhereInput `json:"where,omitempty"`
OrderBy *WeatherAirHistoryOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherAirHistories (params *WeatherAirHistoriesParams) *WeatherAirHistoryExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"WeatherAirHistoryWhereInput", "WeatherAirHistoryOrderByInput", "WeatherAirHistory"},
          "weatherAirHistories",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExecArray{ret}
      }

      type WeatherAirHistoriesConnectionParams struct {
        Where *WeatherAirHistoryWhereInput `json:"where,omitempty"`
OrderBy *WeatherAirHistoryOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherAirHistoriesConnection (params *WeatherAirHistoriesConnectionParams) (WeatherAirHistoryConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) WeatherAirLive (params WeatherAirLiveWhereUniqueInput) *WeatherAirLiveExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"WeatherAirLiveWhereUniqueInput!", "WeatherAirLive"},
          "weatherAirLive",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExec{ret}
      }

      type WeatherAirLivesParams struct {
        Where *WeatherAirLiveWhereInput `json:"where,omitempty"`
OrderBy *WeatherAirLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherAirLives (params *WeatherAirLivesParams) *WeatherAirLiveExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"WeatherAirLiveWhereInput", "WeatherAirLiveOrderByInput", "WeatherAirLive"},
          "weatherAirLives",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExecArray{ret}
      }

      type WeatherAirLivesConnectionParams struct {
        Where *WeatherAirLiveWhereInput `json:"where,omitempty"`
OrderBy *WeatherAirLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherAirLivesConnection (params *WeatherAirLivesConnectionParams) (WeatherAirLiveConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) WeatherHistoryData (params WeatherHistoryDataWhereUniqueInput) *WeatherHistoryDataExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"WeatherHistoryDataWhereUniqueInput!", "WeatherHistoryData"},
          "weatherHistoryData",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExec{ret}
      }

      type WeatherHistoryDatasParams struct {
        Where *WeatherHistoryDataWhereInput `json:"where,omitempty"`
OrderBy *WeatherHistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherHistoryDatas (params *WeatherHistoryDatasParams) *WeatherHistoryDataExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"WeatherHistoryDataWhereInput", "WeatherHistoryDataOrderByInput", "WeatherHistoryData"},
          "weatherHistoryDatas",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExecArray{ret}
      }

      type WeatherHistoryDatasConnectionParams struct {
        Where *WeatherHistoryDataWhereInput `json:"where,omitempty"`
OrderBy *WeatherHistoryDataOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherHistoryDatasConnection (params *WeatherHistoryDatasConnectionParams) (WeatherHistoryDataConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) WeatherLive (params WeatherLiveWhereUniqueInput) *WeatherLiveExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"WeatherLiveWhereUniqueInput!", "WeatherLive"},
          "weatherLive",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExec{ret}
      }

      type WeatherLivesParams struct {
        Where *WeatherLiveWhereInput `json:"where,omitempty"`
OrderBy *WeatherLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherLives (params *WeatherLivesParams) *WeatherLiveExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"WeatherLiveWhereInput", "WeatherLiveOrderByInput", "WeatherLive"},
          "weatherLives",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExecArray{ret}
      }

      type WeatherLivesConnectionParams struct {
        Where *WeatherLiveWhereInput `json:"where,omitempty"`
OrderBy *WeatherLiveOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WeatherLivesConnection (params *WeatherLivesConnectionParams) (WeatherLiveConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) WiFiProberinfo (params WiFiProberinfoWhereUniqueInput) *WiFiProberinfoExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"WiFiProberinfoWhereUniqueInput!", "WiFiProberinfo"},
          "wiFiProberinfo",
          []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExec{ret}
      }

      type WiFiProberinfoesParams struct {
        Where *WiFiProberinfoWhereInput `json:"where,omitempty"`
OrderBy *WiFiProberinfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WiFiProberinfoes (params *WiFiProberinfoesParams) *WiFiProberinfoExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"WiFiProberinfoWhereInput", "WiFiProberinfoOrderByInput", "WiFiProberinfo"},
          "wiFiProberinfoes",
          []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExecArray{ret}
      }

      type WiFiProberinfoesConnectionParams struct {
        Where *WiFiProberinfoWhereInput `json:"where,omitempty"`
OrderBy *WiFiProberinfoOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) WiFiProberinfoesConnection (params *WiFiProberinfoesConnectionParams) (WiFiProberinfoConnectionExec) {
        panic("not implemented")
      }



      func (client *Client) CreateAirHistoryData (params AirHistoryDataCreateInput) *AirHistoryDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"AirHistoryDataCreateInput!", "AirHistoryData"},
          "createAirHistoryData",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExec{ret}
      }

      type AirHistoryDataUpdateParams struct {
        Data AirHistoryDataUpdateInput `json:"data"`
Where AirHistoryDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateAirHistoryData (params AirHistoryDataUpdateParams) *AirHistoryDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"AirHistoryDataUpdateInput!", "AirHistoryDataWhereUniqueInput!", "AirHistoryData"},
                 "updateAirHistoryData",
                 []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExec{ret}
      }

      type AirHistoryDataUpdateManyParams struct {
        Data AirHistoryDataUpdateManyMutationInput `json:"data"`
Where *AirHistoryDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyAirHistoryDatas (params AirHistoryDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"AirHistoryDataUpdateManyMutationInput!", "AirHistoryDataWhereInput"},
          "updateManyAirHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      type AirHistoryDataUpsertParams struct {
        Where AirHistoryDataWhereUniqueInput `json:"where"`
Create AirHistoryDataCreateInput `json:"create"`
Update AirHistoryDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertAirHistoryData (params AirHistoryDataUpsertParams) *AirHistoryDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"AirHistoryDataWhereUniqueInput!", "AirHistoryDataCreateInput!", "AirHistoryDataUpdateInput!","AirHistoryData"},
          "upsertAirHistoryData",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExec{ret}
      }

      func (client *Client) DeleteAirHistoryData (params AirHistoryDataWhereUniqueInput) *AirHistoryDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"AirHistoryDataWhereUniqueInput!", "AirHistoryData"},
          "deleteAirHistoryData",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirHistoryDataExec{ret}
      }

      func (client *Client) DeleteManyAirHistoryDatas (params *AirHistoryDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "AirHistoryDataWhereInput", "deleteManyAirHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateAirLive (params AirLiveCreateInput) *AirLiveExec {
        ret := client.Client.Create(
          params,
          [2]string{"AirLiveCreateInput!", "AirLive"},
          "createAirLive",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExec{ret}
      }

      type AirLiveUpdateParams struct {
        Data AirLiveUpdateInput `json:"data"`
Where AirLiveWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateAirLive (params AirLiveUpdateParams) *AirLiveExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"AirLiveUpdateInput!", "AirLiveWhereUniqueInput!", "AirLive"},
                 "updateAirLive",
                 []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExec{ret}
      }

      type AirLiveUpdateManyParams struct {
        Data AirLiveUpdateManyMutationInput `json:"data"`
Where *AirLiveWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyAirLives (params AirLiveUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"AirLiveUpdateManyMutationInput!", "AirLiveWhereInput"},
          "updateManyAirLives")
        return &BatchPayloadExec{exec}
      }

      type AirLiveUpsertParams struct {
        Where AirLiveWhereUniqueInput `json:"where"`
Create AirLiveCreateInput `json:"create"`
Update AirLiveUpdateInput `json:"update"`
      }
      func (client *Client) UpsertAirLive (params AirLiveUpsertParams) *AirLiveExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"AirLiveWhereUniqueInput!", "AirLiveCreateInput!", "AirLiveUpdateInput!","AirLive"},
          "upsertAirLive",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExec{ret}
      }

      func (client *Client) DeleteAirLive (params AirLiveWhereUniqueInput) *AirLiveExec {
        ret := client.Client.Delete(
          params,
          [2]string{"AirLiveWhereUniqueInput!", "AirLive"},
          "deleteAirLive",
          []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

        return &AirLiveExec{ret}
      }

      func (client *Client) DeleteManyAirLives (params *AirLiveWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "AirLiveWhereInput", "deleteManyAirLives")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateAttendanceRecord (params AttendanceRecordCreateInput) *AttendanceRecordExec {
        ret := client.Client.Create(
          params,
          [2]string{"AttendanceRecordCreateInput!", "AttendanceRecord"},
          "createAttendanceRecord",
          []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExec{ret}
      }

      type AttendanceRecordUpdateParams struct {
        Data AttendanceRecordUpdateInput `json:"data"`
Where AttendanceRecordWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateAttendanceRecord (params AttendanceRecordUpdateParams) *AttendanceRecordExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"AttendanceRecordUpdateInput!", "AttendanceRecordWhereUniqueInput!", "AttendanceRecord"},
                 "updateAttendanceRecord",
                 []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExec{ret}
      }

      type AttendanceRecordUpdateManyParams struct {
        Data AttendanceRecordUpdateManyMutationInput `json:"data"`
Where *AttendanceRecordWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyAttendanceRecords (params AttendanceRecordUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"AttendanceRecordUpdateManyMutationInput!", "AttendanceRecordWhereInput"},
          "updateManyAttendanceRecords")
        return &BatchPayloadExec{exec}
      }

      type AttendanceRecordUpsertParams struct {
        Where AttendanceRecordWhereUniqueInput `json:"where"`
Create AttendanceRecordCreateInput `json:"create"`
Update AttendanceRecordUpdateInput `json:"update"`
      }
      func (client *Client) UpsertAttendanceRecord (params AttendanceRecordUpsertParams) *AttendanceRecordExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"AttendanceRecordWhereUniqueInput!", "AttendanceRecordCreateInput!", "AttendanceRecordUpdateInput!","AttendanceRecord"},
          "upsertAttendanceRecord",
          []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExec{ret}
      }

      func (client *Client) DeleteAttendanceRecord (params AttendanceRecordWhereUniqueInput) *AttendanceRecordExec {
        ret := client.Client.Delete(
          params,
          [2]string{"AttendanceRecordWhereUniqueInput!", "AttendanceRecord"},
          "deleteAttendanceRecord",
          []string{"id","attDate","totalSecond"})

        return &AttendanceRecordExec{ret}
      }

      func (client *Client) DeleteManyAttendanceRecords (params *AttendanceRecordWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "AttendanceRecordWhereInput", "deleteManyAttendanceRecords")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateCityCodeInfo (params CityCodeInfoCreateInput) *CityCodeInfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"CityCodeInfoCreateInput!", "CityCodeInfo"},
          "createCityCodeInfo",
          []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExec{ret}
      }

      type CityCodeInfoUpdateParams struct {
        Data CityCodeInfoUpdateInput `json:"data"`
Where CityCodeInfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateCityCodeInfo (params CityCodeInfoUpdateParams) *CityCodeInfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"CityCodeInfoUpdateInput!", "CityCodeInfoWhereUniqueInput!", "CityCodeInfo"},
                 "updateCityCodeInfo",
                 []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExec{ret}
      }

      type CityCodeInfoUpdateManyParams struct {
        Data CityCodeInfoUpdateManyMutationInput `json:"data"`
Where *CityCodeInfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyCityCodeInfoes (params CityCodeInfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"CityCodeInfoUpdateManyMutationInput!", "CityCodeInfoWhereInput"},
          "updateManyCityCodeInfoes")
        return &BatchPayloadExec{exec}
      }

      type CityCodeInfoUpsertParams struct {
        Where CityCodeInfoWhereUniqueInput `json:"where"`
Create CityCodeInfoCreateInput `json:"create"`
Update CityCodeInfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertCityCodeInfo (params CityCodeInfoUpsertParams) *CityCodeInfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"CityCodeInfoWhereUniqueInput!", "CityCodeInfoCreateInput!", "CityCodeInfoUpdateInput!","CityCodeInfo"},
          "upsertCityCodeInfo",
          []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExec{ret}
      }

      func (client *Client) DeleteCityCodeInfo (params CityCodeInfoWhereUniqueInput) *CityCodeInfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"CityCodeInfoWhereUniqueInput!", "CityCodeInfo"},
          "deleteCityCodeInfo",
          []string{"id","airCitycode","weatherCityCode","cityName"})

        return &CityCodeInfoExec{ret}
      }

      func (client *Client) DeleteManyCityCodeInfoes (params *CityCodeInfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "CityCodeInfoWhereInput", "deleteManyCityCodeInfoes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateDataUnit (params DataUnitCreateInput) *DataUnitExec {
        ret := client.Client.Create(
          params,
          [2]string{"DataUnitCreateInput!", "DataUnit"},
          "createDataUnit",
          []string{"id","dataItem","unit"})

        return &DataUnitExec{ret}
      }

      type DataUnitUpdateParams struct {
        Data DataUnitUpdateInput `json:"data"`
Where DataUnitWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateDataUnit (params DataUnitUpdateParams) *DataUnitExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"DataUnitUpdateInput!", "DataUnitWhereUniqueInput!", "DataUnit"},
                 "updateDataUnit",
                 []string{"id","dataItem","unit"})

        return &DataUnitExec{ret}
      }

      type DataUnitUpdateManyParams struct {
        Data DataUnitUpdateManyMutationInput `json:"data"`
Where *DataUnitWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyDataUnits (params DataUnitUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"DataUnitUpdateManyMutationInput!", "DataUnitWhereInput"},
          "updateManyDataUnits")
        return &BatchPayloadExec{exec}
      }

      type DataUnitUpsertParams struct {
        Where DataUnitWhereUniqueInput `json:"where"`
Create DataUnitCreateInput `json:"create"`
Update DataUnitUpdateInput `json:"update"`
      }
      func (client *Client) UpsertDataUnit (params DataUnitUpsertParams) *DataUnitExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"DataUnitWhereUniqueInput!", "DataUnitCreateInput!", "DataUnitUpdateInput!","DataUnit"},
          "upsertDataUnit",
          []string{"id","dataItem","unit"})

        return &DataUnitExec{ret}
      }

      func (client *Client) DeleteDataUnit (params DataUnitWhereUniqueInput) *DataUnitExec {
        ret := client.Client.Delete(
          params,
          [2]string{"DataUnitWhereUniqueInput!", "DataUnit"},
          "deleteDataUnit",
          []string{"id","dataItem","unit"})

        return &DataUnitExec{ret}
      }

      func (client *Client) DeleteManyDataUnits (params *DataUnitWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "DataUnitWhereInput", "deleteManyDataUnits")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateHistoryData (params HistoryDataCreateInput) *HistoryDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"HistoryDataCreateInput!", "HistoryData"},
          "createHistoryData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExec{ret}
      }

      type HistoryDataUpdateParams struct {
        Data HistoryDataUpdateInput `json:"data"`
Where HistoryDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateHistoryData (params HistoryDataUpdateParams) *HistoryDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"HistoryDataUpdateInput!", "HistoryDataWhereUniqueInput!", "HistoryData"},
                 "updateHistoryData",
                 []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExec{ret}
      }

      type HistoryDataUpdateManyParams struct {
        Data HistoryDataUpdateManyMutationInput `json:"data"`
Where *HistoryDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyHistoryDatas (params HistoryDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"HistoryDataUpdateManyMutationInput!", "HistoryDataWhereInput"},
          "updateManyHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      type HistoryDataUpsertParams struct {
        Where HistoryDataWhereUniqueInput `json:"where"`
Create HistoryDataCreateInput `json:"create"`
Update HistoryDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertHistoryData (params HistoryDataUpsertParams) *HistoryDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"HistoryDataWhereUniqueInput!", "HistoryDataCreateInput!", "HistoryDataUpdateInput!","HistoryData"},
          "upsertHistoryData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExec{ret}
      }

      func (client *Client) DeleteHistoryData (params HistoryDataWhereUniqueInput) *HistoryDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"HistoryDataWhereUniqueInput!", "HistoryData"},
          "deleteHistoryData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

        return &HistoryDataExec{ret}
      }

      func (client *Client) DeleteManyHistoryDatas (params *HistoryDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "HistoryDataWhereInput", "deleteManyHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateIdCardVerifyData (params IDCardVerifyDataCreateInput) *IDCardVerifyDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"IDCardVerifyDataCreateInput!", "IDCardVerifyData"},
          "createIDCardVerifyData",
          []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExec{ret}
      }

      type IDCardVerifyDataUpdateParams struct {
        Data IDCardVerifyDataUpdateInput `json:"data"`
Where IDCardVerifyDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateIdCardVerifyData (params IDCardVerifyDataUpdateParams) *IDCardVerifyDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"IDCardVerifyDataUpdateInput!", "IDCardVerifyDataWhereUniqueInput!", "IDCardVerifyData"},
                 "updateIDCardVerifyData",
                 []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExec{ret}
      }

      type IDCardVerifyDataUpdateManyParams struct {
        Data IDCardVerifyDataUpdateManyMutationInput `json:"data"`
Where *IDCardVerifyDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyIdCardVerifyDatas (params IDCardVerifyDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"IDCardVerifyDataUpdateManyMutationInput!", "IDCardVerifyDataWhereInput"},
          "updateManyIDCardVerifyDatas")
        return &BatchPayloadExec{exec}
      }

      type IDCardVerifyDataUpsertParams struct {
        Where IDCardVerifyDataWhereUniqueInput `json:"where"`
Create IDCardVerifyDataCreateInput `json:"create"`
Update IDCardVerifyDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertIdCardVerifyData (params IDCardVerifyDataUpsertParams) *IDCardVerifyDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"IDCardVerifyDataWhereUniqueInput!", "IDCardVerifyDataCreateInput!", "IDCardVerifyDataUpdateInput!","IDCardVerifyData"},
          "upsertIDCardVerifyData",
          []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExec{ret}
      }

      func (client *Client) DeleteIdCardVerifyData (params IDCardVerifyDataWhereUniqueInput) *IDCardVerifyDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"IDCardVerifyDataWhereUniqueInput!", "IDCardVerifyData"},
          "deleteIDCardVerifyData",
          []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

        return &IDCardVerifyDataExec{ret}
      }

      func (client *Client) DeleteManyIdCardVerifyDatas (params *IDCardVerifyDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "IDCardVerifyDataWhereInput", "deleteManyIDCardVerifyDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateIdVerifyDeviceInfo (params IDVerifyDeviceInfoCreateInput) *IDVerifyDeviceInfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"IDVerifyDeviceInfoCreateInput!", "IDVerifyDeviceInfo"},
          "createIDVerifyDeviceInfo",
          []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExec{ret}
      }

      type IDVerifyDeviceInfoUpdateParams struct {
        Data IDVerifyDeviceInfoUpdateInput `json:"data"`
Where IDVerifyDeviceInfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateIdVerifyDeviceInfo (params IDVerifyDeviceInfoUpdateParams) *IDVerifyDeviceInfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"IDVerifyDeviceInfoUpdateInput!", "IDVerifyDeviceInfoWhereUniqueInput!", "IDVerifyDeviceInfo"},
                 "updateIDVerifyDeviceInfo",
                 []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExec{ret}
      }

      type IDVerifyDeviceInfoUpdateManyParams struct {
        Data IDVerifyDeviceInfoUpdateManyMutationInput `json:"data"`
Where *IDVerifyDeviceInfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyIdVerifyDeviceInfoes (params IDVerifyDeviceInfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"IDVerifyDeviceInfoUpdateManyMutationInput!", "IDVerifyDeviceInfoWhereInput"},
          "updateManyIDVerifyDeviceInfoes")
        return &BatchPayloadExec{exec}
      }

      type IDVerifyDeviceInfoUpsertParams struct {
        Where IDVerifyDeviceInfoWhereUniqueInput `json:"where"`
Create IDVerifyDeviceInfoCreateInput `json:"create"`
Update IDVerifyDeviceInfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertIdVerifyDeviceInfo (params IDVerifyDeviceInfoUpsertParams) *IDVerifyDeviceInfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"IDVerifyDeviceInfoWhereUniqueInput!", "IDVerifyDeviceInfoCreateInput!", "IDVerifyDeviceInfoUpdateInput!","IDVerifyDeviceInfo"},
          "upsertIDVerifyDeviceInfo",
          []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExec{ret}
      }

      func (client *Client) DeleteIdVerifyDeviceInfo (params IDVerifyDeviceInfoWhereUniqueInput) *IDVerifyDeviceInfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"IDVerifyDeviceInfoWhereUniqueInput!", "IDVerifyDeviceInfo"},
          "deleteIDVerifyDeviceInfo",
          []string{"id","devNo","devName","devAddr"})

        return &IDVerifyDeviceInfoExec{ret}
      }

      func (client *Client) DeleteManyIdVerifyDeviceInfoes (params *IDVerifyDeviceInfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "IDVerifyDeviceInfoWhereInput", "deleteManyIDVerifyDeviceInfoes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateLocationInfo (params LocationInfoCreateInput) *LocationInfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"LocationInfoCreateInput!", "LocationInfo"},
          "createLocationInfo",
          []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExec{ret}
      }

      type LocationInfoUpdateParams struct {
        Data LocationInfoUpdateInput `json:"data"`
Where LocationInfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateLocationInfo (params LocationInfoUpdateParams) *LocationInfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"LocationInfoUpdateInput!", "LocationInfoWhereUniqueInput!", "LocationInfo"},
                 "updateLocationInfo",
                 []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExec{ret}
      }

      type LocationInfoUpdateManyParams struct {
        Data LocationInfoUpdateManyMutationInput `json:"data"`
Where *LocationInfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyLocationInfoes (params LocationInfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"LocationInfoUpdateManyMutationInput!", "LocationInfoWhereInput"},
          "updateManyLocationInfoes")
        return &BatchPayloadExec{exec}
      }

      type LocationInfoUpsertParams struct {
        Where LocationInfoWhereUniqueInput `json:"where"`
Create LocationInfoCreateInput `json:"create"`
Update LocationInfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertLocationInfo (params LocationInfoUpsertParams) *LocationInfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"LocationInfoWhereUniqueInput!", "LocationInfoCreateInput!", "LocationInfoUpdateInput!","LocationInfo"},
          "upsertLocationInfo",
          []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExec{ret}
      }

      func (client *Client) DeleteLocationInfo (params LocationInfoWhereUniqueInput) *LocationInfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"LocationInfoWhereUniqueInput!", "LocationInfo"},
          "deleteLocationInfo",
          []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

        return &LocationInfoExec{ret}
      }

      func (client *Client) DeleteManyLocationInfoes (params *LocationInfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "LocationInfoWhereInput", "deleteManyLocationInfoes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateMacProbeData (params MacProbeDataCreateInput) *MacProbeDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"MACProbeDataCreateInput!", "MACProbeData"},
          "createMACProbeData",
          []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExec{ret}
      }

      type MacProbeDataUpdateParams struct {
        Data MacProbeDataUpdateInput `json:"data"`
Where MacProbeDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateMacProbeData (params MacProbeDataUpdateParams) *MacProbeDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"MACProbeDataUpdateInput!", "MACProbeDataWhereUniqueInput!", "MACProbeData"},
                 "updateMACProbeData",
                 []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExec{ret}
      }

      type MacProbeDataUpdateManyParams struct {
        Data MacProbeDataUpdateManyMutationInput `json:"data"`
Where *MacProbeDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyMacProbeDatas (params MacProbeDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"MACProbeDataUpdateManyMutationInput!", "MACProbeDataWhereInput"},
          "updateManyMACProbeDatas")
        return &BatchPayloadExec{exec}
      }

      type MacProbeDataUpsertParams struct {
        Where MacProbeDataWhereUniqueInput `json:"where"`
Create MacProbeDataCreateInput `json:"create"`
Update MacProbeDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertMacProbeData (params MacProbeDataUpsertParams) *MacProbeDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"MACProbeDataWhereUniqueInput!", "MACProbeDataCreateInput!", "MACProbeDataUpdateInput!","MACProbeData"},
          "upsertMACProbeData",
          []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExec{ret}
      }

      func (client *Client) DeleteMacProbeData (params MacProbeDataWhereUniqueInput) *MacProbeDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"MACProbeDataWhereUniqueInput!", "MACProbeData"},
          "deleteMACProbeData",
          []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

        return &MacProbeDataExec{ret}
      }

      func (client *Client) DeleteManyMacProbeDatas (params *MacProbeDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "MACProbeDataWhereInput", "deleteManyMACProbeDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateMacProbeRecord (params MacProbeRecordCreateInput) *MacProbeRecordExec {
        ret := client.Client.Create(
          params,
          [2]string{"MACProbeRecordCreateInput!", "MACProbeRecord"},
          "createMACProbeRecord",
          []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExec{ret}
      }

      type MacProbeRecordUpdateParams struct {
        Data MacProbeRecordUpdateInput `json:"data"`
Where MacProbeRecordWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateMacProbeRecord (params MacProbeRecordUpdateParams) *MacProbeRecordExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"MACProbeRecordUpdateInput!", "MACProbeRecordWhereUniqueInput!", "MACProbeRecord"},
                 "updateMACProbeRecord",
                 []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExec{ret}
      }

      type MacProbeRecordUpdateManyParams struct {
        Data MacProbeRecordUpdateManyMutationInput `json:"data"`
Where *MacProbeRecordWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyMacProbeRecords (params MacProbeRecordUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"MACProbeRecordUpdateManyMutationInput!", "MACProbeRecordWhereInput"},
          "updateManyMACProbeRecords")
        return &BatchPayloadExec{exec}
      }

      type MacProbeRecordUpsertParams struct {
        Where MacProbeRecordWhereUniqueInput `json:"where"`
Create MacProbeRecordCreateInput `json:"create"`
Update MacProbeRecordUpdateInput `json:"update"`
      }
      func (client *Client) UpsertMacProbeRecord (params MacProbeRecordUpsertParams) *MacProbeRecordExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"MACProbeRecordWhereUniqueInput!", "MACProbeRecordCreateInput!", "MACProbeRecordUpdateInput!","MACProbeRecord"},
          "upsertMACProbeRecord",
          []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExec{ret}
      }

      func (client *Client) DeleteMacProbeRecord (params MacProbeRecordWhereUniqueInput) *MacProbeRecordExec {
        ret := client.Client.Delete(
          params,
          [2]string{"MACProbeRecordWhereUniqueInput!", "MACProbeRecord"},
          "deleteMACProbeRecord",
          []string{"id","mac","devNo","entryTime","departureTime"})

        return &MacProbeRecordExec{ret}
      }

      func (client *Client) DeleteManyMacProbeRecords (params *MacProbeRecordWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "MACProbeRecordWhereInput", "deleteManyMACProbeRecords")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateMaCinfo (params MaCinfoCreateInput) *MaCinfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"MACinfoCreateInput!", "MACinfo"},
          "createMACinfo",
          []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExec{ret}
      }

      type MaCinfoUpdateParams struct {
        Data MaCinfoUpdateInput `json:"data"`
Where MaCinfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateMaCinfo (params MaCinfoUpdateParams) *MaCinfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"MACinfoUpdateInput!", "MACinfoWhereUniqueInput!", "MACinfo"},
                 "updateMACinfo",
                 []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExec{ret}
      }

      type MaCinfoUpdateManyParams struct {
        Data MaCinfoUpdateManyMutationInput `json:"data"`
Where *MaCinfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyMaCinfoes (params MaCinfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"MACinfoUpdateManyMutationInput!", "MACinfoWhereInput"},
          "updateManyMACinfoes")
        return &BatchPayloadExec{exec}
      }

      type MaCinfoUpsertParams struct {
        Where MaCinfoWhereUniqueInput `json:"where"`
Create MaCinfoCreateInput `json:"create"`
Update MaCinfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertMaCinfo (params MaCinfoUpsertParams) *MaCinfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"MACinfoWhereUniqueInput!", "MACinfoCreateInput!", "MACinfoUpdateInput!","MACinfo"},
          "upsertMACinfo",
          []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExec{ret}
      }

      func (client *Client) DeleteMaCinfo (params MaCinfoWhereUniqueInput) *MaCinfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"MACinfoWhereUniqueInput!", "MACinfo"},
          "deleteMACinfo",
          []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

        return &MaCinfoExec{ret}
      }

      func (client *Client) DeleteManyMaCinfoes (params *MaCinfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "MACinfoWhereInput", "deleteManyMACinfoes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateMonitorNode (params MonitorNodeCreateInput) *MonitorNodeExec {
        ret := client.Client.Create(
          params,
          [2]string{"MonitorNodeCreateInput!", "MonitorNode"},
          "createMonitorNode",
          []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExec{ret}
      }

      type MonitorNodeUpdateParams struct {
        Data MonitorNodeUpdateInput `json:"data"`
Where MonitorNodeWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateMonitorNode (params MonitorNodeUpdateParams) *MonitorNodeExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"MonitorNodeUpdateInput!", "MonitorNodeWhereUniqueInput!", "MonitorNode"},
                 "updateMonitorNode",
                 []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExec{ret}
      }

      type MonitorNodeUpdateManyParams struct {
        Data MonitorNodeUpdateManyMutationInput `json:"data"`
Where *MonitorNodeWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyMonitorNodes (params MonitorNodeUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"MonitorNodeUpdateManyMutationInput!", "MonitorNodeWhereInput"},
          "updateManyMonitorNodes")
        return &BatchPayloadExec{exec}
      }

      type MonitorNodeUpsertParams struct {
        Where MonitorNodeWhereUniqueInput `json:"where"`
Create MonitorNodeCreateInput `json:"create"`
Update MonitorNodeUpdateInput `json:"update"`
      }
      func (client *Client) UpsertMonitorNode (params MonitorNodeUpsertParams) *MonitorNodeExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"MonitorNodeWhereUniqueInput!", "MonitorNodeCreateInput!", "MonitorNodeUpdateInput!","MonitorNode"},
          "upsertMonitorNode",
          []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExec{ret}
      }

      func (client *Client) DeleteMonitorNode (params MonitorNodeWhereUniqueInput) *MonitorNodeExec {
        ret := client.Client.Delete(
          params,
          [2]string{"MonitorNodeWhereUniqueInput!", "MonitorNode"},
          "deleteMonitorNode",
          []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

        return &MonitorNodeExec{ret}
      }

      func (client *Client) DeleteManyMonitorNodes (params *MonitorNodeWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "MonitorNodeWhereInput", "deleteManyMonitorNodes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreatePersonInfo (params PersonInfoCreateInput) *PersonInfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"PersonInfoCreateInput!", "PersonInfo"},
          "createPersonInfo",
          []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExec{ret}
      }

      type PersonInfoUpdateParams struct {
        Data PersonInfoUpdateInput `json:"data"`
Where PersonInfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdatePersonInfo (params PersonInfoUpdateParams) *PersonInfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"PersonInfoUpdateInput!", "PersonInfoWhereUniqueInput!", "PersonInfo"},
                 "updatePersonInfo",
                 []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExec{ret}
      }

      type PersonInfoUpdateManyParams struct {
        Data PersonInfoUpdateManyMutationInput `json:"data"`
Where *PersonInfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyPersonInfoes (params PersonInfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"PersonInfoUpdateManyMutationInput!", "PersonInfoWhereInput"},
          "updateManyPersonInfoes")
        return &BatchPayloadExec{exec}
      }

      type PersonInfoUpsertParams struct {
        Where PersonInfoWhereUniqueInput `json:"where"`
Create PersonInfoCreateInput `json:"create"`
Update PersonInfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertPersonInfo (params PersonInfoUpsertParams) *PersonInfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"PersonInfoWhereUniqueInput!", "PersonInfoCreateInput!", "PersonInfoUpdateInput!","PersonInfo"},
          "upsertPersonInfo",
          []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExec{ret}
      }

      func (client *Client) DeletePersonInfo (params PersonInfoWhereUniqueInput) *PersonInfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"PersonInfoWhereUniqueInput!", "PersonInfo"},
          "deletePersonInfo",
          []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

        return &PersonInfoExec{ret}
      }

      func (client *Client) DeleteManyPersonInfoes (params *PersonInfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "PersonInfoWhereInput", "deleteManyPersonInfoes")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateRealTimeData (params RealTimeDataCreateInput) *RealTimeDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"RealTimeDataCreateInput!", "RealTimeData"},
          "createRealTimeData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExec{ret}
      }

      type RealTimeDataUpdateParams struct {
        Data RealTimeDataUpdateInput `json:"data"`
Where RealTimeDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateRealTimeData (params RealTimeDataUpdateParams) *RealTimeDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"RealTimeDataUpdateInput!", "RealTimeDataWhereUniqueInput!", "RealTimeData"},
                 "updateRealTimeData",
                 []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExec{ret}
      }

      type RealTimeDataUpdateManyParams struct {
        Data RealTimeDataUpdateManyMutationInput `json:"data"`
Where *RealTimeDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyRealTimeDatas (params RealTimeDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"RealTimeDataUpdateManyMutationInput!", "RealTimeDataWhereInput"},
          "updateManyRealTimeDatas")
        return &BatchPayloadExec{exec}
      }

      type RealTimeDataUpsertParams struct {
        Where RealTimeDataWhereUniqueInput `json:"where"`
Create RealTimeDataCreateInput `json:"create"`
Update RealTimeDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertRealTimeData (params RealTimeDataUpsertParams) *RealTimeDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"RealTimeDataWhereUniqueInput!", "RealTimeDataCreateInput!", "RealTimeDataUpdateInput!","RealTimeData"},
          "upsertRealTimeData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExec{ret}
      }

      func (client *Client) DeleteRealTimeData (params RealTimeDataWhereUniqueInput) *RealTimeDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"RealTimeDataWhereUniqueInput!", "RealTimeData"},
          "deleteRealTimeData",
          []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

        return &RealTimeDataExec{ret}
      }

      func (client *Client) DeleteManyRealTimeDatas (params *RealTimeDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "RealTimeDataWhereInput", "deleteManyRealTimeDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateWeatherAirHistory (params WeatherAirHistoryCreateInput) *WeatherAirHistoryExec {
        ret := client.Client.Create(
          params,
          [2]string{"WeatherAirHistoryCreateInput!", "WeatherAirHistory"},
          "createWeatherAirHistory",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExec{ret}
      }

      type WeatherAirHistoryUpdateParams struct {
        Data WeatherAirHistoryUpdateInput `json:"data"`
Where WeatherAirHistoryWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateWeatherAirHistory (params WeatherAirHistoryUpdateParams) *WeatherAirHistoryExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"WeatherAirHistoryUpdateInput!", "WeatherAirHistoryWhereUniqueInput!", "WeatherAirHistory"},
                 "updateWeatherAirHistory",
                 []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExec{ret}
      }

      type WeatherAirHistoryUpdateManyParams struct {
        Data WeatherAirHistoryUpdateManyMutationInput `json:"data"`
Where *WeatherAirHistoryWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyWeatherAirHistories (params WeatherAirHistoryUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"WeatherAirHistoryUpdateManyMutationInput!", "WeatherAirHistoryWhereInput"},
          "updateManyWeatherAirHistories")
        return &BatchPayloadExec{exec}
      }

      type WeatherAirHistoryUpsertParams struct {
        Where WeatherAirHistoryWhereUniqueInput `json:"where"`
Create WeatherAirHistoryCreateInput `json:"create"`
Update WeatherAirHistoryUpdateInput `json:"update"`
      }
      func (client *Client) UpsertWeatherAirHistory (params WeatherAirHistoryUpsertParams) *WeatherAirHistoryExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"WeatherAirHistoryWhereUniqueInput!", "WeatherAirHistoryCreateInput!", "WeatherAirHistoryUpdateInput!","WeatherAirHistory"},
          "upsertWeatherAirHistory",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExec{ret}
      }

      func (client *Client) DeleteWeatherAirHistory (params WeatherAirHistoryWhereUniqueInput) *WeatherAirHistoryExec {
        ret := client.Client.Delete(
          params,
          [2]string{"WeatherAirHistoryWhereUniqueInput!", "WeatherAirHistory"},
          "deleteWeatherAirHistory",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirHistoryExec{ret}
      }

      func (client *Client) DeleteManyWeatherAirHistories (params *WeatherAirHistoryWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "WeatherAirHistoryWhereInput", "deleteManyWeatherAirHistories")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateWeatherAirLive (params WeatherAirLiveCreateInput) *WeatherAirLiveExec {
        ret := client.Client.Create(
          params,
          [2]string{"WeatherAirLiveCreateInput!", "WeatherAirLive"},
          "createWeatherAirLive",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExec{ret}
      }

      type WeatherAirLiveUpdateParams struct {
        Data WeatherAirLiveUpdateInput `json:"data"`
Where WeatherAirLiveWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateWeatherAirLive (params WeatherAirLiveUpdateParams) *WeatherAirLiveExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"WeatherAirLiveUpdateInput!", "WeatherAirLiveWhereUniqueInput!", "WeatherAirLive"},
                 "updateWeatherAirLive",
                 []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExec{ret}
      }

      type WeatherAirLiveUpdateManyParams struct {
        Data WeatherAirLiveUpdateManyMutationInput `json:"data"`
Where *WeatherAirLiveWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyWeatherAirLives (params WeatherAirLiveUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"WeatherAirLiveUpdateManyMutationInput!", "WeatherAirLiveWhereInput"},
          "updateManyWeatherAirLives")
        return &BatchPayloadExec{exec}
      }

      type WeatherAirLiveUpsertParams struct {
        Where WeatherAirLiveWhereUniqueInput `json:"where"`
Create WeatherAirLiveCreateInput `json:"create"`
Update WeatherAirLiveUpdateInput `json:"update"`
      }
      func (client *Client) UpsertWeatherAirLive (params WeatherAirLiveUpsertParams) *WeatherAirLiveExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"WeatherAirLiveWhereUniqueInput!", "WeatherAirLiveCreateInput!", "WeatherAirLiveUpdateInput!","WeatherAirLive"},
          "upsertWeatherAirLive",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExec{ret}
      }

      func (client *Client) DeleteWeatherAirLive (params WeatherAirLiveWhereUniqueInput) *WeatherAirLiveExec {
        ret := client.Client.Delete(
          params,
          [2]string{"WeatherAirLiveWhereUniqueInput!", "WeatherAirLive"},
          "deleteWeatherAirLive",
          []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

        return &WeatherAirLiveExec{ret}
      }

      func (client *Client) DeleteManyWeatherAirLives (params *WeatherAirLiveWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "WeatherAirLiveWhereInput", "deleteManyWeatherAirLives")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateWeatherHistoryData (params WeatherHistoryDataCreateInput) *WeatherHistoryDataExec {
        ret := client.Client.Create(
          params,
          [2]string{"WeatherHistoryDataCreateInput!", "WeatherHistoryData"},
          "createWeatherHistoryData",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExec{ret}
      }

      type WeatherHistoryDataUpdateParams struct {
        Data WeatherHistoryDataUpdateInput `json:"data"`
Where WeatherHistoryDataWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateWeatherHistoryData (params WeatherHistoryDataUpdateParams) *WeatherHistoryDataExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"WeatherHistoryDataUpdateInput!", "WeatherHistoryDataWhereUniqueInput!", "WeatherHistoryData"},
                 "updateWeatherHistoryData",
                 []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExec{ret}
      }

      type WeatherHistoryDataUpdateManyParams struct {
        Data WeatherHistoryDataUpdateManyMutationInput `json:"data"`
Where *WeatherHistoryDataWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyWeatherHistoryDatas (params WeatherHistoryDataUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"WeatherHistoryDataUpdateManyMutationInput!", "WeatherHistoryDataWhereInput"},
          "updateManyWeatherHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      type WeatherHistoryDataUpsertParams struct {
        Where WeatherHistoryDataWhereUniqueInput `json:"where"`
Create WeatherHistoryDataCreateInput `json:"create"`
Update WeatherHistoryDataUpdateInput `json:"update"`
      }
      func (client *Client) UpsertWeatherHistoryData (params WeatherHistoryDataUpsertParams) *WeatherHistoryDataExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"WeatherHistoryDataWhereUniqueInput!", "WeatherHistoryDataCreateInput!", "WeatherHistoryDataUpdateInput!","WeatherHistoryData"},
          "upsertWeatherHistoryData",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExec{ret}
      }

      func (client *Client) DeleteWeatherHistoryData (params WeatherHistoryDataWhereUniqueInput) *WeatherHistoryDataExec {
        ret := client.Client.Delete(
          params,
          [2]string{"WeatherHistoryDataWhereUniqueInput!", "WeatherHistoryData"},
          "deleteWeatherHistoryData",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherHistoryDataExec{ret}
      }

      func (client *Client) DeleteManyWeatherHistoryDatas (params *WeatherHistoryDataWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "WeatherHistoryDataWhereInput", "deleteManyWeatherHistoryDatas")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateWeatherLive (params WeatherLiveCreateInput) *WeatherLiveExec {
        ret := client.Client.Create(
          params,
          [2]string{"WeatherLiveCreateInput!", "WeatherLive"},
          "createWeatherLive",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExec{ret}
      }

      type WeatherLiveUpdateParams struct {
        Data WeatherLiveUpdateInput `json:"data"`
Where WeatherLiveWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateWeatherLive (params WeatherLiveUpdateParams) *WeatherLiveExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"WeatherLiveUpdateInput!", "WeatherLiveWhereUniqueInput!", "WeatherLive"},
                 "updateWeatherLive",
                 []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExec{ret}
      }

      type WeatherLiveUpdateManyParams struct {
        Data WeatherLiveUpdateManyMutationInput `json:"data"`
Where *WeatherLiveWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyWeatherLives (params WeatherLiveUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"WeatherLiveUpdateManyMutationInput!", "WeatherLiveWhereInput"},
          "updateManyWeatherLives")
        return &BatchPayloadExec{exec}
      }

      type WeatherLiveUpsertParams struct {
        Where WeatherLiveWhereUniqueInput `json:"where"`
Create WeatherLiveCreateInput `json:"create"`
Update WeatherLiveUpdateInput `json:"update"`
      }
      func (client *Client) UpsertWeatherLive (params WeatherLiveUpsertParams) *WeatherLiveExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"WeatherLiveWhereUniqueInput!", "WeatherLiveCreateInput!", "WeatherLiveUpdateInput!","WeatherLive"},
          "upsertWeatherLive",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExec{ret}
      }

      func (client *Client) DeleteWeatherLive (params WeatherLiveWhereUniqueInput) *WeatherLiveExec {
        ret := client.Client.Delete(
          params,
          [2]string{"WeatherLiveWhereUniqueInput!", "WeatherLive"},
          "deleteWeatherLive",
          []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

        return &WeatherLiveExec{ret}
      }

      func (client *Client) DeleteManyWeatherLives (params *WeatherLiveWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "WeatherLiveWhereInput", "deleteManyWeatherLives")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateWiFiProberinfo (params WiFiProberinfoCreateInput) *WiFiProberinfoExec {
        ret := client.Client.Create(
          params,
          [2]string{"WiFiProberinfoCreateInput!", "WiFiProberinfo"},
          "createWiFiProberinfo",
          []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExec{ret}
      }

      type WiFiProberinfoUpdateParams struct {
        Data WiFiProberinfoUpdateInput `json:"data"`
Where WiFiProberinfoWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateWiFiProberinfo (params WiFiProberinfoUpdateParams) *WiFiProberinfoExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"WiFiProberinfoUpdateInput!", "WiFiProberinfoWhereUniqueInput!", "WiFiProberinfo"},
                 "updateWiFiProberinfo",
                 []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExec{ret}
      }

      type WiFiProberinfoUpdateManyParams struct {
        Data WiFiProberinfoUpdateManyMutationInput `json:"data"`
Where *WiFiProberinfoWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyWiFiProberinfoes (params WiFiProberinfoUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"WiFiProberinfoUpdateManyMutationInput!", "WiFiProberinfoWhereInput"},
          "updateManyWiFiProberinfoes")
        return &BatchPayloadExec{exec}
      }

      type WiFiProberinfoUpsertParams struct {
        Where WiFiProberinfoWhereUniqueInput `json:"where"`
Create WiFiProberinfoCreateInput `json:"create"`
Update WiFiProberinfoUpdateInput `json:"update"`
      }
      func (client *Client) UpsertWiFiProberinfo (params WiFiProberinfoUpsertParams) *WiFiProberinfoExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"WiFiProberinfoWhereUniqueInput!", "WiFiProberinfoCreateInput!", "WiFiProberinfoUpdateInput!","WiFiProberinfo"},
          "upsertWiFiProberinfo",
          []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExec{ret}
      }

      func (client *Client) DeleteWiFiProberinfo (params WiFiProberinfoWhereUniqueInput) *WiFiProberinfoExec {
        ret := client.Client.Delete(
          params,
          [2]string{"WiFiProberinfoWhereUniqueInput!", "WiFiProberinfo"},
          "deleteWiFiProberinfo",
          []string{"id","devNo","devMac","devMdoel"})

        return &WiFiProberinfoExec{ret}
      }

      func (client *Client) DeleteManyWiFiProberinfoes (params *WiFiProberinfoWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "WiFiProberinfoWhereInput", "deleteManyWiFiProberinfoes")
        return &BatchPayloadExec{exec}
      }


        type WeatherHistoryDataOrderByInput string
        const (
          WeatherHistoryDataOrderByInputIDAsc WeatherHistoryDataOrderByInput = "id_ASC"
WeatherHistoryDataOrderByInputIDDesc WeatherHistoryDataOrderByInput = "id_DESC"
WeatherHistoryDataOrderByInputCitycodeAsc WeatherHistoryDataOrderByInput = "citycode_ASC"
WeatherHistoryDataOrderByInputCitycodeDesc WeatherHistoryDataOrderByInput = "citycode_DESC"
WeatherHistoryDataOrderByInputUpdatedAtAsc WeatherHistoryDataOrderByInput = "updatedAt_ASC"
WeatherHistoryDataOrderByInputUpdatedAtDesc WeatherHistoryDataOrderByInput = "updatedAt_DESC"
WeatherHistoryDataOrderByInputWindspeedAsc WeatherHistoryDataOrderByInput = "windspeed_ASC"
WeatherHistoryDataOrderByInputWindspeedDesc WeatherHistoryDataOrderByInput = "windspeed_DESC"
WeatherHistoryDataOrderByInputAirpressureAsc WeatherHistoryDataOrderByInput = "airpressure_ASC"
WeatherHistoryDataOrderByInputAirpressureDesc WeatherHistoryDataOrderByInput = "airpressure_DESC"
WeatherHistoryDataOrderByInputPhenomenaAsc WeatherHistoryDataOrderByInput = "phenomena_ASC"
WeatherHistoryDataOrderByInputPhenomenaDesc WeatherHistoryDataOrderByInput = "phenomena_DESC"
WeatherHistoryDataOrderByInputRdescAsc WeatherHistoryDataOrderByInput = "rdesc_ASC"
WeatherHistoryDataOrderByInputRdescDesc WeatherHistoryDataOrderByInput = "rdesc_DESC"
WeatherHistoryDataOrderByInputHumidityAsc WeatherHistoryDataOrderByInput = "humidity_ASC"
WeatherHistoryDataOrderByInputHumidityDesc WeatherHistoryDataOrderByInput = "humidity_DESC"
WeatherHistoryDataOrderByInputUpdatetimeAsc WeatherHistoryDataOrderByInput = "updatetime_ASC"
WeatherHistoryDataOrderByInputUpdatetimeDesc WeatherHistoryDataOrderByInput = "updatetime_DESC"
WeatherHistoryDataOrderByInputWindpowerAsc WeatherHistoryDataOrderByInput = "windpower_ASC"
WeatherHistoryDataOrderByInputWindpowerDesc WeatherHistoryDataOrderByInput = "windpower_DESC"
WeatherHistoryDataOrderByInputFeelstAsc WeatherHistoryDataOrderByInput = "feelst_ASC"
WeatherHistoryDataOrderByInputFeelstDesc WeatherHistoryDataOrderByInput = "feelst_DESC"
WeatherHistoryDataOrderByInputWinddirectAsc WeatherHistoryDataOrderByInput = "winddirect_ASC"
WeatherHistoryDataOrderByInputWinddirectDesc WeatherHistoryDataOrderByInput = "winddirect_DESC"
WeatherHistoryDataOrderByInputRcodeAsc WeatherHistoryDataOrderByInput = "rcode_ASC"
WeatherHistoryDataOrderByInputRcodeDesc WeatherHistoryDataOrderByInput = "rcode_DESC"
WeatherHistoryDataOrderByInputRainAsc WeatherHistoryDataOrderByInput = "rain_ASC"
WeatherHistoryDataOrderByInputRainDesc WeatherHistoryDataOrderByInput = "rain_DESC"
WeatherHistoryDataOrderByInputTemperatureAsc WeatherHistoryDataOrderByInput = "temperature_ASC"
WeatherHistoryDataOrderByInputTemperatureDesc WeatherHistoryDataOrderByInput = "temperature_DESC"
          )

        type HistoryDataOrderByInput string
        const (
          HistoryDataOrderByInputIDAsc HistoryDataOrderByInput = "id_ASC"
HistoryDataOrderByInputIDDesc HistoryDataOrderByInput = "id_DESC"
HistoryDataOrderByInputRcvTimeAsc HistoryDataOrderByInput = "rcvTime_ASC"
HistoryDataOrderByInputRcvTimeDesc HistoryDataOrderByInput = "rcvTime_DESC"
HistoryDataOrderByInputWindSpeedAsc HistoryDataOrderByInput = "windSpeed_ASC"
HistoryDataOrderByInputWindSpeedDesc HistoryDataOrderByInput = "windSpeed_DESC"
HistoryDataOrderByInputWindDirectionAsc HistoryDataOrderByInput = "windDirection_ASC"
HistoryDataOrderByInputWindDirectionDesc HistoryDataOrderByInput = "windDirection_DESC"
HistoryDataOrderByInputTemperatureAsc HistoryDataOrderByInput = "temperature_ASC"
HistoryDataOrderByInputTemperatureDesc HistoryDataOrderByInput = "temperature_DESC"
HistoryDataOrderByInputHumidityAsc HistoryDataOrderByInput = "humidity_ASC"
HistoryDataOrderByInputHumidityDesc HistoryDataOrderByInput = "humidity_DESC"
HistoryDataOrderByInputNoiseAsc HistoryDataOrderByInput = "noise_ASC"
HistoryDataOrderByInputNoiseDesc HistoryDataOrderByInput = "noise_DESC"
HistoryDataOrderByInputPm2Asc HistoryDataOrderByInput = "pm2_ASC"
HistoryDataOrderByInputPm2Desc HistoryDataOrderByInput = "pm2_DESC"
HistoryDataOrderByInputPm10Asc HistoryDataOrderByInput = "pm10_ASC"
HistoryDataOrderByInputPm10Desc HistoryDataOrderByInput = "pm10_DESC"
HistoryDataOrderByInputCoAsc HistoryDataOrderByInput = "co_ASC"
HistoryDataOrderByInputCoDesc HistoryDataOrderByInput = "co_DESC"
HistoryDataOrderByInputCo2Asc HistoryDataOrderByInput = "co2_ASC"
HistoryDataOrderByInputCo2Desc HistoryDataOrderByInput = "co2_DESC"
HistoryDataOrderByInputAirPressureAsc HistoryDataOrderByInput = "airPressure_ASC"
HistoryDataOrderByInputAirPressureDesc HistoryDataOrderByInput = "airPressure_DESC"
HistoryDataOrderByInputSunLightAsc HistoryDataOrderByInput = "sunLight_ASC"
HistoryDataOrderByInputSunLightDesc HistoryDataOrderByInput = "sunLight_DESC"
HistoryDataOrderByInputCreatedAtAsc HistoryDataOrderByInput = "createdAt_ASC"
HistoryDataOrderByInputCreatedAtDesc HistoryDataOrderByInput = "createdAt_DESC"
          )

        type AirHistoryDataOrderByInput string
        const (
          AirHistoryDataOrderByInputIDAsc AirHistoryDataOrderByInput = "id_ASC"
AirHistoryDataOrderByInputIDDesc AirHistoryDataOrderByInput = "id_DESC"
AirHistoryDataOrderByInputCitycodeAsc AirHistoryDataOrderByInput = "citycode_ASC"
AirHistoryDataOrderByInputCitycodeDesc AirHistoryDataOrderByInput = "citycode_DESC"
AirHistoryDataOrderByInputPm25Asc AirHistoryDataOrderByInput = "PM25_ASC"
AirHistoryDataOrderByInputPm25Desc AirHistoryDataOrderByInput = "PM25_DESC"
AirHistoryDataOrderByInputTimeAsc AirHistoryDataOrderByInput = "time_ASC"
AirHistoryDataOrderByInputTimeDesc AirHistoryDataOrderByInput = "time_DESC"
AirHistoryDataOrderByInputRdescAsc AirHistoryDataOrderByInput = "rdesc_ASC"
AirHistoryDataOrderByInputRdescDesc AirHistoryDataOrderByInput = "rdesc_DESC"
AirHistoryDataOrderByInputPm10Asc AirHistoryDataOrderByInput = "PM10_ASC"
AirHistoryDataOrderByInputPm10Desc AirHistoryDataOrderByInput = "PM10_DESC"
AirHistoryDataOrderByInputSo2Asc AirHistoryDataOrderByInput = "SO2_ASC"
AirHistoryDataOrderByInputSo2Desc AirHistoryDataOrderByInput = "SO2_DESC"
AirHistoryDataOrderByInputO3Asc AirHistoryDataOrderByInput = "o3_ASC"
AirHistoryDataOrderByInputO3Desc AirHistoryDataOrderByInput = "o3_DESC"
AirHistoryDataOrderByInputNo2Asc AirHistoryDataOrderByInput = "NO2_ASC"
AirHistoryDataOrderByInputNo2Desc AirHistoryDataOrderByInput = "NO2_DESC"
AirHistoryDataOrderByInputPrimaryAsc AirHistoryDataOrderByInput = "primary_ASC"
AirHistoryDataOrderByInputPrimaryDesc AirHistoryDataOrderByInput = "primary_DESC"
AirHistoryDataOrderByInputRcodeAsc AirHistoryDataOrderByInput = "rcode_ASC"
AirHistoryDataOrderByInputRcodeDesc AirHistoryDataOrderByInput = "rcode_DESC"
AirHistoryDataOrderByInputCoAsc AirHistoryDataOrderByInput = "CO_ASC"
AirHistoryDataOrderByInputCoDesc AirHistoryDataOrderByInput = "CO_DESC"
AirHistoryDataOrderByInputAqiAsc AirHistoryDataOrderByInput = "AQI_ASC"
AirHistoryDataOrderByInputAqiDesc AirHistoryDataOrderByInput = "AQI_DESC"
          )

        type WeatherLiveOrderByInput string
        const (
          WeatherLiveOrderByInputIDAsc WeatherLiveOrderByInput = "id_ASC"
WeatherLiveOrderByInputIDDesc WeatherLiveOrderByInput = "id_DESC"
WeatherLiveOrderByInputCitycodeAsc WeatherLiveOrderByInput = "citycode_ASC"
WeatherLiveOrderByInputCitycodeDesc WeatherLiveOrderByInput = "citycode_DESC"
WeatherLiveOrderByInputUpdatedAtAsc WeatherLiveOrderByInput = "updatedAt_ASC"
WeatherLiveOrderByInputUpdatedAtDesc WeatherLiveOrderByInput = "updatedAt_DESC"
WeatherLiveOrderByInputWindspeedAsc WeatherLiveOrderByInput = "windspeed_ASC"
WeatherLiveOrderByInputWindspeedDesc WeatherLiveOrderByInput = "windspeed_DESC"
WeatherLiveOrderByInputAirpressureAsc WeatherLiveOrderByInput = "airpressure_ASC"
WeatherLiveOrderByInputAirpressureDesc WeatherLiveOrderByInput = "airpressure_DESC"
WeatherLiveOrderByInputPhenomenaAsc WeatherLiveOrderByInput = "phenomena_ASC"
WeatherLiveOrderByInputPhenomenaDesc WeatherLiveOrderByInput = "phenomena_DESC"
WeatherLiveOrderByInputRdescAsc WeatherLiveOrderByInput = "rdesc_ASC"
WeatherLiveOrderByInputRdescDesc WeatherLiveOrderByInput = "rdesc_DESC"
WeatherLiveOrderByInputHumidityAsc WeatherLiveOrderByInput = "humidity_ASC"
WeatherLiveOrderByInputHumidityDesc WeatherLiveOrderByInput = "humidity_DESC"
WeatherLiveOrderByInputUpdatetimeAsc WeatherLiveOrderByInput = "updatetime_ASC"
WeatherLiveOrderByInputUpdatetimeDesc WeatherLiveOrderByInput = "updatetime_DESC"
WeatherLiveOrderByInputWindpowerAsc WeatherLiveOrderByInput = "windpower_ASC"
WeatherLiveOrderByInputWindpowerDesc WeatherLiveOrderByInput = "windpower_DESC"
WeatherLiveOrderByInputFeelstAsc WeatherLiveOrderByInput = "feelst_ASC"
WeatherLiveOrderByInputFeelstDesc WeatherLiveOrderByInput = "feelst_DESC"
WeatherLiveOrderByInputWinddirectAsc WeatherLiveOrderByInput = "winddirect_ASC"
WeatherLiveOrderByInputWinddirectDesc WeatherLiveOrderByInput = "winddirect_DESC"
WeatherLiveOrderByInputRcodeAsc WeatherLiveOrderByInput = "rcode_ASC"
WeatherLiveOrderByInputRcodeDesc WeatherLiveOrderByInput = "rcode_DESC"
WeatherLiveOrderByInputRainAsc WeatherLiveOrderByInput = "rain_ASC"
WeatherLiveOrderByInputRainDesc WeatherLiveOrderByInput = "rain_DESC"
WeatherLiveOrderByInputTemperatureAsc WeatherLiveOrderByInput = "temperature_ASC"
WeatherLiveOrderByInputTemperatureDesc WeatherLiveOrderByInput = "temperature_DESC"
          )

        type WeatherAirHistoryOrderByInput string
        const (
          WeatherAirHistoryOrderByInputIDAsc WeatherAirHistoryOrderByInput = "id_ASC"
WeatherAirHistoryOrderByInputIDDesc WeatherAirHistoryOrderByInput = "id_DESC"
WeatherAirHistoryOrderByInputWindSpeedAsc WeatherAirHistoryOrderByInput = "WindSpeed_ASC"
WeatherAirHistoryOrderByInputWindSpeedDesc WeatherAirHistoryOrderByInput = "WindSpeed_DESC"
WeatherAirHistoryOrderByInputCityNameAsc WeatherAirHistoryOrderByInput = "CityName_ASC"
WeatherAirHistoryOrderByInputCityNameDesc WeatherAirHistoryOrderByInput = "CityName_DESC"
WeatherAirHistoryOrderByInputAirpressureAsc WeatherAirHistoryOrderByInput = "Airpressure_ASC"
WeatherAirHistoryOrderByInputAirpressureDesc WeatherAirHistoryOrderByInput = "Airpressure_DESC"
WeatherAirHistoryOrderByInputPhenomenaAsc WeatherAirHistoryOrderByInput = "Phenomena_ASC"
WeatherAirHistoryOrderByInputPhenomenaDesc WeatherAirHistoryOrderByInput = "Phenomena_DESC"
WeatherAirHistoryOrderByInputRdescAsc WeatherAirHistoryOrderByInput = "Rdesc_ASC"
WeatherAirHistoryOrderByInputRdescDesc WeatherAirHistoryOrderByInput = "Rdesc_DESC"
WeatherAirHistoryOrderByInputHumidityAsc WeatherAirHistoryOrderByInput = "Humidity_ASC"
WeatherAirHistoryOrderByInputHumidityDesc WeatherAirHistoryOrderByInput = "Humidity_DESC"
WeatherAirHistoryOrderByInputUpdatetimeAsc WeatherAirHistoryOrderByInput = "Updatetime_ASC"
WeatherAirHistoryOrderByInputUpdatetimeDesc WeatherAirHistoryOrderByInput = "Updatetime_DESC"
WeatherAirHistoryOrderByInputWindpowerAsc WeatherAirHistoryOrderByInput = "Windpower_ASC"
WeatherAirHistoryOrderByInputWindpowerDesc WeatherAirHistoryOrderByInput = "Windpower_DESC"
WeatherAirHistoryOrderByInputFeelstAsc WeatherAirHistoryOrderByInput = "Feelst_ASC"
WeatherAirHistoryOrderByInputFeelstDesc WeatherAirHistoryOrderByInput = "Feelst_DESC"
WeatherAirHistoryOrderByInputWinddirectAsc WeatherAirHistoryOrderByInput = "Winddirect_ASC"
WeatherAirHistoryOrderByInputWinddirectDesc WeatherAirHistoryOrderByInput = "Winddirect_DESC"
WeatherAirHistoryOrderByInputRcodeAsc WeatherAirHistoryOrderByInput = "Rcode_ASC"
WeatherAirHistoryOrderByInputRcodeDesc WeatherAirHistoryOrderByInput = "Rcode_DESC"
WeatherAirHistoryOrderByInputRainAsc WeatherAirHistoryOrderByInput = "Rain_ASC"
WeatherAirHistoryOrderByInputRainDesc WeatherAirHistoryOrderByInput = "Rain_DESC"
WeatherAirHistoryOrderByInputTemperatureAsc WeatherAirHistoryOrderByInput = "Temperature_ASC"
WeatherAirHistoryOrderByInputTemperatureDesc WeatherAirHistoryOrderByInput = "Temperature_DESC"
WeatherAirHistoryOrderByInputCitycodeAsc WeatherAirHistoryOrderByInput = "Citycode_ASC"
WeatherAirHistoryOrderByInputCitycodeDesc WeatherAirHistoryOrderByInput = "Citycode_DESC"
WeatherAirHistoryOrderByInputPm25Asc WeatherAirHistoryOrderByInput = "PM25_ASC"
WeatherAirHistoryOrderByInputPm25Desc WeatherAirHistoryOrderByInput = "PM25_DESC"
WeatherAirHistoryOrderByInputPm10Asc WeatherAirHistoryOrderByInput = "PM10_ASC"
WeatherAirHistoryOrderByInputPm10Desc WeatherAirHistoryOrderByInput = "PM10_DESC"
WeatherAirHistoryOrderByInputSo2Asc WeatherAirHistoryOrderByInput = "SO2_ASC"
WeatherAirHistoryOrderByInputSo2Desc WeatherAirHistoryOrderByInput = "SO2_DESC"
WeatherAirHistoryOrderByInputO3Asc WeatherAirHistoryOrderByInput = "O3_ASC"
WeatherAirHistoryOrderByInputO3Desc WeatherAirHistoryOrderByInput = "O3_DESC"
WeatherAirHistoryOrderByInputNo2Asc WeatherAirHistoryOrderByInput = "NO2_ASC"
WeatherAirHistoryOrderByInputNo2Desc WeatherAirHistoryOrderByInput = "NO2_DESC"
WeatherAirHistoryOrderByInputPrimaryAsc WeatherAirHistoryOrderByInput = "Primary_ASC"
WeatherAirHistoryOrderByInputPrimaryDesc WeatherAirHistoryOrderByInput = "Primary_DESC"
WeatherAirHistoryOrderByInputCoAsc WeatherAirHistoryOrderByInput = "CO_ASC"
WeatherAirHistoryOrderByInputCoDesc WeatherAirHistoryOrderByInput = "CO_DESC"
WeatherAirHistoryOrderByInputAqiAsc WeatherAirHistoryOrderByInput = "AQI_ASC"
WeatherAirHistoryOrderByInputAqiDesc WeatherAirHistoryOrderByInput = "AQI_DESC"
          )

        type RealTimeDataOrderByInput string
        const (
          RealTimeDataOrderByInputIDAsc RealTimeDataOrderByInput = "id_ASC"
RealTimeDataOrderByInputIDDesc RealTimeDataOrderByInput = "id_DESC"
RealTimeDataOrderByInputRcvTimeAsc RealTimeDataOrderByInput = "rcvTime_ASC"
RealTimeDataOrderByInputRcvTimeDesc RealTimeDataOrderByInput = "rcvTime_DESC"
RealTimeDataOrderByInputWindSpeedAsc RealTimeDataOrderByInput = "windSpeed_ASC"
RealTimeDataOrderByInputWindSpeedDesc RealTimeDataOrderByInput = "windSpeed_DESC"
RealTimeDataOrderByInputWindDirectionAsc RealTimeDataOrderByInput = "windDirection_ASC"
RealTimeDataOrderByInputWindDirectionDesc RealTimeDataOrderByInput = "windDirection_DESC"
RealTimeDataOrderByInputTemperatureAsc RealTimeDataOrderByInput = "temperature_ASC"
RealTimeDataOrderByInputTemperatureDesc RealTimeDataOrderByInput = "temperature_DESC"
RealTimeDataOrderByInputHumidityAsc RealTimeDataOrderByInput = "humidity_ASC"
RealTimeDataOrderByInputHumidityDesc RealTimeDataOrderByInput = "humidity_DESC"
RealTimeDataOrderByInputNoiseAsc RealTimeDataOrderByInput = "noise_ASC"
RealTimeDataOrderByInputNoiseDesc RealTimeDataOrderByInput = "noise_DESC"
RealTimeDataOrderByInputPm2Asc RealTimeDataOrderByInput = "pm2_ASC"
RealTimeDataOrderByInputPm2Desc RealTimeDataOrderByInput = "pm2_DESC"
RealTimeDataOrderByInputPm10Asc RealTimeDataOrderByInput = "pm10_ASC"
RealTimeDataOrderByInputPm10Desc RealTimeDataOrderByInput = "pm10_DESC"
RealTimeDataOrderByInputCoAsc RealTimeDataOrderByInput = "co_ASC"
RealTimeDataOrderByInputCoDesc RealTimeDataOrderByInput = "co_DESC"
RealTimeDataOrderByInputCo2Asc RealTimeDataOrderByInput = "co2_ASC"
RealTimeDataOrderByInputCo2Desc RealTimeDataOrderByInput = "co2_DESC"
RealTimeDataOrderByInputAirPressureAsc RealTimeDataOrderByInput = "airPressure_ASC"
RealTimeDataOrderByInputAirPressureDesc RealTimeDataOrderByInput = "airPressure_DESC"
RealTimeDataOrderByInputSunLightAsc RealTimeDataOrderByInput = "sunLight_ASC"
RealTimeDataOrderByInputSunLightDesc RealTimeDataOrderByInput = "sunLight_DESC"
RealTimeDataOrderByInputUpdatedAtAsc RealTimeDataOrderByInput = "updatedAt_ASC"
RealTimeDataOrderByInputUpdatedAtDesc RealTimeDataOrderByInput = "updatedAt_DESC"
          )

        type WiFiProberinfoOrderByInput string
        const (
          WiFiProberinfoOrderByInputIDAsc WiFiProberinfoOrderByInput = "id_ASC"
WiFiProberinfoOrderByInputIDDesc WiFiProberinfoOrderByInput = "id_DESC"
WiFiProberinfoOrderByInputDevNoAsc WiFiProberinfoOrderByInput = "devNo_ASC"
WiFiProberinfoOrderByInputDevNoDesc WiFiProberinfoOrderByInput = "devNo_DESC"
WiFiProberinfoOrderByInputDevMacAsc WiFiProberinfoOrderByInput = "devMac_ASC"
WiFiProberinfoOrderByInputDevMacDesc WiFiProberinfoOrderByInput = "devMac_DESC"
WiFiProberinfoOrderByInputDevMdoelAsc WiFiProberinfoOrderByInput = "devMdoel_ASC"
WiFiProberinfoOrderByInputDevMdoelDesc WiFiProberinfoOrderByInput = "devMdoel_DESC"
          )

        type MacProbeRecordOrderByInput string
        const (
          MacProbeRecordOrderByInputIDAsc MacProbeRecordOrderByInput = "id_ASC"
MacProbeRecordOrderByInputIDDesc MacProbeRecordOrderByInput = "id_DESC"
MacProbeRecordOrderByInputMacAsc MacProbeRecordOrderByInput = "mac_ASC"
MacProbeRecordOrderByInputMacDesc MacProbeRecordOrderByInput = "mac_DESC"
MacProbeRecordOrderByInputDevNoAsc MacProbeRecordOrderByInput = "devNo_ASC"
MacProbeRecordOrderByInputDevNoDesc MacProbeRecordOrderByInput = "devNo_DESC"
MacProbeRecordOrderByInputEntryTimeAsc MacProbeRecordOrderByInput = "entryTime_ASC"
MacProbeRecordOrderByInputEntryTimeDesc MacProbeRecordOrderByInput = "entryTime_DESC"
MacProbeRecordOrderByInputDepartureTimeAsc MacProbeRecordOrderByInput = "departureTime_ASC"
MacProbeRecordOrderByInputDepartureTimeDesc MacProbeRecordOrderByInput = "departureTime_DESC"
          )

        type AttendanceRecordOrderByInput string
        const (
          AttendanceRecordOrderByInputIDAsc AttendanceRecordOrderByInput = "id_ASC"
AttendanceRecordOrderByInputIDDesc AttendanceRecordOrderByInput = "id_DESC"
AttendanceRecordOrderByInputAttDateAsc AttendanceRecordOrderByInput = "attDate_ASC"
AttendanceRecordOrderByInputAttDateDesc AttendanceRecordOrderByInput = "attDate_DESC"
AttendanceRecordOrderByInputTotalSecondAsc AttendanceRecordOrderByInput = "totalSecond_ASC"
AttendanceRecordOrderByInputTotalSecondDesc AttendanceRecordOrderByInput = "totalSecond_DESC"
          )

        type DataUnitOrderByInput string
        const (
          DataUnitOrderByInputIDAsc DataUnitOrderByInput = "id_ASC"
DataUnitOrderByInputIDDesc DataUnitOrderByInput = "id_DESC"
DataUnitOrderByInputDataItemAsc DataUnitOrderByInput = "dataItem_ASC"
DataUnitOrderByInputDataItemDesc DataUnitOrderByInput = "dataItem_DESC"
DataUnitOrderByInputUnitAsc DataUnitOrderByInput = "unit_ASC"
DataUnitOrderByInputUnitDesc DataUnitOrderByInput = "unit_DESC"
          )

        type MacProbeDataOrderByInput string
        const (
          MacProbeDataOrderByInputIDAsc MacProbeDataOrderByInput = "id_ASC"
MacProbeDataOrderByInputIDDesc MacProbeDataOrderByInput = "id_DESC"
MacProbeDataOrderByInputProbeTimeAsc MacProbeDataOrderByInput = "probeTime_ASC"
MacProbeDataOrderByInputProbeTimeDesc MacProbeDataOrderByInput = "probeTime_DESC"
MacProbeDataOrderByInputIsConnetAsc MacProbeDataOrderByInput = "isConnet_ASC"
MacProbeDataOrderByInputIsConnetDesc MacProbeDataOrderByInput = "isConnet_DESC"
MacProbeDataOrderByInputRouterMacAsc MacProbeDataOrderByInput = "routerMAC_ASC"
MacProbeDataOrderByInputRouterMacDesc MacProbeDataOrderByInput = "routerMAC_DESC"
MacProbeDataOrderByInputRouterSsidAsc MacProbeDataOrderByInput = "routerSSID_ASC"
MacProbeDataOrderByInputRouterSsidDesc MacProbeDataOrderByInput = "routerSSID_DESC"
MacProbeDataOrderByInputDestanceAsc MacProbeDataOrderByInput = "destance_ASC"
MacProbeDataOrderByInputDestanceDesc MacProbeDataOrderByInput = "destance_DESC"
          )

        type AirLiveOrderByInput string
        const (
          AirLiveOrderByInputIDAsc AirLiveOrderByInput = "id_ASC"
AirLiveOrderByInputIDDesc AirLiveOrderByInput = "id_DESC"
AirLiveOrderByInputCitycodeAsc AirLiveOrderByInput = "citycode_ASC"
AirLiveOrderByInputCitycodeDesc AirLiveOrderByInput = "citycode_DESC"
AirLiveOrderByInputPm25Asc AirLiveOrderByInput = "PM25_ASC"
AirLiveOrderByInputPm25Desc AirLiveOrderByInput = "PM25_DESC"
AirLiveOrderByInputTimeAsc AirLiveOrderByInput = "time_ASC"
AirLiveOrderByInputTimeDesc AirLiveOrderByInput = "time_DESC"
AirLiveOrderByInputRdescAsc AirLiveOrderByInput = "rdesc_ASC"
AirLiveOrderByInputRdescDesc AirLiveOrderByInput = "rdesc_DESC"
AirLiveOrderByInputPm10Asc AirLiveOrderByInput = "PM10_ASC"
AirLiveOrderByInputPm10Desc AirLiveOrderByInput = "PM10_DESC"
AirLiveOrderByInputSo2Asc AirLiveOrderByInput = "SO2_ASC"
AirLiveOrderByInputSo2Desc AirLiveOrderByInput = "SO2_DESC"
AirLiveOrderByInputO3Asc AirLiveOrderByInput = "o3_ASC"
AirLiveOrderByInputO3Desc AirLiveOrderByInput = "o3_DESC"
AirLiveOrderByInputNo2Asc AirLiveOrderByInput = "NO2_ASC"
AirLiveOrderByInputNo2Desc AirLiveOrderByInput = "NO2_DESC"
AirLiveOrderByInputPrimaryAsc AirLiveOrderByInput = "primary_ASC"
AirLiveOrderByInputPrimaryDesc AirLiveOrderByInput = "primary_DESC"
AirLiveOrderByInputRcodeAsc AirLiveOrderByInput = "rcode_ASC"
AirLiveOrderByInputRcodeDesc AirLiveOrderByInput = "rcode_DESC"
AirLiveOrderByInputCoAsc AirLiveOrderByInput = "CO_ASC"
AirLiveOrderByInputCoDesc AirLiveOrderByInput = "CO_DESC"
AirLiveOrderByInputAqiAsc AirLiveOrderByInput = "AQI_ASC"
AirLiveOrderByInputAqiDesc AirLiveOrderByInput = "AQI_DESC"
          )

        type IDVerifyDeviceInfoOrderByInput string
        const (
          IDVerifyDeviceInfoOrderByInputIDAsc IDVerifyDeviceInfoOrderByInput = "id_ASC"
IDVerifyDeviceInfoOrderByInputIDDesc IDVerifyDeviceInfoOrderByInput = "id_DESC"
IDVerifyDeviceInfoOrderByInputDevNoAsc IDVerifyDeviceInfoOrderByInput = "devNo_ASC"
IDVerifyDeviceInfoOrderByInputDevNoDesc IDVerifyDeviceInfoOrderByInput = "devNo_DESC"
IDVerifyDeviceInfoOrderByInputDevNameAsc IDVerifyDeviceInfoOrderByInput = "devName_ASC"
IDVerifyDeviceInfoOrderByInputDevNameDesc IDVerifyDeviceInfoOrderByInput = "devName_DESC"
IDVerifyDeviceInfoOrderByInputDevAddrAsc IDVerifyDeviceInfoOrderByInput = "devAddr_ASC"
IDVerifyDeviceInfoOrderByInputDevAddrDesc IDVerifyDeviceInfoOrderByInput = "devAddr_DESC"
          )

        type MonitorNodeOrderByInput string
        const (
          MonitorNodeOrderByInputIDAsc MonitorNodeOrderByInput = "id_ASC"
MonitorNodeOrderByInputIDDesc MonitorNodeOrderByInput = "id_DESC"
MonitorNodeOrderByInputMonitorSnAsc MonitorNodeOrderByInput = "monitorSN_ASC"
MonitorNodeOrderByInputMonitorSnDesc MonitorNodeOrderByInput = "monitorSN_DESC"
MonitorNodeOrderByInputMonitorNameAsc MonitorNodeOrderByInput = "monitorName_ASC"
MonitorNodeOrderByInputMonitorNameDesc MonitorNodeOrderByInput = "monitorName_DESC"
MonitorNodeOrderByInputMonitorTypeAsc MonitorNodeOrderByInput = "monitorType_ASC"
MonitorNodeOrderByInputMonitorTypeDesc MonitorNodeOrderByInput = "monitorType_DESC"
MonitorNodeOrderByInputMonitorStatusAsc MonitorNodeOrderByInput = "monitorStatus_ASC"
MonitorNodeOrderByInputMonitorStatusDesc MonitorNodeOrderByInput = "monitorStatus_DESC"
MonitorNodeOrderByInputCreatedAtAsc MonitorNodeOrderByInput = "createdAt_ASC"
MonitorNodeOrderByInputCreatedAtDesc MonitorNodeOrderByInput = "createdAt_DESC"
MonitorNodeOrderByInputUpdatedAtAsc MonitorNodeOrderByInput = "updatedAt_ASC"
MonitorNodeOrderByInputUpdatedAtDesc MonitorNodeOrderByInput = "updatedAt_DESC"
          )

        type IDCardVerifyDataOrderByInput string
        const (
          IDCardVerifyDataOrderByInputIDAsc IDCardVerifyDataOrderByInput = "id_ASC"
IDCardVerifyDataOrderByInputIDDesc IDCardVerifyDataOrderByInput = "id_DESC"
IDCardVerifyDataOrderByInputCreatedAtAsc IDCardVerifyDataOrderByInput = "createdAt_ASC"
IDCardVerifyDataOrderByInputCreatedAtDesc IDCardVerifyDataOrderByInput = "createdAt_DESC"
IDCardVerifyDataOrderByInputDevNoAsc IDCardVerifyDataOrderByInput = "devNo_ASC"
IDCardVerifyDataOrderByInputDevNoDesc IDCardVerifyDataOrderByInput = "devNo_DESC"
IDCardVerifyDataOrderByInputDevNameAsc IDCardVerifyDataOrderByInput = "devName_ASC"
IDCardVerifyDataOrderByInputDevNameDesc IDCardVerifyDataOrderByInput = "devName_DESC"
IDCardVerifyDataOrderByInputDevAddrAsc IDCardVerifyDataOrderByInput = "devAddr_ASC"
IDCardVerifyDataOrderByInputDevAddrDesc IDCardVerifyDataOrderByInput = "devAddr_DESC"
IDCardVerifyDataOrderByInputIDCardAsc IDCardVerifyDataOrderByInput = "idCard_ASC"
IDCardVerifyDataOrderByInputIDCardDesc IDCardVerifyDataOrderByInput = "idCard_DESC"
IDCardVerifyDataOrderByInputPersonTypeAsc IDCardVerifyDataOrderByInput = "personType_ASC"
IDCardVerifyDataOrderByInputPersonTypeDesc IDCardVerifyDataOrderByInput = "personType_DESC"
IDCardVerifyDataOrderByInputScoreAsc IDCardVerifyDataOrderByInput = "score_ASC"
IDCardVerifyDataOrderByInputScoreDesc IDCardVerifyDataOrderByInput = "score_DESC"
IDCardVerifyDataOrderByInputStatusAsc IDCardVerifyDataOrderByInput = "status_ASC"
IDCardVerifyDataOrderByInputStatusDesc IDCardVerifyDataOrderByInput = "status_DESC"
IDCardVerifyDataOrderByInputFaceImgUriAsc IDCardVerifyDataOrderByInput = "faceImgUri_ASC"
IDCardVerifyDataOrderByInputFaceImgUriDesc IDCardVerifyDataOrderByInput = "faceImgUri_DESC"
          )

        type MaCinfoOrderByInput string
        const (
          MaCinfoOrderByInputIDAsc MaCinfoOrderByInput = "id_ASC"
MaCinfoOrderByInputIDDesc MaCinfoOrderByInput = "id_DESC"
MaCinfoOrderByInputMacAsc MaCinfoOrderByInput = "mac_ASC"
MaCinfoOrderByInputMacDesc MaCinfoOrderByInput = "mac_DESC"
MaCinfoOrderByInputDevTypeAsc MaCinfoOrderByInput = "devType_ASC"
MaCinfoOrderByInputDevTypeDesc MaCinfoOrderByInput = "devType_DESC"
MaCinfoOrderByInputProbeCountAsc MaCinfoOrderByInput = "probeCount_ASC"
MaCinfoOrderByInputProbeCountDesc MaCinfoOrderByInput = "probeCount_DESC"
MaCinfoOrderByInputLastProbeTimeAsc MaCinfoOrderByInput = "lastProbeTime_ASC"
MaCinfoOrderByInputLastProbeTimeDesc MaCinfoOrderByInput = "lastProbeTime_DESC"
MaCinfoOrderByInputIfOnlineAsc MaCinfoOrderByInput = "ifOnline_ASC"
MaCinfoOrderByInputIfOnlineDesc MaCinfoOrderByInput = "ifOnline_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

        type CityCodeInfoOrderByInput string
        const (
          CityCodeInfoOrderByInputIDAsc CityCodeInfoOrderByInput = "id_ASC"
CityCodeInfoOrderByInputIDDesc CityCodeInfoOrderByInput = "id_DESC"
CityCodeInfoOrderByInputAirCitycodeAsc CityCodeInfoOrderByInput = "airCitycode_ASC"
CityCodeInfoOrderByInputAirCitycodeDesc CityCodeInfoOrderByInput = "airCitycode_DESC"
CityCodeInfoOrderByInputWeatherCityCodeAsc CityCodeInfoOrderByInput = "weatherCityCode_ASC"
CityCodeInfoOrderByInputWeatherCityCodeDesc CityCodeInfoOrderByInput = "weatherCityCode_DESC"
CityCodeInfoOrderByInputCityNameAsc CityCodeInfoOrderByInput = "cityName_ASC"
CityCodeInfoOrderByInputCityNameDesc CityCodeInfoOrderByInput = "cityName_DESC"
          )

        type LocationInfoOrderByInput string
        const (
          LocationInfoOrderByInputIDAsc LocationInfoOrderByInput = "id_ASC"
LocationInfoOrderByInputIDDesc LocationInfoOrderByInput = "id_DESC"
LocationInfoOrderByInputDescribeAsc LocationInfoOrderByInput = "describe_ASC"
LocationInfoOrderByInputDescribeDesc LocationInfoOrderByInput = "describe_DESC"
LocationInfoOrderByInputLongitudeAsc LocationInfoOrderByInput = "longitude_ASC"
LocationInfoOrderByInputLongitudeDesc LocationInfoOrderByInput = "longitude_DESC"
LocationInfoOrderByInputLatitudeAsc LocationInfoOrderByInput = "latitude_ASC"
LocationInfoOrderByInputLatitudeDesc LocationInfoOrderByInput = "latitude_DESC"
LocationInfoOrderByInputProvinceAsc LocationInfoOrderByInput = "province_ASC"
LocationInfoOrderByInputProvinceDesc LocationInfoOrderByInput = "province_DESC"
LocationInfoOrderByInputCityAsc LocationInfoOrderByInput = "city_ASC"
LocationInfoOrderByInputCityDesc LocationInfoOrderByInput = "city_DESC"
LocationInfoOrderByInputCountyAsc LocationInfoOrderByInput = "county_ASC"
LocationInfoOrderByInputCountyDesc LocationInfoOrderByInput = "county_DESC"
LocationInfoOrderByInputStreetAsc LocationInfoOrderByInput = "street_ASC"
LocationInfoOrderByInputStreetDesc LocationInfoOrderByInput = "street_DESC"
LocationInfoOrderByInputIndoorLocalAsc LocationInfoOrderByInput = "indoorLocal_ASC"
LocationInfoOrderByInputIndoorLocalDesc LocationInfoOrderByInput = "indoorLocal_DESC"
LocationInfoOrderByInputOutdoorLocalAsc LocationInfoOrderByInput = "outdoorLocal_ASC"
LocationInfoOrderByInputOutdoorLocalDesc LocationInfoOrderByInput = "outdoorLocal_DESC"
          )

        type PersonInfoOrderByInput string
        const (
          PersonInfoOrderByInputIDAsc PersonInfoOrderByInput = "id_ASC"
PersonInfoOrderByInputIDDesc PersonInfoOrderByInput = "id_DESC"
PersonInfoOrderByInputIDCardAsc PersonInfoOrderByInput = "idCard_ASC"
PersonInfoOrderByInputIDCardDesc PersonInfoOrderByInput = "idCard_DESC"
PersonInfoOrderByInputCardTypeAsc PersonInfoOrderByInput = "cardType_ASC"
PersonInfoOrderByInputCardTypeDesc PersonInfoOrderByInput = "cardType_DESC"
PersonInfoOrderByInputValidityAsc PersonInfoOrderByInput = "validity_ASC"
PersonInfoOrderByInputValidityDesc PersonInfoOrderByInput = "validity_DESC"
PersonInfoOrderByInputBirthdayAsc PersonInfoOrderByInput = "birthday_ASC"
PersonInfoOrderByInputBirthdayDesc PersonInfoOrderByInput = "birthday_DESC"
PersonInfoOrderByInputPersonNameAsc PersonInfoOrderByInput = "personName_ASC"
PersonInfoOrderByInputPersonNameDesc PersonInfoOrderByInput = "personName_DESC"
PersonInfoOrderByInputAddressAsc PersonInfoOrderByInput = "address_ASC"
PersonInfoOrderByInputAddressDesc PersonInfoOrderByInput = "address_DESC"
PersonInfoOrderByInputNationAsc PersonInfoOrderByInput = "nation_ASC"
PersonInfoOrderByInputNationDesc PersonInfoOrderByInput = "nation_DESC"
PersonInfoOrderByInputAuthorityAsc PersonInfoOrderByInput = "authority_ASC"
PersonInfoOrderByInputAuthorityDesc PersonInfoOrderByInput = "authority_DESC"
PersonInfoOrderByInputGenderAsc PersonInfoOrderByInput = "gender_ASC"
PersonInfoOrderByInputGenderDesc PersonInfoOrderByInput = "gender_DESC"
PersonInfoOrderByInputClassAsc PersonInfoOrderByInput = "class_ASC"
PersonInfoOrderByInputClassDesc PersonInfoOrderByInput = "class_DESC"
PersonInfoOrderByInputStudentNumberAsc PersonInfoOrderByInput = "studentNumber_ASC"
PersonInfoOrderByInputStudentNumberDesc PersonInfoOrderByInput = "studentNumber_DESC"
PersonInfoOrderByInputPhoneAsc PersonInfoOrderByInput = "phone_ASC"
PersonInfoOrderByInputPhoneDesc PersonInfoOrderByInput = "phone_DESC"
PersonInfoOrderByInputRemarkAsc PersonInfoOrderByInput = "remark_ASC"
PersonInfoOrderByInputRemarkDesc PersonInfoOrderByInput = "remark_DESC"
PersonInfoOrderByInputBaseFaceImgUriAsc PersonInfoOrderByInput = "baseFaceImgUri_ASC"
PersonInfoOrderByInputBaseFaceImgUriDesc PersonInfoOrderByInput = "baseFaceImgUri_DESC"
          )

        type WeatherAirLiveOrderByInput string
        const (
          WeatherAirLiveOrderByInputIDAsc WeatherAirLiveOrderByInput = "id_ASC"
WeatherAirLiveOrderByInputIDDesc WeatherAirLiveOrderByInput = "id_DESC"
WeatherAirLiveOrderByInputWindSpeedAsc WeatherAirLiveOrderByInput = "WindSpeed_ASC"
WeatherAirLiveOrderByInputWindSpeedDesc WeatherAirLiveOrderByInput = "WindSpeed_DESC"
WeatherAirLiveOrderByInputCityNameAsc WeatherAirLiveOrderByInput = "CityName_ASC"
WeatherAirLiveOrderByInputCityNameDesc WeatherAirLiveOrderByInput = "CityName_DESC"
WeatherAirLiveOrderByInputAirpressureAsc WeatherAirLiveOrderByInput = "Airpressure_ASC"
WeatherAirLiveOrderByInputAirpressureDesc WeatherAirLiveOrderByInput = "Airpressure_DESC"
WeatherAirLiveOrderByInputPhenomenaAsc WeatherAirLiveOrderByInput = "Phenomena_ASC"
WeatherAirLiveOrderByInputPhenomenaDesc WeatherAirLiveOrderByInput = "Phenomena_DESC"
WeatherAirLiveOrderByInputRdescAsc WeatherAirLiveOrderByInput = "Rdesc_ASC"
WeatherAirLiveOrderByInputRdescDesc WeatherAirLiveOrderByInput = "Rdesc_DESC"
WeatherAirLiveOrderByInputHumidityAsc WeatherAirLiveOrderByInput = "Humidity_ASC"
WeatherAirLiveOrderByInputHumidityDesc WeatherAirLiveOrderByInput = "Humidity_DESC"
WeatherAirLiveOrderByInputUpdatetimeAsc WeatherAirLiveOrderByInput = "Updatetime_ASC"
WeatherAirLiveOrderByInputUpdatetimeDesc WeatherAirLiveOrderByInput = "Updatetime_DESC"
WeatherAirLiveOrderByInputWindpowerAsc WeatherAirLiveOrderByInput = "Windpower_ASC"
WeatherAirLiveOrderByInputWindpowerDesc WeatherAirLiveOrderByInput = "Windpower_DESC"
WeatherAirLiveOrderByInputFeelstAsc WeatherAirLiveOrderByInput = "Feelst_ASC"
WeatherAirLiveOrderByInputFeelstDesc WeatherAirLiveOrderByInput = "Feelst_DESC"
WeatherAirLiveOrderByInputWinddirectAsc WeatherAirLiveOrderByInput = "Winddirect_ASC"
WeatherAirLiveOrderByInputWinddirectDesc WeatherAirLiveOrderByInput = "Winddirect_DESC"
WeatherAirLiveOrderByInputRcodeAsc WeatherAirLiveOrderByInput = "Rcode_ASC"
WeatherAirLiveOrderByInputRcodeDesc WeatherAirLiveOrderByInput = "Rcode_DESC"
WeatherAirLiveOrderByInputRainAsc WeatherAirLiveOrderByInput = "Rain_ASC"
WeatherAirLiveOrderByInputRainDesc WeatherAirLiveOrderByInput = "Rain_DESC"
WeatherAirLiveOrderByInputTemperatureAsc WeatherAirLiveOrderByInput = "Temperature_ASC"
WeatherAirLiveOrderByInputTemperatureDesc WeatherAirLiveOrderByInput = "Temperature_DESC"
WeatherAirLiveOrderByInputCitycodeAsc WeatherAirLiveOrderByInput = "Citycode_ASC"
WeatherAirLiveOrderByInputCitycodeDesc WeatherAirLiveOrderByInput = "Citycode_DESC"
WeatherAirLiveOrderByInputPm25Asc WeatherAirLiveOrderByInput = "PM25_ASC"
WeatherAirLiveOrderByInputPm25Desc WeatherAirLiveOrderByInput = "PM25_DESC"
WeatherAirLiveOrderByInputPm10Asc WeatherAirLiveOrderByInput = "PM10_ASC"
WeatherAirLiveOrderByInputPm10Desc WeatherAirLiveOrderByInput = "PM10_DESC"
WeatherAirLiveOrderByInputSo2Asc WeatherAirLiveOrderByInput = "SO2_ASC"
WeatherAirLiveOrderByInputSo2Desc WeatherAirLiveOrderByInput = "SO2_DESC"
WeatherAirLiveOrderByInputO3Asc WeatherAirLiveOrderByInput = "O3_ASC"
WeatherAirLiveOrderByInputO3Desc WeatherAirLiveOrderByInput = "O3_DESC"
WeatherAirLiveOrderByInputNo2Asc WeatherAirLiveOrderByInput = "NO2_ASC"
WeatherAirLiveOrderByInputNo2Desc WeatherAirLiveOrderByInput = "NO2_DESC"
WeatherAirLiveOrderByInputPrimaryAsc WeatherAirLiveOrderByInput = "Primary_ASC"
WeatherAirLiveOrderByInputPrimaryDesc WeatherAirLiveOrderByInput = "Primary_DESC"
WeatherAirLiveOrderByInputCoAsc WeatherAirLiveOrderByInput = "CO_ASC"
WeatherAirLiveOrderByInputCoDesc WeatherAirLiveOrderByInput = "CO_DESC"
WeatherAirLiveOrderByInputAqiAsc WeatherAirLiveOrderByInput = "AQI_ASC"
WeatherAirLiveOrderByInputAqiDesc WeatherAirLiveOrderByInput = "AQI_DESC"
          )

      type AttendanceRecordUpdateManyWithoutMacInput struct {
        Create []AttendanceRecordCreateWithoutMacInput `json:"create,omitempty"`
Delete []AttendanceRecordWhereUniqueInput `json:"delete,omitempty"`
Connect []AttendanceRecordWhereUniqueInput `json:"connect,omitempty"`
Set []AttendanceRecordWhereUniqueInput `json:"set,omitempty"`
Disconnect []AttendanceRecordWhereUniqueInput `json:"disconnect,omitempty"`
Update []AttendanceRecordUpdateWithWhereUniqueWithoutMacInput `json:"update,omitempty"`
Upsert []AttendanceRecordUpsertWithWhereUniqueWithoutMacInput `json:"upsert,omitempty"`
DeleteMany []AttendanceRecordScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []AttendanceRecordUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type AirHistoryDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type WeatherAirLiveCreateOneWithoutCityInfoInput struct {
        Create *WeatherAirLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect *WeatherAirLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type MonitorNodeUpsertWithoutHistoryDatasInput struct {
        Update MonitorNodeUpdateWithoutHistoryDatasDataInput `json:"update"`
Create MonitorNodeCreateWithoutHistoryDatasInput `json:"create"`
          }

      type WeatherAirLiveCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type IDCardVerifyDataUpsertWithWhereUniqueWithoutIdVerifyDeviceInput struct {
        Where IDCardVerifyDataWhereUniqueInput `json:"where"`
Update IDCardVerifyDataUpdateWithoutIdVerifyDeviceDataInput `json:"update"`
Create IDCardVerifyDataCreateWithoutIdVerifyDeviceInput `json:"create"`
          }

      type WeatherAirHistoryCreateManyWithoutCityInfoInput struct {
        Create []WeatherAirHistoryCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect []WeatherAirHistoryWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherLiveSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *WeatherLiveWhereInput `json:"node,omitempty"`
And []WeatherLiveSubscriptionWhereInput `json:"AND,omitempty"`
Or []WeatherLiveSubscriptionWhereInput `json:"OR,omitempty"`
Not []WeatherLiveSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type WeatherAirHistoryCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type WeatherHistoryDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *WeatherHistoryDataWhereInput `json:"node,omitempty"`
And []WeatherHistoryDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []WeatherHistoryDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []WeatherHistoryDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type WeatherHistoryDataCreateManyWithoutCityInfoInput struct {
        Create []WeatherHistoryDataCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect []WeatherHistoryDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type RealTimeDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
MonitorNode *MonitorNodeWhereInput `json:"monitorNode,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
RcvTimeNot *string `json:"rcvTime_not,omitempty"`
RcvTimeIn []string `json:"rcvTime_in,omitempty"`
RcvTimeNotIn []string `json:"rcvTime_not_in,omitempty"`
RcvTimeLt *string `json:"rcvTime_lt,omitempty"`
RcvTimeLte *string `json:"rcvTime_lte,omitempty"`
RcvTimeGt *string `json:"rcvTime_gt,omitempty"`
RcvTimeGte *string `json:"rcvTime_gte,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindSpeedNot *float64 `json:"windSpeed_not,omitempty"`
WindSpeedIn []float64 `json:"windSpeed_in,omitempty"`
WindSpeedNotIn []float64 `json:"windSpeed_not_in,omitempty"`
WindSpeedLt *float64 `json:"windSpeed_lt,omitempty"`
WindSpeedLte *float64 `json:"windSpeed_lte,omitempty"`
WindSpeedGt *float64 `json:"windSpeed_gt,omitempty"`
WindSpeedGte *float64 `json:"windSpeed_gte,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
WindDirectionNot *string `json:"windDirection_not,omitempty"`
WindDirectionIn []string `json:"windDirection_in,omitempty"`
WindDirectionNotIn []string `json:"windDirection_not_in,omitempty"`
WindDirectionLt *string `json:"windDirection_lt,omitempty"`
WindDirectionLte *string `json:"windDirection_lte,omitempty"`
WindDirectionGt *string `json:"windDirection_gt,omitempty"`
WindDirectionGte *string `json:"windDirection_gte,omitempty"`
WindDirectionContains *string `json:"windDirection_contains,omitempty"`
WindDirectionNotContains *string `json:"windDirection_not_contains,omitempty"`
WindDirectionStartsWith *string `json:"windDirection_starts_with,omitempty"`
WindDirectionNotStartsWith *string `json:"windDirection_not_starts_with,omitempty"`
WindDirectionEndsWith *string `json:"windDirection_ends_with,omitempty"`
WindDirectionNotEndsWith *string `json:"windDirection_not_ends_with,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
TemperatureNot *float64 `json:"temperature_not,omitempty"`
TemperatureIn []float64 `json:"temperature_in,omitempty"`
TemperatureNotIn []float64 `json:"temperature_not_in,omitempty"`
TemperatureLt *float64 `json:"temperature_lt,omitempty"`
TemperatureLte *float64 `json:"temperature_lte,omitempty"`
TemperatureGt *float64 `json:"temperature_gt,omitempty"`
TemperatureGte *float64 `json:"temperature_gte,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
HumidityNot *float64 `json:"humidity_not,omitempty"`
HumidityIn []float64 `json:"humidity_in,omitempty"`
HumidityNotIn []float64 `json:"humidity_not_in,omitempty"`
HumidityLt *float64 `json:"humidity_lt,omitempty"`
HumidityLte *float64 `json:"humidity_lte,omitempty"`
HumidityGt *float64 `json:"humidity_gt,omitempty"`
HumidityGte *float64 `json:"humidity_gte,omitempty"`
Noise *float64 `json:"noise,omitempty"`
NoiseNot *float64 `json:"noise_not,omitempty"`
NoiseIn []float64 `json:"noise_in,omitempty"`
NoiseNotIn []float64 `json:"noise_not_in,omitempty"`
NoiseLt *float64 `json:"noise_lt,omitempty"`
NoiseLte *float64 `json:"noise_lte,omitempty"`
NoiseGt *float64 `json:"noise_gt,omitempty"`
NoiseGte *float64 `json:"noise_gte,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm2Not *float64 `json:"pm2_not,omitempty"`
Pm2In []float64 `json:"pm2_in,omitempty"`
Pm2NotIn []float64 `json:"pm2_not_in,omitempty"`
Pm2Lt *float64 `json:"pm2_lt,omitempty"`
Pm2Lte *float64 `json:"pm2_lte,omitempty"`
Pm2Gt *float64 `json:"pm2_gt,omitempty"`
Pm2Gte *float64 `json:"pm2_gte,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Pm10Not *float64 `json:"pm10_not,omitempty"`
Pm10In []float64 `json:"pm10_in,omitempty"`
Pm10NotIn []float64 `json:"pm10_not_in,omitempty"`
Pm10Lt *float64 `json:"pm10_lt,omitempty"`
Pm10Lte *float64 `json:"pm10_lte,omitempty"`
Pm10Gt *float64 `json:"pm10_gt,omitempty"`
Pm10Gte *float64 `json:"pm10_gte,omitempty"`
Co *float64 `json:"co,omitempty"`
CoNot *float64 `json:"co_not,omitempty"`
CoIn []float64 `json:"co_in,omitempty"`
CoNotIn []float64 `json:"co_not_in,omitempty"`
CoLt *float64 `json:"co_lt,omitempty"`
CoLte *float64 `json:"co_lte,omitempty"`
CoGt *float64 `json:"co_gt,omitempty"`
CoGte *float64 `json:"co_gte,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
Co2Not *float64 `json:"co2_not,omitempty"`
Co2In []float64 `json:"co2_in,omitempty"`
Co2NotIn []float64 `json:"co2_not_in,omitempty"`
Co2Lt *float64 `json:"co2_lt,omitempty"`
Co2Lte *float64 `json:"co2_lte,omitempty"`
Co2Gt *float64 `json:"co2_gt,omitempty"`
Co2Gte *float64 `json:"co2_gte,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
AirPressureNot *float64 `json:"airPressure_not,omitempty"`
AirPressureIn []float64 `json:"airPressure_in,omitempty"`
AirPressureNotIn []float64 `json:"airPressure_not_in,omitempty"`
AirPressureLt *float64 `json:"airPressure_lt,omitempty"`
AirPressureLte *float64 `json:"airPressure_lte,omitempty"`
AirPressureGt *float64 `json:"airPressure_gt,omitempty"`
AirPressureGte *float64 `json:"airPressure_gte,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
SunLightNot *float64 `json:"sunLight_not,omitempty"`
SunLightIn []float64 `json:"sunLight_in,omitempty"`
SunLightNotIn []float64 `json:"sunLight_not_in,omitempty"`
SunLightLt *float64 `json:"sunLight_lt,omitempty"`
SunLightLte *float64 `json:"sunLight_lte,omitempty"`
SunLightGt *float64 `json:"sunLight_gt,omitempty"`
SunLightGte *float64 `json:"sunLight_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []RealTimeDataWhereInput `json:"AND,omitempty"`
Or []RealTimeDataWhereInput `json:"OR,omitempty"`
Not []RealTimeDataWhereInput `json:"NOT,omitempty"`
          }

      type WeatherHistoryDataCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type AttendanceRecordWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
AttDate *string `json:"attDate,omitempty"`
AttDateNot *string `json:"attDate_not,omitempty"`
AttDateIn []string `json:"attDate_in,omitempty"`
AttDateNotIn []string `json:"attDate_not_in,omitempty"`
AttDateLt *string `json:"attDate_lt,omitempty"`
AttDateLte *string `json:"attDate_lte,omitempty"`
AttDateGt *string `json:"attDate_gt,omitempty"`
AttDateGte *string `json:"attDate_gte,omitempty"`
Mac *MaCinfoWhereInput `json:"mac,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
TotalSecondNot *string `json:"totalSecond_not,omitempty"`
TotalSecondIn []string `json:"totalSecond_in,omitempty"`
TotalSecondNotIn []string `json:"totalSecond_not_in,omitempty"`
TotalSecondLt *string `json:"totalSecond_lt,omitempty"`
TotalSecondLte *string `json:"totalSecond_lte,omitempty"`
TotalSecondGt *string `json:"totalSecond_gt,omitempty"`
TotalSecondGte *string `json:"totalSecond_gte,omitempty"`
TotalSecondContains *string `json:"totalSecond_contains,omitempty"`
TotalSecondNotContains *string `json:"totalSecond_not_contains,omitempty"`
TotalSecondStartsWith *string `json:"totalSecond_starts_with,omitempty"`
TotalSecondNotStartsWith *string `json:"totalSecond_not_starts_with,omitempty"`
TotalSecondEndsWith *string `json:"totalSecond_ends_with,omitempty"`
TotalSecondNotEndsWith *string `json:"totalSecond_not_ends_with,omitempty"`
And []AttendanceRecordWhereInput `json:"AND,omitempty"`
Or []AttendanceRecordWhereInput `json:"OR,omitempty"`
Not []AttendanceRecordWhereInput `json:"NOT,omitempty"`
          }

      type AirHistoryDataUpdateInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutAirHistoryDatasInput `json:"cityInfo,omitempty"`
          }

      type PersonInfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *PersonInfoWhereInput `json:"node,omitempty"`
And []PersonInfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []PersonInfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []PersonInfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutAirHistoryDatasInput struct {
        Create *CityCodeInfoCreateWithoutAirHistoryDatasInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutAirHistoryDatasDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutAirHistoryDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MonitorNodeSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *MonitorNodeWhereInput `json:"node,omitempty"`
And []MonitorNodeSubscriptionWhereInput `json:"AND,omitempty"`
Or []MonitorNodeSubscriptionWhereInput `json:"OR,omitempty"`
Not []MonitorNodeSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type CityCodeInfoUpdateWithoutAirHistoryDatasDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type MaCinfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *MaCinfoWhereInput `json:"node,omitempty"`
And []MaCinfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []MaCinfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []MaCinfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpdateOneInput struct {
        Create *LocationInfoCreateInput `json:"create,omitempty"`
Update *LocationInfoUpdateDataInput `json:"update,omitempty"`
Upsert *LocationInfoUpsertNestedInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MacProbeDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *MacProbeDataWhereInput `json:"node,omitempty"`
And []MacProbeDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []MacProbeDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []MacProbeDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpdateDataInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeUpdateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoUpdateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
WifiProbers *WiFiProberinfoUpdateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type CityCodeInfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
AirCitycode *string `json:"airCitycode,omitempty"`
AirCitycodeNot *string `json:"airCitycode_not,omitempty"`
AirCitycodeIn []string `json:"airCitycode_in,omitempty"`
AirCitycodeNotIn []string `json:"airCitycode_not_in,omitempty"`
AirCitycodeLt *string `json:"airCitycode_lt,omitempty"`
AirCitycodeLte *string `json:"airCitycode_lte,omitempty"`
AirCitycodeGt *string `json:"airCitycode_gt,omitempty"`
AirCitycodeGte *string `json:"airCitycode_gte,omitempty"`
AirCitycodeContains *string `json:"airCitycode_contains,omitempty"`
AirCitycodeNotContains *string `json:"airCitycode_not_contains,omitempty"`
AirCitycodeStartsWith *string `json:"airCitycode_starts_with,omitempty"`
AirCitycodeNotStartsWith *string `json:"airCitycode_not_starts_with,omitempty"`
AirCitycodeEndsWith *string `json:"airCitycode_ends_with,omitempty"`
AirCitycodeNotEndsWith *string `json:"airCitycode_not_ends_with,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
WeatherCityCodeNot *string `json:"weatherCityCode_not,omitempty"`
WeatherCityCodeIn []string `json:"weatherCityCode_in,omitempty"`
WeatherCityCodeNotIn []string `json:"weatherCityCode_not_in,omitempty"`
WeatherCityCodeLt *string `json:"weatherCityCode_lt,omitempty"`
WeatherCityCodeLte *string `json:"weatherCityCode_lte,omitempty"`
WeatherCityCodeGt *string `json:"weatherCityCode_gt,omitempty"`
WeatherCityCodeGte *string `json:"weatherCityCode_gte,omitempty"`
WeatherCityCodeContains *string `json:"weatherCityCode_contains,omitempty"`
WeatherCityCodeNotContains *string `json:"weatherCityCode_not_contains,omitempty"`
WeatherCityCodeStartsWith *string `json:"weatherCityCode_starts_with,omitempty"`
WeatherCityCodeNotStartsWith *string `json:"weatherCityCode_not_starts_with,omitempty"`
WeatherCityCodeEndsWith *string `json:"weatherCityCode_ends_with,omitempty"`
WeatherCityCodeNotEndsWith *string `json:"weatherCityCode_not_ends_with,omitempty"`
CityName *string `json:"cityName,omitempty"`
CityNameNot *string `json:"cityName_not,omitempty"`
CityNameIn []string `json:"cityName_in,omitempty"`
CityNameNotIn []string `json:"cityName_not_in,omitempty"`
CityNameLt *string `json:"cityName_lt,omitempty"`
CityNameLte *string `json:"cityName_lte,omitempty"`
CityNameGt *string `json:"cityName_gt,omitempty"`
CityNameGte *string `json:"cityName_gte,omitempty"`
CityNameContains *string `json:"cityName_contains,omitempty"`
CityNameNotContains *string `json:"cityName_not_contains,omitempty"`
CityNameStartsWith *string `json:"cityName_starts_with,omitempty"`
CityNameNotStartsWith *string `json:"cityName_not_starts_with,omitempty"`
CityNameEndsWith *string `json:"cityName_ends_with,omitempty"`
CityNameNotEndsWith *string `json:"cityName_not_ends_with,omitempty"`
LocationInfo *LocationInfoWhereInput `json:"locationInfo,omitempty"`
AirLive *AirLiveWhereInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveWhereInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveWhereInput `json:"weatherAirLive,omitempty"`
WeatherAirHistoryEvery *WeatherAirHistoryWhereInput `json:"weatherAirHistory_every,omitempty"`
WeatherAirHistorySome *WeatherAirHistoryWhereInput `json:"weatherAirHistory_some,omitempty"`
WeatherAirHistoryNone *WeatherAirHistoryWhereInput `json:"weatherAirHistory_none,omitempty"`
AirHistoryDatasEvery *AirHistoryDataWhereInput `json:"airHistoryDatas_every,omitempty"`
AirHistoryDatasSome *AirHistoryDataWhereInput `json:"airHistoryDatas_some,omitempty"`
AirHistoryDatasNone *AirHistoryDataWhereInput `json:"airHistoryDatas_none,omitempty"`
WeatherHistoryDatasEvery *WeatherHistoryDataWhereInput `json:"weatherHistoryDatas_every,omitempty"`
WeatherHistoryDatasSome *WeatherHistoryDataWhereInput `json:"weatherHistoryDatas_some,omitempty"`
WeatherHistoryDatasNone *WeatherHistoryDataWhereInput `json:"weatherHistoryDatas_none,omitempty"`
And []CityCodeInfoWhereInput `json:"AND,omitempty"`
Or []CityCodeInfoWhereInput `json:"OR,omitempty"`
Not []CityCodeInfoWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeUpdateManyWithoutLocationInput struct {
        Create []MonitorNodeCreateWithoutLocationInput `json:"create,omitempty"`
Delete []MonitorNodeWhereUniqueInput `json:"delete,omitempty"`
Connect []MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
Set []MonitorNodeWhereUniqueInput `json:"set,omitempty"`
Disconnect []MonitorNodeWhereUniqueInput `json:"disconnect,omitempty"`
Update []MonitorNodeUpdateWithWhereUniqueWithoutLocationInput `json:"update,omitempty"`
Upsert []MonitorNodeUpsertWithWhereUniqueWithoutLocationInput `json:"upsert,omitempty"`
DeleteMany []MonitorNodeScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []MonitorNodeUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type WeatherLiveWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
WindspeedNot *string `json:"windspeed_not,omitempty"`
WindspeedIn []string `json:"windspeed_in,omitempty"`
WindspeedNotIn []string `json:"windspeed_not_in,omitempty"`
WindspeedLt *string `json:"windspeed_lt,omitempty"`
WindspeedLte *string `json:"windspeed_lte,omitempty"`
WindspeedGt *string `json:"windspeed_gt,omitempty"`
WindspeedGte *string `json:"windspeed_gte,omitempty"`
WindspeedContains *string `json:"windspeed_contains,omitempty"`
WindspeedNotContains *string `json:"windspeed_not_contains,omitempty"`
WindspeedStartsWith *string `json:"windspeed_starts_with,omitempty"`
WindspeedNotStartsWith *string `json:"windspeed_not_starts_with,omitempty"`
WindspeedEndsWith *string `json:"windspeed_ends_with,omitempty"`
WindspeedNotEndsWith *string `json:"windspeed_not_ends_with,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
AirpressureNot *string `json:"airpressure_not,omitempty"`
AirpressureIn []string `json:"airpressure_in,omitempty"`
AirpressureNotIn []string `json:"airpressure_not_in,omitempty"`
AirpressureLt *string `json:"airpressure_lt,omitempty"`
AirpressureLte *string `json:"airpressure_lte,omitempty"`
AirpressureGt *string `json:"airpressure_gt,omitempty"`
AirpressureGte *string `json:"airpressure_gte,omitempty"`
AirpressureContains *string `json:"airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
PhenomenaNot *string `json:"phenomena_not,omitempty"`
PhenomenaIn []string `json:"phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"phenomena_lt,omitempty"`
PhenomenaLte *string `json:"phenomena_lte,omitempty"`
PhenomenaGt *string `json:"phenomena_gt,omitempty"`
PhenomenaGte *string `json:"phenomena_gte,omitempty"`
PhenomenaContains *string `json:"phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Humidity *string `json:"humidity,omitempty"`
HumidityNot *string `json:"humidity_not,omitempty"`
HumidityIn []string `json:"humidity_in,omitempty"`
HumidityNotIn []string `json:"humidity_not_in,omitempty"`
HumidityLt *string `json:"humidity_lt,omitempty"`
HumidityLte *string `json:"humidity_lte,omitempty"`
HumidityGt *string `json:"humidity_gt,omitempty"`
HumidityGte *string `json:"humidity_gte,omitempty"`
HumidityContains *string `json:"humidity_contains,omitempty"`
HumidityNotContains *string `json:"humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"humidity_not_ends_with,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
UpdatetimeNot *string `json:"updatetime_not,omitempty"`
UpdatetimeIn []string `json:"updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"updatetime_not_ends_with,omitempty"`
Windpower *string `json:"windpower,omitempty"`
WindpowerNot *string `json:"windpower_not,omitempty"`
WindpowerIn []string `json:"windpower_in,omitempty"`
WindpowerNotIn []string `json:"windpower_not_in,omitempty"`
WindpowerLt *string `json:"windpower_lt,omitempty"`
WindpowerLte *string `json:"windpower_lte,omitempty"`
WindpowerGt *string `json:"windpower_gt,omitempty"`
WindpowerGte *string `json:"windpower_gte,omitempty"`
WindpowerContains *string `json:"windpower_contains,omitempty"`
WindpowerNotContains *string `json:"windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"windpower_not_ends_with,omitempty"`
Feelst *string `json:"feelst,omitempty"`
FeelstNot *string `json:"feelst_not,omitempty"`
FeelstIn []string `json:"feelst_in,omitempty"`
FeelstNotIn []string `json:"feelst_not_in,omitempty"`
FeelstLt *string `json:"feelst_lt,omitempty"`
FeelstLte *string `json:"feelst_lte,omitempty"`
FeelstGt *string `json:"feelst_gt,omitempty"`
FeelstGte *string `json:"feelst_gte,omitempty"`
FeelstContains *string `json:"feelst_contains,omitempty"`
FeelstNotContains *string `json:"feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"feelst_not_ends_with,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
WinddirectNot *string `json:"winddirect_not,omitempty"`
WinddirectIn []string `json:"winddirect_in,omitempty"`
WinddirectNotIn []string `json:"winddirect_not_in,omitempty"`
WinddirectLt *string `json:"winddirect_lt,omitempty"`
WinddirectLte *string `json:"winddirect_lte,omitempty"`
WinddirectGt *string `json:"winddirect_gt,omitempty"`
WinddirectGte *string `json:"winddirect_gte,omitempty"`
WinddirectContains *string `json:"winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"winddirect_not_ends_with,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
RcodeNot *int32 `json:"rcode_not,omitempty"`
RcodeIn []int32 `json:"rcode_in,omitempty"`
RcodeNotIn []int32 `json:"rcode_not_in,omitempty"`
RcodeLt *int32 `json:"rcode_lt,omitempty"`
RcodeLte *int32 `json:"rcode_lte,omitempty"`
RcodeGt *int32 `json:"rcode_gt,omitempty"`
RcodeGte *int32 `json:"rcode_gte,omitempty"`
Rain *string `json:"rain,omitempty"`
RainNot *string `json:"rain_not,omitempty"`
RainIn []string `json:"rain_in,omitempty"`
RainNotIn []string `json:"rain_not_in,omitempty"`
RainLt *string `json:"rain_lt,omitempty"`
RainLte *string `json:"rain_lte,omitempty"`
RainGt *string `json:"rain_gt,omitempty"`
RainGte *string `json:"rain_gte,omitempty"`
RainContains *string `json:"rain_contains,omitempty"`
RainNotContains *string `json:"rain_not_contains,omitempty"`
RainStartsWith *string `json:"rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"rain_not_ends_with,omitempty"`
Temperature *string `json:"temperature,omitempty"`
TemperatureNot *string `json:"temperature_not,omitempty"`
TemperatureIn []string `json:"temperature_in,omitempty"`
TemperatureNotIn []string `json:"temperature_not_in,omitempty"`
TemperatureLt *string `json:"temperature_lt,omitempty"`
TemperatureLte *string `json:"temperature_lte,omitempty"`
TemperatureGt *string `json:"temperature_gt,omitempty"`
TemperatureGte *string `json:"temperature_gte,omitempty"`
TemperatureContains *string `json:"temperature_contains,omitempty"`
TemperatureNotContains *string `json:"temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"temperature_not_ends_with,omitempty"`
And []WeatherLiveWhereInput `json:"AND,omitempty"`
Or []WeatherLiveWhereInput `json:"OR,omitempty"`
Not []WeatherLiveWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeUpdateWithWhereUniqueWithoutLocationInput struct {
        Where MonitorNodeWhereUniqueInput `json:"where"`
Data MonitorNodeUpdateWithoutLocationDataInput `json:"data"`
          }

      type AirHistoryDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Time *string `json:"time,omitempty"`
TimeNot *string `json:"time_not,omitempty"`
TimeIn []string `json:"time_in,omitempty"`
TimeNotIn []string `json:"time_not_in,omitempty"`
TimeLt *string `json:"time_lt,omitempty"`
TimeLte *string `json:"time_lte,omitempty"`
TimeGt *string `json:"time_gt,omitempty"`
TimeGte *string `json:"time_gte,omitempty"`
TimeContains *string `json:"time_contains,omitempty"`
TimeNotContains *string `json:"time_not_contains,omitempty"`
TimeStartsWith *string `json:"time_starts_with,omitempty"`
TimeNotStartsWith *string `json:"time_not_starts_with,omitempty"`
TimeEndsWith *string `json:"time_ends_with,omitempty"`
TimeNotEndsWith *string `json:"time_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"o3,omitempty"`
O3Not *string `json:"o3_not,omitempty"`
O3In []string `json:"o3_in,omitempty"`
O3NotIn []string `json:"o3_not_in,omitempty"`
O3Lt *string `json:"o3_lt,omitempty"`
O3Lte *string `json:"o3_lte,omitempty"`
O3Gt *string `json:"o3_gt,omitempty"`
O3Gte *string `json:"o3_gte,omitempty"`
O3Contains *string `json:"o3_contains,omitempty"`
O3NotContains *string `json:"o3_not_contains,omitempty"`
O3StartsWith *string `json:"o3_starts_with,omitempty"`
O3NotStartsWith *string `json:"o3_not_starts_with,omitempty"`
O3EndsWith *string `json:"o3_ends_with,omitempty"`
O3NotEndsWith *string `json:"o3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"primary,omitempty"`
PrimaryNot *string `json:"primary_not,omitempty"`
PrimaryIn []string `json:"primary_in,omitempty"`
PrimaryNotIn []string `json:"primary_not_in,omitempty"`
PrimaryLt *string `json:"primary_lt,omitempty"`
PrimaryLte *string `json:"primary_lte,omitempty"`
PrimaryGt *string `json:"primary_gt,omitempty"`
PrimaryGte *string `json:"primary_gte,omitempty"`
PrimaryContains *string `json:"primary_contains,omitempty"`
PrimaryNotContains *string `json:"primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"primary_not_ends_with,omitempty"`
Rcode *string `json:"rcode,omitempty"`
RcodeNot *string `json:"rcode_not,omitempty"`
RcodeIn []string `json:"rcode_in,omitempty"`
RcodeNotIn []string `json:"rcode_not_in,omitempty"`
RcodeLt *string `json:"rcode_lt,omitempty"`
RcodeLte *string `json:"rcode_lte,omitempty"`
RcodeGt *string `json:"rcode_gt,omitempty"`
RcodeGte *string `json:"rcode_gte,omitempty"`
RcodeContains *string `json:"rcode_contains,omitempty"`
RcodeNotContains *string `json:"rcode_not_contains,omitempty"`
RcodeStartsWith *string `json:"rcode_starts_with,omitempty"`
RcodeNotStartsWith *string `json:"rcode_not_starts_with,omitempty"`
RcodeEndsWith *string `json:"rcode_ends_with,omitempty"`
RcodeNotEndsWith *string `json:"rcode_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
And []AirHistoryDataWhereInput `json:"AND,omitempty"`
Or []AirHistoryDataWhereInput `json:"OR,omitempty"`
Not []AirHistoryDataWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeUpdateWithoutLocationDataInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
RealTimeData *RealTimeDataUpdateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
HistoryDatas *HistoryDataUpdateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type LocationInfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *LocationInfoWhereInput `json:"node,omitempty"`
And []LocationInfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []LocationInfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []LocationInfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type RealTimeDataUpdateOneWithoutMonitorNodeInput struct {
        Create *RealTimeDataCreateWithoutMonitorNodeInput `json:"create,omitempty"`
Update *RealTimeDataUpdateWithoutMonitorNodeDataInput `json:"update,omitempty"`
Upsert *RealTimeDataUpsertWithoutMonitorNodeInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *RealTimeDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type MaCinfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Mac *string `json:"mac,omitempty"`
MacNot *string `json:"mac_not,omitempty"`
MacIn []string `json:"mac_in,omitempty"`
MacNotIn []string `json:"mac_not_in,omitempty"`
MacLt *string `json:"mac_lt,omitempty"`
MacLte *string `json:"mac_lte,omitempty"`
MacGt *string `json:"mac_gt,omitempty"`
MacGte *string `json:"mac_gte,omitempty"`
MacContains *string `json:"mac_contains,omitempty"`
MacNotContains *string `json:"mac_not_contains,omitempty"`
MacStartsWith *string `json:"mac_starts_with,omitempty"`
MacNotStartsWith *string `json:"mac_not_starts_with,omitempty"`
MacEndsWith *string `json:"mac_ends_with,omitempty"`
MacNotEndsWith *string `json:"mac_not_ends_with,omitempty"`
DevType *string `json:"devType,omitempty"`
DevTypeNot *string `json:"devType_not,omitempty"`
DevTypeIn []string `json:"devType_in,omitempty"`
DevTypeNotIn []string `json:"devType_not_in,omitempty"`
DevTypeLt *string `json:"devType_lt,omitempty"`
DevTypeLte *string `json:"devType_lte,omitempty"`
DevTypeGt *string `json:"devType_gt,omitempty"`
DevTypeGte *string `json:"devType_gte,omitempty"`
DevTypeContains *string `json:"devType_contains,omitempty"`
DevTypeNotContains *string `json:"devType_not_contains,omitempty"`
DevTypeStartsWith *string `json:"devType_starts_with,omitempty"`
DevTypeNotStartsWith *string `json:"devType_not_starts_with,omitempty"`
DevTypeEndsWith *string `json:"devType_ends_with,omitempty"`
DevTypeNotEndsWith *string `json:"devType_not_ends_with,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
ProbeCountNot *int32 `json:"probeCount_not,omitempty"`
ProbeCountIn []int32 `json:"probeCount_in,omitempty"`
ProbeCountNotIn []int32 `json:"probeCount_not_in,omitempty"`
ProbeCountLt *int32 `json:"probeCount_lt,omitempty"`
ProbeCountLte *int32 `json:"probeCount_lte,omitempty"`
ProbeCountGt *int32 `json:"probeCount_gt,omitempty"`
ProbeCountGte *int32 `json:"probeCount_gte,omitempty"`
LastProbeTime *string `json:"lastProbeTime,omitempty"`
LastProbeTimeNot *string `json:"lastProbeTime_not,omitempty"`
LastProbeTimeIn []string `json:"lastProbeTime_in,omitempty"`
LastProbeTimeNotIn []string `json:"lastProbeTime_not_in,omitempty"`
LastProbeTimeLt *string `json:"lastProbeTime_lt,omitempty"`
LastProbeTimeLte *string `json:"lastProbeTime_lte,omitempty"`
LastProbeTimeGt *string `json:"lastProbeTime_gt,omitempty"`
LastProbeTimeGte *string `json:"lastProbeTime_gte,omitempty"`
Person *PersonInfoWhereInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
IfOnlineNot *int32 `json:"ifOnline_not,omitempty"`
IfOnlineIn []int32 `json:"ifOnline_in,omitempty"`
IfOnlineNotIn []int32 `json:"ifOnline_not_in,omitempty"`
IfOnlineLt *int32 `json:"ifOnline_lt,omitempty"`
IfOnlineLte *int32 `json:"ifOnline_lte,omitempty"`
IfOnlineGt *int32 `json:"ifOnline_gt,omitempty"`
IfOnlineGte *int32 `json:"ifOnline_gte,omitempty"`
MacProbeDatasEvery *MacProbeDataWhereInput `json:"macProbeDatas_every,omitempty"`
MacProbeDatasSome *MacProbeDataWhereInput `json:"macProbeDatas_some,omitempty"`
MacProbeDatasNone *MacProbeDataWhereInput `json:"macProbeDatas_none,omitempty"`
AttendanceRecordsEvery *AttendanceRecordWhereInput `json:"attendanceRecords_every,omitempty"`
AttendanceRecordsSome *AttendanceRecordWhereInput `json:"attendanceRecords_some,omitempty"`
AttendanceRecordsNone *AttendanceRecordWhereInput `json:"attendanceRecords_none,omitempty"`
And []MaCinfoWhereInput `json:"AND,omitempty"`
Or []MaCinfoWhereInput `json:"OR,omitempty"`
Not []MaCinfoWhereInput `json:"NOT,omitempty"`
          }

      type RealTimeDataUpdateWithoutMonitorNodeDataInput struct {
        RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type IDCardVerifyDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *IDCardVerifyDataWhereInput `json:"node,omitempty"`
And []IDCardVerifyDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []IDCardVerifyDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []IDCardVerifyDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type RealTimeDataUpsertWithoutMonitorNodeInput struct {
        Update RealTimeDataUpdateWithoutMonitorNodeDataInput `json:"update"`
Create RealTimeDataCreateWithoutMonitorNodeInput `json:"create"`
          }

      type DataUnitSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *DataUnitWhereInput `json:"node,omitempty"`
And []DataUnitSubscriptionWhereInput `json:"AND,omitempty"`
Or []DataUnitSubscriptionWhereInput `json:"OR,omitempty"`
Not []DataUnitSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type HistoryDataUpdateManyWithoutMonitorNodeInput struct {
        Create []HistoryDataCreateWithoutMonitorNodeInput `json:"create,omitempty"`
Delete []HistoryDataWhereUniqueInput `json:"delete,omitempty"`
Connect []HistoryDataWhereUniqueInput `json:"connect,omitempty"`
Set []HistoryDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []HistoryDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []HistoryDataUpdateWithWhereUniqueWithoutMonitorNodeInput `json:"update,omitempty"`
Upsert []HistoryDataUpsertWithWhereUniqueWithoutMonitorNodeInput `json:"upsert,omitempty"`
DeleteMany []HistoryDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []HistoryDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type AttendanceRecordSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *AttendanceRecordWhereInput `json:"node,omitempty"`
And []AttendanceRecordSubscriptionWhereInput `json:"AND,omitempty"`
Or []AttendanceRecordSubscriptionWhereInput `json:"OR,omitempty"`
Not []AttendanceRecordSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type HistoryDataUpdateWithWhereUniqueWithoutMonitorNodeInput struct {
        Where HistoryDataWhereUniqueInput `json:"where"`
Data HistoryDataUpdateWithoutMonitorNodeDataInput `json:"data"`
          }

      type AirLiveWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Citycode *string `json:"citycode,omitempty"`
          }

      type HistoryDataUpdateWithoutMonitorNodeDataInput struct {
        RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type WiFiProberinfoUpdateManyMutationInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
          }

      type HistoryDataUpsertWithWhereUniqueWithoutMonitorNodeInput struct {
        Where HistoryDataWhereUniqueInput `json:"where"`
Update HistoryDataUpdateWithoutMonitorNodeDataInput `json:"update"`
Create HistoryDataCreateWithoutMonitorNodeInput `json:"create"`
          }

      type WiFiProberinfoCreateInput struct {
        ID *string `json:"id,omitempty"`
DevNo string `json:"devNo"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
LocationInfo *LocationInfoCreateOneWithoutWifiProbersInput `json:"locationInfo,omitempty"`
MacProbeDatas *MacProbeDataCreateManyWithoutWifiProberInput `json:"macProbeDatas,omitempty"`
          }

      type HistoryDataScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
RcvTimeNot *string `json:"rcvTime_not,omitempty"`
RcvTimeIn []string `json:"rcvTime_in,omitempty"`
RcvTimeNotIn []string `json:"rcvTime_not_in,omitempty"`
RcvTimeLt *string `json:"rcvTime_lt,omitempty"`
RcvTimeLte *string `json:"rcvTime_lte,omitempty"`
RcvTimeGt *string `json:"rcvTime_gt,omitempty"`
RcvTimeGte *string `json:"rcvTime_gte,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindSpeedNot *float64 `json:"windSpeed_not,omitempty"`
WindSpeedIn []float64 `json:"windSpeed_in,omitempty"`
WindSpeedNotIn []float64 `json:"windSpeed_not_in,omitempty"`
WindSpeedLt *float64 `json:"windSpeed_lt,omitempty"`
WindSpeedLte *float64 `json:"windSpeed_lte,omitempty"`
WindSpeedGt *float64 `json:"windSpeed_gt,omitempty"`
WindSpeedGte *float64 `json:"windSpeed_gte,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
WindDirectionNot *string `json:"windDirection_not,omitempty"`
WindDirectionIn []string `json:"windDirection_in,omitempty"`
WindDirectionNotIn []string `json:"windDirection_not_in,omitempty"`
WindDirectionLt *string `json:"windDirection_lt,omitempty"`
WindDirectionLte *string `json:"windDirection_lte,omitempty"`
WindDirectionGt *string `json:"windDirection_gt,omitempty"`
WindDirectionGte *string `json:"windDirection_gte,omitempty"`
WindDirectionContains *string `json:"windDirection_contains,omitempty"`
WindDirectionNotContains *string `json:"windDirection_not_contains,omitempty"`
WindDirectionStartsWith *string `json:"windDirection_starts_with,omitempty"`
WindDirectionNotStartsWith *string `json:"windDirection_not_starts_with,omitempty"`
WindDirectionEndsWith *string `json:"windDirection_ends_with,omitempty"`
WindDirectionNotEndsWith *string `json:"windDirection_not_ends_with,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
TemperatureNot *float64 `json:"temperature_not,omitempty"`
TemperatureIn []float64 `json:"temperature_in,omitempty"`
TemperatureNotIn []float64 `json:"temperature_not_in,omitempty"`
TemperatureLt *float64 `json:"temperature_lt,omitempty"`
TemperatureLte *float64 `json:"temperature_lte,omitempty"`
TemperatureGt *float64 `json:"temperature_gt,omitempty"`
TemperatureGte *float64 `json:"temperature_gte,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
HumidityNot *float64 `json:"humidity_not,omitempty"`
HumidityIn []float64 `json:"humidity_in,omitempty"`
HumidityNotIn []float64 `json:"humidity_not_in,omitempty"`
HumidityLt *float64 `json:"humidity_lt,omitempty"`
HumidityLte *float64 `json:"humidity_lte,omitempty"`
HumidityGt *float64 `json:"humidity_gt,omitempty"`
HumidityGte *float64 `json:"humidity_gte,omitempty"`
Noise *float64 `json:"noise,omitempty"`
NoiseNot *float64 `json:"noise_not,omitempty"`
NoiseIn []float64 `json:"noise_in,omitempty"`
NoiseNotIn []float64 `json:"noise_not_in,omitempty"`
NoiseLt *float64 `json:"noise_lt,omitempty"`
NoiseLte *float64 `json:"noise_lte,omitempty"`
NoiseGt *float64 `json:"noise_gt,omitempty"`
NoiseGte *float64 `json:"noise_gte,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm2Not *float64 `json:"pm2_not,omitempty"`
Pm2In []float64 `json:"pm2_in,omitempty"`
Pm2NotIn []float64 `json:"pm2_not_in,omitempty"`
Pm2Lt *float64 `json:"pm2_lt,omitempty"`
Pm2Lte *float64 `json:"pm2_lte,omitempty"`
Pm2Gt *float64 `json:"pm2_gt,omitempty"`
Pm2Gte *float64 `json:"pm2_gte,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Pm10Not *float64 `json:"pm10_not,omitempty"`
Pm10In []float64 `json:"pm10_in,omitempty"`
Pm10NotIn []float64 `json:"pm10_not_in,omitempty"`
Pm10Lt *float64 `json:"pm10_lt,omitempty"`
Pm10Lte *float64 `json:"pm10_lte,omitempty"`
Pm10Gt *float64 `json:"pm10_gt,omitempty"`
Pm10Gte *float64 `json:"pm10_gte,omitempty"`
Co *float64 `json:"co,omitempty"`
CoNot *float64 `json:"co_not,omitempty"`
CoIn []float64 `json:"co_in,omitempty"`
CoNotIn []float64 `json:"co_not_in,omitempty"`
CoLt *float64 `json:"co_lt,omitempty"`
CoLte *float64 `json:"co_lte,omitempty"`
CoGt *float64 `json:"co_gt,omitempty"`
CoGte *float64 `json:"co_gte,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
Co2Not *float64 `json:"co2_not,omitempty"`
Co2In []float64 `json:"co2_in,omitempty"`
Co2NotIn []float64 `json:"co2_not_in,omitempty"`
Co2Lt *float64 `json:"co2_lt,omitempty"`
Co2Lte *float64 `json:"co2_lte,omitempty"`
Co2Gt *float64 `json:"co2_gt,omitempty"`
Co2Gte *float64 `json:"co2_gte,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
AirPressureNot *float64 `json:"airPressure_not,omitempty"`
AirPressureIn []float64 `json:"airPressure_in,omitempty"`
AirPressureNotIn []float64 `json:"airPressure_not_in,omitempty"`
AirPressureLt *float64 `json:"airPressure_lt,omitempty"`
AirPressureLte *float64 `json:"airPressure_lte,omitempty"`
AirPressureGt *float64 `json:"airPressure_gt,omitempty"`
AirPressureGte *float64 `json:"airPressure_gte,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
SunLightNot *float64 `json:"sunLight_not,omitempty"`
SunLightIn []float64 `json:"sunLight_in,omitempty"`
SunLightNotIn []float64 `json:"sunLight_not_in,omitempty"`
SunLightLt *float64 `json:"sunLight_lt,omitempty"`
SunLightLte *float64 `json:"sunLight_lte,omitempty"`
SunLightGt *float64 `json:"sunLight_gt,omitempty"`
SunLightGte *float64 `json:"sunLight_gte,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
And []HistoryDataScalarWhereInput `json:"AND,omitempty"`
Or []HistoryDataScalarWhereInput `json:"OR,omitempty"`
Not []HistoryDataScalarWhereInput `json:"NOT,omitempty"`
          }

      type WeatherLiveUpdateManyMutationInput struct {
        Citycode *string `json:"citycode,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type HistoryDataUpdateManyWithWhereNestedInput struct {
        Where HistoryDataScalarWhereInput `json:"where"`
Data HistoryDataUpdateManyDataInput `json:"data"`
          }

      type CityCodeInfoUpdateWithoutWeatherLiveDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type HistoryDataUpdateManyDataInput struct {
        RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type IDCardVerifyDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevName *string `json:"devName,omitempty"`
DevNameNot *string `json:"devName_not,omitempty"`
DevNameIn []string `json:"devName_in,omitempty"`
DevNameNotIn []string `json:"devName_not_in,omitempty"`
DevNameLt *string `json:"devName_lt,omitempty"`
DevNameLte *string `json:"devName_lte,omitempty"`
DevNameGt *string `json:"devName_gt,omitempty"`
DevNameGte *string `json:"devName_gte,omitempty"`
DevNameContains *string `json:"devName_contains,omitempty"`
DevNameNotContains *string `json:"devName_not_contains,omitempty"`
DevNameStartsWith *string `json:"devName_starts_with,omitempty"`
DevNameNotStartsWith *string `json:"devName_not_starts_with,omitempty"`
DevNameEndsWith *string `json:"devName_ends_with,omitempty"`
DevNameNotEndsWith *string `json:"devName_not_ends_with,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
DevAddrNot *string `json:"devAddr_not,omitempty"`
DevAddrIn []string `json:"devAddr_in,omitempty"`
DevAddrNotIn []string `json:"devAddr_not_in,omitempty"`
DevAddrLt *string `json:"devAddr_lt,omitempty"`
DevAddrLte *string `json:"devAddr_lte,omitempty"`
DevAddrGt *string `json:"devAddr_gt,omitempty"`
DevAddrGte *string `json:"devAddr_gte,omitempty"`
DevAddrContains *string `json:"devAddr_contains,omitempty"`
DevAddrNotContains *string `json:"devAddr_not_contains,omitempty"`
DevAddrStartsWith *string `json:"devAddr_starts_with,omitempty"`
DevAddrNotStartsWith *string `json:"devAddr_not_starts_with,omitempty"`
DevAddrEndsWith *string `json:"devAddr_ends_with,omitempty"`
DevAddrNotEndsWith *string `json:"devAddr_not_ends_with,omitempty"`
IDCard *string `json:"idCard,omitempty"`
IDCardNot *string `json:"idCard_not,omitempty"`
IDCardIn []string `json:"idCard_in,omitempty"`
IDCardNotIn []string `json:"idCard_not_in,omitempty"`
IDCardLt *string `json:"idCard_lt,omitempty"`
IDCardLte *string `json:"idCard_lte,omitempty"`
IDCardGt *string `json:"idCard_gt,omitempty"`
IDCardGte *string `json:"idCard_gte,omitempty"`
IDCardContains *string `json:"idCard_contains,omitempty"`
IDCardNotContains *string `json:"idCard_not_contains,omitempty"`
IDCardStartsWith *string `json:"idCard_starts_with,omitempty"`
IDCardNotStartsWith *string `json:"idCard_not_starts_with,omitempty"`
IDCardEndsWith *string `json:"idCard_ends_with,omitempty"`
IDCardNotEndsWith *string `json:"idCard_not_ends_with,omitempty"`
PersonType *string `json:"personType,omitempty"`
PersonTypeNot *string `json:"personType_not,omitempty"`
PersonTypeIn []string `json:"personType_in,omitempty"`
PersonTypeNotIn []string `json:"personType_not_in,omitempty"`
PersonTypeLt *string `json:"personType_lt,omitempty"`
PersonTypeLte *string `json:"personType_lte,omitempty"`
PersonTypeGt *string `json:"personType_gt,omitempty"`
PersonTypeGte *string `json:"personType_gte,omitempty"`
PersonTypeContains *string `json:"personType_contains,omitempty"`
PersonTypeNotContains *string `json:"personType_not_contains,omitempty"`
PersonTypeStartsWith *string `json:"personType_starts_with,omitempty"`
PersonTypeNotStartsWith *string `json:"personType_not_starts_with,omitempty"`
PersonTypeEndsWith *string `json:"personType_ends_with,omitempty"`
PersonTypeNotEndsWith *string `json:"personType_not_ends_with,omitempty"`
Score *string `json:"score,omitempty"`
ScoreNot *string `json:"score_not,omitempty"`
ScoreIn []string `json:"score_in,omitempty"`
ScoreNotIn []string `json:"score_not_in,omitempty"`
ScoreLt *string `json:"score_lt,omitempty"`
ScoreLte *string `json:"score_lte,omitempty"`
ScoreGt *string `json:"score_gt,omitempty"`
ScoreGte *string `json:"score_gte,omitempty"`
ScoreContains *string `json:"score_contains,omitempty"`
ScoreNotContains *string `json:"score_not_contains,omitempty"`
ScoreStartsWith *string `json:"score_starts_with,omitempty"`
ScoreNotStartsWith *string `json:"score_not_starts_with,omitempty"`
ScoreEndsWith *string `json:"score_ends_with,omitempty"`
ScoreNotEndsWith *string `json:"score_not_ends_with,omitempty"`
Status *string `json:"status,omitempty"`
StatusNot *string `json:"status_not,omitempty"`
StatusIn []string `json:"status_in,omitempty"`
StatusNotIn []string `json:"status_not_in,omitempty"`
StatusLt *string `json:"status_lt,omitempty"`
StatusLte *string `json:"status_lte,omitempty"`
StatusGt *string `json:"status_gt,omitempty"`
StatusGte *string `json:"status_gte,omitempty"`
StatusContains *string `json:"status_contains,omitempty"`
StatusNotContains *string `json:"status_not_contains,omitempty"`
StatusStartsWith *string `json:"status_starts_with,omitempty"`
StatusNotStartsWith *string `json:"status_not_starts_with,omitempty"`
StatusEndsWith *string `json:"status_ends_with,omitempty"`
StatusNotEndsWith *string `json:"status_not_ends_with,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
FaceImgUriNot *string `json:"faceImgUri_not,omitempty"`
FaceImgUriIn []string `json:"faceImgUri_in,omitempty"`
FaceImgUriNotIn []string `json:"faceImgUri_not_in,omitempty"`
FaceImgUriLt *string `json:"faceImgUri_lt,omitempty"`
FaceImgUriLte *string `json:"faceImgUri_lte,omitempty"`
FaceImgUriGt *string `json:"faceImgUri_gt,omitempty"`
FaceImgUriGte *string `json:"faceImgUri_gte,omitempty"`
FaceImgUriContains *string `json:"faceImgUri_contains,omitempty"`
FaceImgUriNotContains *string `json:"faceImgUri_not_contains,omitempty"`
FaceImgUriStartsWith *string `json:"faceImgUri_starts_with,omitempty"`
FaceImgUriNotStartsWith *string `json:"faceImgUri_not_starts_with,omitempty"`
FaceImgUriEndsWith *string `json:"faceImgUri_ends_with,omitempty"`
FaceImgUriNotEndsWith *string `json:"faceImgUri_not_ends_with,omitempty"`
Person *PersonInfoWhereInput `json:"person,omitempty"`
IDVerifyDevice *IDVerifyDeviceInfoWhereInput `json:"idVerifyDevice,omitempty"`
And []IDCardVerifyDataWhereInput `json:"AND,omitempty"`
Or []IDCardVerifyDataWhereInput `json:"OR,omitempty"`
Not []IDCardVerifyDataWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeUpsertWithWhereUniqueWithoutLocationInput struct {
        Where MonitorNodeWhereUniqueInput `json:"where"`
Update MonitorNodeUpdateWithoutLocationDataInput `json:"update"`
Create MonitorNodeCreateWithoutLocationInput `json:"create"`
          }

      type WeatherLiveUpdateInput struct {
        Citycode *string `json:"citycode,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutWeatherLiveInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type MonitorNodeScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
MonitorSn *string `json:"monitorSN,omitempty"`
MonitorSnNot *string `json:"monitorSN_not,omitempty"`
MonitorSnIn []string `json:"monitorSN_in,omitempty"`
MonitorSnNotIn []string `json:"monitorSN_not_in,omitempty"`
MonitorSnLt *string `json:"monitorSN_lt,omitempty"`
MonitorSnLte *string `json:"monitorSN_lte,omitempty"`
MonitorSnGt *string `json:"monitorSN_gt,omitempty"`
MonitorSnGte *string `json:"monitorSN_gte,omitempty"`
MonitorSnContains *string `json:"monitorSN_contains,omitempty"`
MonitorSnNotContains *string `json:"monitorSN_not_contains,omitempty"`
MonitorSnStartsWith *string `json:"monitorSN_starts_with,omitempty"`
MonitorSnNotStartsWith *string `json:"monitorSN_not_starts_with,omitempty"`
MonitorSnEndsWith *string `json:"monitorSN_ends_with,omitempty"`
MonitorSnNotEndsWith *string `json:"monitorSN_not_ends_with,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorNameNot *string `json:"monitorName_not,omitempty"`
MonitorNameIn []string `json:"monitorName_in,omitempty"`
MonitorNameNotIn []string `json:"monitorName_not_in,omitempty"`
MonitorNameLt *string `json:"monitorName_lt,omitempty"`
MonitorNameLte *string `json:"monitorName_lte,omitempty"`
MonitorNameGt *string `json:"monitorName_gt,omitempty"`
MonitorNameGte *string `json:"monitorName_gte,omitempty"`
MonitorNameContains *string `json:"monitorName_contains,omitempty"`
MonitorNameNotContains *string `json:"monitorName_not_contains,omitempty"`
MonitorNameStartsWith *string `json:"monitorName_starts_with,omitempty"`
MonitorNameNotStartsWith *string `json:"monitorName_not_starts_with,omitempty"`
MonitorNameEndsWith *string `json:"monitorName_ends_with,omitempty"`
MonitorNameNotEndsWith *string `json:"monitorName_not_ends_with,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorTypeNot *string `json:"monitorType_not,omitempty"`
MonitorTypeIn []string `json:"monitorType_in,omitempty"`
MonitorTypeNotIn []string `json:"monitorType_not_in,omitempty"`
MonitorTypeLt *string `json:"monitorType_lt,omitempty"`
MonitorTypeLte *string `json:"monitorType_lte,omitempty"`
MonitorTypeGt *string `json:"monitorType_gt,omitempty"`
MonitorTypeGte *string `json:"monitorType_gte,omitempty"`
MonitorTypeContains *string `json:"monitorType_contains,omitempty"`
MonitorTypeNotContains *string `json:"monitorType_not_contains,omitempty"`
MonitorTypeStartsWith *string `json:"monitorType_starts_with,omitempty"`
MonitorTypeNotStartsWith *string `json:"monitorType_not_starts_with,omitempty"`
MonitorTypeEndsWith *string `json:"monitorType_ends_with,omitempty"`
MonitorTypeNotEndsWith *string `json:"monitorType_not_ends_with,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
MonitorStatusNot *string `json:"monitorStatus_not,omitempty"`
MonitorStatusIn []string `json:"monitorStatus_in,omitempty"`
MonitorStatusNotIn []string `json:"monitorStatus_not_in,omitempty"`
MonitorStatusLt *string `json:"monitorStatus_lt,omitempty"`
MonitorStatusLte *string `json:"monitorStatus_lte,omitempty"`
MonitorStatusGt *string `json:"monitorStatus_gt,omitempty"`
MonitorStatusGte *string `json:"monitorStatus_gte,omitempty"`
MonitorStatusContains *string `json:"monitorStatus_contains,omitempty"`
MonitorStatusNotContains *string `json:"monitorStatus_not_contains,omitempty"`
MonitorStatusStartsWith *string `json:"monitorStatus_starts_with,omitempty"`
MonitorStatusNotStartsWith *string `json:"monitorStatus_not_starts_with,omitempty"`
MonitorStatusEndsWith *string `json:"monitorStatus_ends_with,omitempty"`
MonitorStatusNotEndsWith *string `json:"monitorStatus_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []MonitorNodeScalarWhereInput `json:"AND,omitempty"`
Or []MonitorNodeScalarWhereInput `json:"OR,omitempty"`
Not []MonitorNodeScalarWhereInput `json:"NOT,omitempty"`
          }

      type DataUnitWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type MonitorNodeUpdateManyWithWhereNestedInput struct {
        Where MonitorNodeScalarWhereInput `json:"where"`
Data MonitorNodeUpdateManyDataInput `json:"data"`
          }

      type DataUnitWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
DataItem *string `json:"dataItem,omitempty"`
DataItemNot *string `json:"dataItem_not,omitempty"`
DataItemIn []string `json:"dataItem_in,omitempty"`
DataItemNotIn []string `json:"dataItem_not_in,omitempty"`
DataItemLt *string `json:"dataItem_lt,omitempty"`
DataItemLte *string `json:"dataItem_lte,omitempty"`
DataItemGt *string `json:"dataItem_gt,omitempty"`
DataItemGte *string `json:"dataItem_gte,omitempty"`
DataItemContains *string `json:"dataItem_contains,omitempty"`
DataItemNotContains *string `json:"dataItem_not_contains,omitempty"`
DataItemStartsWith *string `json:"dataItem_starts_with,omitempty"`
DataItemNotStartsWith *string `json:"dataItem_not_starts_with,omitempty"`
DataItemEndsWith *string `json:"dataItem_ends_with,omitempty"`
DataItemNotEndsWith *string `json:"dataItem_not_ends_with,omitempty"`
Unit *string `json:"unit,omitempty"`
UnitNot *string `json:"unit_not,omitempty"`
UnitIn []string `json:"unit_in,omitempty"`
UnitNotIn []string `json:"unit_not_in,omitempty"`
UnitLt *string `json:"unit_lt,omitempty"`
UnitLte *string `json:"unit_lte,omitempty"`
UnitGt *string `json:"unit_gt,omitempty"`
UnitGte *string `json:"unit_gte,omitempty"`
UnitContains *string `json:"unit_contains,omitempty"`
UnitNotContains *string `json:"unit_not_contains,omitempty"`
UnitStartsWith *string `json:"unit_starts_with,omitempty"`
UnitNotStartsWith *string `json:"unit_not_starts_with,omitempty"`
UnitEndsWith *string `json:"unit_ends_with,omitempty"`
UnitNotEndsWith *string `json:"unit_not_ends_with,omitempty"`
And []DataUnitWhereInput `json:"AND,omitempty"`
Or []DataUnitWhereInput `json:"OR,omitempty"`
Not []DataUnitWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeUpdateManyDataInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
          }

      type WeatherLiveCreateInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
CityInfo *CityCodeInfoCreateOneWithoutWeatherLiveInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateManyWithoutLocationInfoInput struct {
        Create []IDVerifyDeviceInfoCreateWithoutLocationInfoInput `json:"create,omitempty"`
Delete []IDVerifyDeviceInfoWhereUniqueInput `json:"delete,omitempty"`
Connect []IDVerifyDeviceInfoWhereUniqueInput `json:"connect,omitempty"`
Set []IDVerifyDeviceInfoWhereUniqueInput `json:"set,omitempty"`
Disconnect []IDVerifyDeviceInfoWhereUniqueInput `json:"disconnect,omitempty"`
Update []IDVerifyDeviceInfoUpdateWithWhereUniqueWithoutLocationInfoInput `json:"update,omitempty"`
Upsert []IDVerifyDeviceInfoUpsertWithWhereUniqueWithoutLocationInfoInput `json:"upsert,omitempty"`
DeleteMany []IDVerifyDeviceInfoScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []IDVerifyDeviceInfoUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type CityCodeInfoUpsertWithoutWeatherHistoryDatasInput struct {
        Update CityCodeInfoUpdateWithoutWeatherHistoryDatasDataInput `json:"update"`
Create CityCodeInfoCreateWithoutWeatherHistoryDatasInput `json:"create"`
          }

      type IDVerifyDeviceInfoUpdateWithWhereUniqueWithoutLocationInfoInput struct {
        Where IDVerifyDeviceInfoWhereUniqueInput `json:"where"`
Data IDVerifyDeviceInfoUpdateWithoutLocationInfoDataInput `json:"data"`
          }

      type CityCodeInfoUpdateWithoutWeatherHistoryDatasDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateWithoutLocationInfoDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataUpdateManyWithoutIdVerifyDeviceInput `json:"idCardVerifyDatas,omitempty"`
          }

      type WeatherHistoryDataUpdateInput struct {
        Citycode *string `json:"citycode,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutWeatherHistoryDatasInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type IDCardVerifyDataUpdateManyWithoutIdVerifyDeviceInput struct {
        Create []IDCardVerifyDataCreateWithoutIdVerifyDeviceInput `json:"create,omitempty"`
Delete []IDCardVerifyDataWhereUniqueInput `json:"delete,omitempty"`
Connect []IDCardVerifyDataWhereUniqueInput `json:"connect,omitempty"`
Set []IDCardVerifyDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []IDCardVerifyDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []IDCardVerifyDataUpdateWithWhereUniqueWithoutIdVerifyDeviceInput `json:"update,omitempty"`
Upsert []IDCardVerifyDataUpsertWithWhereUniqueWithoutIdVerifyDeviceInput `json:"upsert,omitempty"`
DeleteMany []IDCardVerifyDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []IDCardVerifyDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type CityCodeInfoCreateWithoutWeatherHistoryDatasInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
          }

      type IDCardVerifyDataUpdateWithWhereUniqueWithoutIdVerifyDeviceInput struct {
        Where IDCardVerifyDataWhereUniqueInput `json:"where"`
Data IDCardVerifyDataUpdateWithoutIdVerifyDeviceDataInput `json:"data"`
          }

      type WeatherHistoryDataCreateInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
CityInfo *CityCodeInfoCreateOneWithoutWeatherHistoryDatasInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type IDCardVerifyDataUpdateWithoutIdVerifyDeviceDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
Person *PersonInfoUpdateOneWithoutIdCardVerifyDatasInput `json:"person,omitempty"`
          }

      type WeatherAirLiveUpdateManyMutationInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type PersonInfoUpdateOneWithoutIdCardVerifyDatasInput struct {
        Create *PersonInfoCreateWithoutIdCardVerifyDatasInput `json:"create,omitempty"`
Update *PersonInfoUpdateWithoutIdCardVerifyDatasDataInput `json:"update,omitempty"`
Upsert *PersonInfoUpsertWithoutIdCardVerifyDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *PersonInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoUpdateWithoutWeatherAirLiveDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type PersonInfoUpdateWithoutIdCardVerifyDatasDataInput struct {
        IDCard *string `json:"idCard,omitempty"`
CardType *string `json:"cardType,omitempty"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
Macinfos *MaCinfoUpdateManyWithoutPersonInput `json:"macinfos,omitempty"`
          }

      type LocationInfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Describe *string `json:"describe,omitempty"`
DescribeNot *string `json:"describe_not,omitempty"`
DescribeIn []string `json:"describe_in,omitempty"`
DescribeNotIn []string `json:"describe_not_in,omitempty"`
DescribeLt *string `json:"describe_lt,omitempty"`
DescribeLte *string `json:"describe_lte,omitempty"`
DescribeGt *string `json:"describe_gt,omitempty"`
DescribeGte *string `json:"describe_gte,omitempty"`
DescribeContains *string `json:"describe_contains,omitempty"`
DescribeNotContains *string `json:"describe_not_contains,omitempty"`
DescribeStartsWith *string `json:"describe_starts_with,omitempty"`
DescribeNotStartsWith *string `json:"describe_not_starts_with,omitempty"`
DescribeEndsWith *string `json:"describe_ends_with,omitempty"`
DescribeNotEndsWith *string `json:"describe_not_ends_with,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
LongitudeNot *float64 `json:"longitude_not,omitempty"`
LongitudeIn []float64 `json:"longitude_in,omitempty"`
LongitudeNotIn []float64 `json:"longitude_not_in,omitempty"`
LongitudeLt *float64 `json:"longitude_lt,omitempty"`
LongitudeLte *float64 `json:"longitude_lte,omitempty"`
LongitudeGt *float64 `json:"longitude_gt,omitempty"`
LongitudeGte *float64 `json:"longitude_gte,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
LatitudeNot *float64 `json:"latitude_not,omitempty"`
LatitudeIn []float64 `json:"latitude_in,omitempty"`
LatitudeNotIn []float64 `json:"latitude_not_in,omitempty"`
LatitudeLt *float64 `json:"latitude_lt,omitempty"`
LatitudeLte *float64 `json:"latitude_lte,omitempty"`
LatitudeGt *float64 `json:"latitude_gt,omitempty"`
LatitudeGte *float64 `json:"latitude_gte,omitempty"`
Province *string `json:"province,omitempty"`
ProvinceNot *string `json:"province_not,omitempty"`
ProvinceIn []string `json:"province_in,omitempty"`
ProvinceNotIn []string `json:"province_not_in,omitempty"`
ProvinceLt *string `json:"province_lt,omitempty"`
ProvinceLte *string `json:"province_lte,omitempty"`
ProvinceGt *string `json:"province_gt,omitempty"`
ProvinceGte *string `json:"province_gte,omitempty"`
ProvinceContains *string `json:"province_contains,omitempty"`
ProvinceNotContains *string `json:"province_not_contains,omitempty"`
ProvinceStartsWith *string `json:"province_starts_with,omitempty"`
ProvinceNotStartsWith *string `json:"province_not_starts_with,omitempty"`
ProvinceEndsWith *string `json:"province_ends_with,omitempty"`
ProvinceNotEndsWith *string `json:"province_not_ends_with,omitempty"`
City *string `json:"city,omitempty"`
CityNot *string `json:"city_not,omitempty"`
CityIn []string `json:"city_in,omitempty"`
CityNotIn []string `json:"city_not_in,omitempty"`
CityLt *string `json:"city_lt,omitempty"`
CityLte *string `json:"city_lte,omitempty"`
CityGt *string `json:"city_gt,omitempty"`
CityGte *string `json:"city_gte,omitempty"`
CityContains *string `json:"city_contains,omitempty"`
CityNotContains *string `json:"city_not_contains,omitempty"`
CityStartsWith *string `json:"city_starts_with,omitempty"`
CityNotStartsWith *string `json:"city_not_starts_with,omitempty"`
CityEndsWith *string `json:"city_ends_with,omitempty"`
CityNotEndsWith *string `json:"city_not_ends_with,omitempty"`
County *string `json:"county,omitempty"`
CountyNot *string `json:"county_not,omitempty"`
CountyIn []string `json:"county_in,omitempty"`
CountyNotIn []string `json:"county_not_in,omitempty"`
CountyLt *string `json:"county_lt,omitempty"`
CountyLte *string `json:"county_lte,omitempty"`
CountyGt *string `json:"county_gt,omitempty"`
CountyGte *string `json:"county_gte,omitempty"`
CountyContains *string `json:"county_contains,omitempty"`
CountyNotContains *string `json:"county_not_contains,omitempty"`
CountyStartsWith *string `json:"county_starts_with,omitempty"`
CountyNotStartsWith *string `json:"county_not_starts_with,omitempty"`
CountyEndsWith *string `json:"county_ends_with,omitempty"`
CountyNotEndsWith *string `json:"county_not_ends_with,omitempty"`
Street *string `json:"street,omitempty"`
StreetNot *string `json:"street_not,omitempty"`
StreetIn []string `json:"street_in,omitempty"`
StreetNotIn []string `json:"street_not_in,omitempty"`
StreetLt *string `json:"street_lt,omitempty"`
StreetLte *string `json:"street_lte,omitempty"`
StreetGt *string `json:"street_gt,omitempty"`
StreetGte *string `json:"street_gte,omitempty"`
StreetContains *string `json:"street_contains,omitempty"`
StreetNotContains *string `json:"street_not_contains,omitempty"`
StreetStartsWith *string `json:"street_starts_with,omitempty"`
StreetNotStartsWith *string `json:"street_not_starts_with,omitempty"`
StreetEndsWith *string `json:"street_ends_with,omitempty"`
StreetNotEndsWith *string `json:"street_not_ends_with,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
IndoorLocalNot *string `json:"indoorLocal_not,omitempty"`
IndoorLocalIn []string `json:"indoorLocal_in,omitempty"`
IndoorLocalNotIn []string `json:"indoorLocal_not_in,omitempty"`
IndoorLocalLt *string `json:"indoorLocal_lt,omitempty"`
IndoorLocalLte *string `json:"indoorLocal_lte,omitempty"`
IndoorLocalGt *string `json:"indoorLocal_gt,omitempty"`
IndoorLocalGte *string `json:"indoorLocal_gte,omitempty"`
IndoorLocalContains *string `json:"indoorLocal_contains,omitempty"`
IndoorLocalNotContains *string `json:"indoorLocal_not_contains,omitempty"`
IndoorLocalStartsWith *string `json:"indoorLocal_starts_with,omitempty"`
IndoorLocalNotStartsWith *string `json:"indoorLocal_not_starts_with,omitempty"`
IndoorLocalEndsWith *string `json:"indoorLocal_ends_with,omitempty"`
IndoorLocalNotEndsWith *string `json:"indoorLocal_not_ends_with,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
OutdoorLocalNot *string `json:"outdoorLocal_not,omitempty"`
OutdoorLocalIn []string `json:"outdoorLocal_in,omitempty"`
OutdoorLocalNotIn []string `json:"outdoorLocal_not_in,omitempty"`
OutdoorLocalLt *string `json:"outdoorLocal_lt,omitempty"`
OutdoorLocalLte *string `json:"outdoorLocal_lte,omitempty"`
OutdoorLocalGt *string `json:"outdoorLocal_gt,omitempty"`
OutdoorLocalGte *string `json:"outdoorLocal_gte,omitempty"`
OutdoorLocalContains *string `json:"outdoorLocal_contains,omitempty"`
OutdoorLocalNotContains *string `json:"outdoorLocal_not_contains,omitempty"`
OutdoorLocalStartsWith *string `json:"outdoorLocal_starts_with,omitempty"`
OutdoorLocalNotStartsWith *string `json:"outdoorLocal_not_starts_with,omitempty"`
OutdoorLocalEndsWith *string `json:"outdoorLocal_ends_with,omitempty"`
OutdoorLocalNotEndsWith *string `json:"outdoorLocal_not_ends_with,omitempty"`
MonitorNodesEvery *MonitorNodeWhereInput `json:"monitorNodes_every,omitempty"`
MonitorNodesSome *MonitorNodeWhereInput `json:"monitorNodes_some,omitempty"`
MonitorNodesNone *MonitorNodeWhereInput `json:"monitorNodes_none,omitempty"`
IDVerifyDevicesEvery *IDVerifyDeviceInfoWhereInput `json:"idVerifyDevices_every,omitempty"`
IDVerifyDevicesSome *IDVerifyDeviceInfoWhereInput `json:"idVerifyDevices_some,omitempty"`
IDVerifyDevicesNone *IDVerifyDeviceInfoWhereInput `json:"idVerifyDevices_none,omitempty"`
WifiProbersEvery *WiFiProberinfoWhereInput `json:"wifiProbers_every,omitempty"`
WifiProbersSome *WiFiProberinfoWhereInput `json:"wifiProbers_some,omitempty"`
WifiProbersNone *WiFiProberinfoWhereInput `json:"wifiProbers_none,omitempty"`
And []LocationInfoWhereInput `json:"AND,omitempty"`
Or []LocationInfoWhereInput `json:"OR,omitempty"`
Not []LocationInfoWhereInput `json:"NOT,omitempty"`
          }

      type MaCinfoUpdateManyWithoutPersonInput struct {
        Create []MaCinfoCreateWithoutPersonInput `json:"create,omitempty"`
Delete []MaCinfoWhereUniqueInput `json:"delete,omitempty"`
Connect []MaCinfoWhereUniqueInput `json:"connect,omitempty"`
Set []MaCinfoWhereUniqueInput `json:"set,omitempty"`
Disconnect []MaCinfoWhereUniqueInput `json:"disconnect,omitempty"`
Update []MaCinfoUpdateWithWhereUniqueWithoutPersonInput `json:"update,omitempty"`
Upsert []MaCinfoUpsertWithWhereUniqueWithoutPersonInput `json:"upsert,omitempty"`
DeleteMany []MaCinfoScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []MaCinfoUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type WeatherAirLiveUpdateInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutWeatherAirLiveInput `json:"cityInfo,omitempty"`
          }

      type MaCinfoUpdateWithWhereUniqueWithoutPersonInput struct {
        Where MaCinfoWhereUniqueInput `json:"where"`
Data MaCinfoUpdateWithoutPersonDataInput `json:"data"`
          }

      type MacProbeDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type MaCinfoUpdateWithoutPersonDataInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataUpdateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
AttendanceRecords *AttendanceRecordUpdateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type WeatherAirLiveCreateInput struct {
        ID *string `json:"id,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoCreateOneWithoutWeatherAirLiveInput `json:"cityInfo,omitempty"`
          }

      type MacProbeDataUpdateManyWithoutMacInput struct {
        Create []MacProbeDataCreateWithoutMacInput `json:"create,omitempty"`
Delete []MacProbeDataWhereUniqueInput `json:"delete,omitempty"`
Connect []MacProbeDataWhereUniqueInput `json:"connect,omitempty"`
Set []MacProbeDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []MacProbeDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []MacProbeDataUpdateWithWhereUniqueWithoutMacInput `json:"update,omitempty"`
Upsert []MacProbeDataUpsertWithWhereUniqueWithoutMacInput `json:"upsert,omitempty"`
DeleteMany []MacProbeDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []MacProbeDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type MacProbeRecordWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type MacProbeDataUpdateWithWhereUniqueWithoutMacInput struct {
        Where MacProbeDataWhereUniqueInput `json:"where"`
Data MacProbeDataUpdateWithoutMacDataInput `json:"data"`
          }

      type MacProbeRecordWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Mac *string `json:"mac,omitempty"`
MacNot *string `json:"mac_not,omitempty"`
MacIn []string `json:"mac_in,omitempty"`
MacNotIn []string `json:"mac_not_in,omitempty"`
MacLt *string `json:"mac_lt,omitempty"`
MacLte *string `json:"mac_lte,omitempty"`
MacGt *string `json:"mac_gt,omitempty"`
MacGte *string `json:"mac_gte,omitempty"`
MacContains *string `json:"mac_contains,omitempty"`
MacNotContains *string `json:"mac_not_contains,omitempty"`
MacStartsWith *string `json:"mac_starts_with,omitempty"`
MacNotStartsWith *string `json:"mac_not_starts_with,omitempty"`
MacEndsWith *string `json:"mac_ends_with,omitempty"`
MacNotEndsWith *string `json:"mac_not_ends_with,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
EntryTime *string `json:"entryTime,omitempty"`
EntryTimeNot *string `json:"entryTime_not,omitempty"`
EntryTimeIn []string `json:"entryTime_in,omitempty"`
EntryTimeNotIn []string `json:"entryTime_not_in,omitempty"`
EntryTimeLt *string `json:"entryTime_lt,omitempty"`
EntryTimeLte *string `json:"entryTime_lte,omitempty"`
EntryTimeGt *string `json:"entryTime_gt,omitempty"`
EntryTimeGte *string `json:"entryTime_gte,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
DepartureTimeNot *string `json:"departureTime_not,omitempty"`
DepartureTimeIn []string `json:"departureTime_in,omitempty"`
DepartureTimeNotIn []string `json:"departureTime_not_in,omitempty"`
DepartureTimeLt *string `json:"departureTime_lt,omitempty"`
DepartureTimeLte *string `json:"departureTime_lte,omitempty"`
DepartureTimeGt *string `json:"departureTime_gt,omitempty"`
DepartureTimeGte *string `json:"departureTime_gte,omitempty"`
And []MacProbeRecordWhereInput `json:"AND,omitempty"`
Or []MacProbeRecordWhereInput `json:"OR,omitempty"`
Not []MacProbeRecordWhereInput `json:"NOT,omitempty"`
          }

      type MacProbeDataUpdateWithoutMacDataInput struct {
        ProbeTime *string `json:"probeTime,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
WifiProber *WiFiProberinfoUpdateOneWithoutMacProbeDatasInput `json:"wifiProber,omitempty"`
          }

      type CityCodeInfoUpdateWithoutWeatherAirHistoryDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type WiFiProberinfoUpdateOneWithoutMacProbeDatasInput struct {
        Create *WiFiProberinfoCreateWithoutMacProbeDatasInput `json:"create,omitempty"`
Update *WiFiProberinfoUpdateWithoutMacProbeDatasDataInput `json:"update,omitempty"`
Upsert *WiFiProberinfoUpsertWithoutMacProbeDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *WiFiProberinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherAirHistoryUpdateInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutWeatherAirHistoryInput `json:"cityInfo,omitempty"`
          }

      type WiFiProberinfoUpdateWithoutMacProbeDatasDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
LocationInfo *LocationInfoUpdateOneWithoutWifiProbersInput `json:"locationInfo,omitempty"`
          }

      type CityCodeInfoCreateWithoutWeatherAirHistoryInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type LocationInfoUpdateOneWithoutWifiProbersInput struct {
        Create *LocationInfoCreateWithoutWifiProbersInput `json:"create,omitempty"`
Update *LocationInfoUpdateWithoutWifiProbersDataInput `json:"update,omitempty"`
Upsert *LocationInfoUpsertWithoutWifiProbersInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherAirHistoryCreateInput struct {
        ID *string `json:"id,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoCreateOneWithoutWeatherAirHistoryInput `json:"cityInfo,omitempty"`
          }

      type LocationInfoUpdateWithoutWifiProbersDataInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeUpdateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoUpdateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
          }

      type RealTimeDataUpdateManyMutationInput struct {
        RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type LocationInfoUpsertWithoutWifiProbersInput struct {
        Update LocationInfoUpdateWithoutWifiProbersDataInput `json:"update"`
Create LocationInfoCreateWithoutWifiProbersInput `json:"create"`
          }

      type MonitorNodeUpdateWithoutRealTimeDataDataInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
Location *LocationInfoUpdateOneWithoutMonitorNodesInput `json:"location,omitempty"`
HistoryDatas *HistoryDataUpdateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type WiFiProberinfoUpsertWithoutMacProbeDatasInput struct {
        Update WiFiProberinfoUpdateWithoutMacProbeDatasDataInput `json:"update"`
Create WiFiProberinfoCreateWithoutMacProbeDatasInput `json:"create"`
          }

      type MonitorNodeUpdateOneRequiredWithoutRealTimeDataInput struct {
        Create *MonitorNodeCreateWithoutRealTimeDataInput `json:"create,omitempty"`
Update *MonitorNodeUpdateWithoutRealTimeDataDataInput `json:"update,omitempty"`
Upsert *MonitorNodeUpsertWithoutRealTimeDataInput `json:"upsert,omitempty"`
Connect *MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
          }

      type MacProbeDataUpsertWithWhereUniqueWithoutMacInput struct {
        Where MacProbeDataWhereUniqueInput `json:"where"`
Update MacProbeDataUpdateWithoutMacDataInput `json:"update"`
Create MacProbeDataCreateWithoutMacInput `json:"create"`
          }

      type MonitorNodeCreateWithoutRealTimeDataInput struct {
        ID *string `json:"id,omitempty"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
Location *LocationInfoCreateOneWithoutMonitorNodesInput `json:"location,omitempty"`
HistoryDatas *HistoryDataCreateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type MacProbeDataScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
ProbeTime *string `json:"probeTime,omitempty"`
ProbeTimeNot *string `json:"probeTime_not,omitempty"`
ProbeTimeIn []string `json:"probeTime_in,omitempty"`
ProbeTimeNotIn []string `json:"probeTime_not_in,omitempty"`
ProbeTimeLt *string `json:"probeTime_lt,omitempty"`
ProbeTimeLte *string `json:"probeTime_lte,omitempty"`
ProbeTimeGt *string `json:"probeTime_gt,omitempty"`
ProbeTimeGte *string `json:"probeTime_gte,omitempty"`
ProbeTimeContains *string `json:"probeTime_contains,omitempty"`
ProbeTimeNotContains *string `json:"probeTime_not_contains,omitempty"`
ProbeTimeStartsWith *string `json:"probeTime_starts_with,omitempty"`
ProbeTimeNotStartsWith *string `json:"probeTime_not_starts_with,omitempty"`
ProbeTimeEndsWith *string `json:"probeTime_ends_with,omitempty"`
ProbeTimeNotEndsWith *string `json:"probeTime_not_ends_with,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
IsConnetNot *string `json:"isConnet_not,omitempty"`
IsConnetIn []string `json:"isConnet_in,omitempty"`
IsConnetNotIn []string `json:"isConnet_not_in,omitempty"`
IsConnetLt *string `json:"isConnet_lt,omitempty"`
IsConnetLte *string `json:"isConnet_lte,omitempty"`
IsConnetGt *string `json:"isConnet_gt,omitempty"`
IsConnetGte *string `json:"isConnet_gte,omitempty"`
IsConnetContains *string `json:"isConnet_contains,omitempty"`
IsConnetNotContains *string `json:"isConnet_not_contains,omitempty"`
IsConnetStartsWith *string `json:"isConnet_starts_with,omitempty"`
IsConnetNotStartsWith *string `json:"isConnet_not_starts_with,omitempty"`
IsConnetEndsWith *string `json:"isConnet_ends_with,omitempty"`
IsConnetNotEndsWith *string `json:"isConnet_not_ends_with,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterMacNot *string `json:"routerMAC_not,omitempty"`
RouterMacIn []string `json:"routerMAC_in,omitempty"`
RouterMacNotIn []string `json:"routerMAC_not_in,omitempty"`
RouterMacLt *string `json:"routerMAC_lt,omitempty"`
RouterMacLte *string `json:"routerMAC_lte,omitempty"`
RouterMacGt *string `json:"routerMAC_gt,omitempty"`
RouterMacGte *string `json:"routerMAC_gte,omitempty"`
RouterMacContains *string `json:"routerMAC_contains,omitempty"`
RouterMacNotContains *string `json:"routerMAC_not_contains,omitempty"`
RouterMacStartsWith *string `json:"routerMAC_starts_with,omitempty"`
RouterMacNotStartsWith *string `json:"routerMAC_not_starts_with,omitempty"`
RouterMacEndsWith *string `json:"routerMAC_ends_with,omitempty"`
RouterMacNotEndsWith *string `json:"routerMAC_not_ends_with,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
RouterSsidNot *string `json:"routerSSID_not,omitempty"`
RouterSsidIn []string `json:"routerSSID_in,omitempty"`
RouterSsidNotIn []string `json:"routerSSID_not_in,omitempty"`
RouterSsidLt *string `json:"routerSSID_lt,omitempty"`
RouterSsidLte *string `json:"routerSSID_lte,omitempty"`
RouterSsidGt *string `json:"routerSSID_gt,omitempty"`
RouterSsidGte *string `json:"routerSSID_gte,omitempty"`
RouterSsidContains *string `json:"routerSSID_contains,omitempty"`
RouterSsidNotContains *string `json:"routerSSID_not_contains,omitempty"`
RouterSsidStartsWith *string `json:"routerSSID_starts_with,omitempty"`
RouterSsidNotStartsWith *string `json:"routerSSID_not_starts_with,omitempty"`
RouterSsidEndsWith *string `json:"routerSSID_ends_with,omitempty"`
RouterSsidNotEndsWith *string `json:"routerSSID_not_ends_with,omitempty"`
Destance *string `json:"destance,omitempty"`
DestanceNot *string `json:"destance_not,omitempty"`
DestanceIn []string `json:"destance_in,omitempty"`
DestanceNotIn []string `json:"destance_not_in,omitempty"`
DestanceLt *string `json:"destance_lt,omitempty"`
DestanceLte *string `json:"destance_lte,omitempty"`
DestanceGt *string `json:"destance_gt,omitempty"`
DestanceGte *string `json:"destance_gte,omitempty"`
DestanceContains *string `json:"destance_contains,omitempty"`
DestanceNotContains *string `json:"destance_not_contains,omitempty"`
DestanceStartsWith *string `json:"destance_starts_with,omitempty"`
DestanceNotStartsWith *string `json:"destance_not_starts_with,omitempty"`
DestanceEndsWith *string `json:"destance_ends_with,omitempty"`
DestanceNotEndsWith *string `json:"destance_not_ends_with,omitempty"`
And []MacProbeDataScalarWhereInput `json:"AND,omitempty"`
Or []MacProbeDataScalarWhereInput `json:"OR,omitempty"`
Not []MacProbeDataScalarWhereInput `json:"NOT,omitempty"`
          }

      type RealTimeDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type MacProbeDataUpdateManyWithWhereNestedInput struct {
        Where MacProbeDataScalarWhereInput `json:"where"`
Data MacProbeDataUpdateManyDataInput `json:"data"`
          }

      type PersonInfoUpdateManyMutationInput struct {
        IDCard *string `json:"idCard,omitempty"`
CardType *string `json:"cardType,omitempty"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
          }

      type MacProbeDataUpdateManyDataInput struct {
        ProbeTime *string `json:"probeTime,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
          }

      type PersonInfoCreateInput struct {
        ID *string `json:"id,omitempty"`
IDCard string `json:"idCard"`
CardType string `json:"cardType"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataCreateManyWithoutPersonInput `json:"idCardVerifyDatas,omitempty"`
Macinfos *MaCinfoCreateManyWithoutPersonInput `json:"macinfos,omitempty"`
          }

      type IDCardVerifyDataUpdateManyMutationInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
          }

      type MonitorNodeUpdateManyMutationInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
          }

      type AttendanceRecordUpdateWithWhereUniqueWithoutMacInput struct {
        Where AttendanceRecordWhereUniqueInput `json:"where"`
Data AttendanceRecordUpdateWithoutMacDataInput `json:"data"`
          }

      type MonitorNodeCreateInput struct {
        ID *string `json:"id,omitempty"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
Location *LocationInfoCreateOneWithoutMonitorNodesInput `json:"location,omitempty"`
RealTimeData *RealTimeDataCreateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
HistoryDatas *HistoryDataCreateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type AttendanceRecordUpdateWithoutMacDataInput struct {
        AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type MaCinfoUpdateManyMutationInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
          }

      type AttendanceRecordUpsertWithWhereUniqueWithoutMacInput struct {
        Where AttendanceRecordWhereUniqueInput `json:"where"`
Update AttendanceRecordUpdateWithoutMacDataInput `json:"update"`
Create AttendanceRecordCreateWithoutMacInput `json:"create"`
          }

      type MaCinfoCreateInput struct {
        ID *string `json:"id,omitempty"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoCreateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataCreateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
AttendanceRecords *AttendanceRecordCreateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type AttendanceRecordScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
AttDate *string `json:"attDate,omitempty"`
AttDateNot *string `json:"attDate_not,omitempty"`
AttDateIn []string `json:"attDate_in,omitempty"`
AttDateNotIn []string `json:"attDate_not_in,omitempty"`
AttDateLt *string `json:"attDate_lt,omitempty"`
AttDateLte *string `json:"attDate_lte,omitempty"`
AttDateGt *string `json:"attDate_gt,omitempty"`
AttDateGte *string `json:"attDate_gte,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
TotalSecondNot *string `json:"totalSecond_not,omitempty"`
TotalSecondIn []string `json:"totalSecond_in,omitempty"`
TotalSecondNotIn []string `json:"totalSecond_not_in,omitempty"`
TotalSecondLt *string `json:"totalSecond_lt,omitempty"`
TotalSecondLte *string `json:"totalSecond_lte,omitempty"`
TotalSecondGt *string `json:"totalSecond_gt,omitempty"`
TotalSecondGte *string `json:"totalSecond_gte,omitempty"`
TotalSecondContains *string `json:"totalSecond_contains,omitempty"`
TotalSecondNotContains *string `json:"totalSecond_not_contains,omitempty"`
TotalSecondStartsWith *string `json:"totalSecond_starts_with,omitempty"`
TotalSecondNotStartsWith *string `json:"totalSecond_not_starts_with,omitempty"`
TotalSecondEndsWith *string `json:"totalSecond_ends_with,omitempty"`
TotalSecondNotEndsWith *string `json:"totalSecond_not_ends_with,omitempty"`
And []AttendanceRecordScalarWhereInput `json:"AND,omitempty"`
Or []AttendanceRecordScalarWhereInput `json:"OR,omitempty"`
Not []AttendanceRecordScalarWhereInput `json:"NOT,omitempty"`
          }

      type WeatherHistoryDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type AttendanceRecordUpdateManyWithWhereNestedInput struct {
        Where AttendanceRecordScalarWhereInput `json:"where"`
Data AttendanceRecordUpdateManyDataInput `json:"data"`
          }

      type MacProbeRecordCreateInput struct {
        ID *string `json:"id,omitempty"`
Mac string `json:"mac"`
DevNo string `json:"devNo"`
EntryTime *string `json:"entryTime,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
          }

      type AttendanceRecordUpdateManyDataInput struct {
        AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type WeatherLiveWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Citycode *string `json:"citycode,omitempty"`
          }

      type MaCinfoUpsertWithWhereUniqueWithoutPersonInput struct {
        Where MaCinfoWhereUniqueInput `json:"where"`
Update MaCinfoUpdateWithoutPersonDataInput `json:"update"`
Create MaCinfoCreateWithoutPersonInput `json:"create"`
          }

      type MacProbeDataCreateInput struct {
        ID *string `json:"id,omitempty"`
ProbeTime string `json:"probeTime"`
Mac *MaCinfoCreateOneWithoutMacProbeDatasInput `json:"mac,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
WifiProber *WiFiProberinfoCreateOneWithoutMacProbeDatasInput `json:"wifiProber,omitempty"`
          }

      type MaCinfoScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Mac *string `json:"mac,omitempty"`
MacNot *string `json:"mac_not,omitempty"`
MacIn []string `json:"mac_in,omitempty"`
MacNotIn []string `json:"mac_not_in,omitempty"`
MacLt *string `json:"mac_lt,omitempty"`
MacLte *string `json:"mac_lte,omitempty"`
MacGt *string `json:"mac_gt,omitempty"`
MacGte *string `json:"mac_gte,omitempty"`
MacContains *string `json:"mac_contains,omitempty"`
MacNotContains *string `json:"mac_not_contains,omitempty"`
MacStartsWith *string `json:"mac_starts_with,omitempty"`
MacNotStartsWith *string `json:"mac_not_starts_with,omitempty"`
MacEndsWith *string `json:"mac_ends_with,omitempty"`
MacNotEndsWith *string `json:"mac_not_ends_with,omitempty"`
DevType *string `json:"devType,omitempty"`
DevTypeNot *string `json:"devType_not,omitempty"`
DevTypeIn []string `json:"devType_in,omitempty"`
DevTypeNotIn []string `json:"devType_not_in,omitempty"`
DevTypeLt *string `json:"devType_lt,omitempty"`
DevTypeLte *string `json:"devType_lte,omitempty"`
DevTypeGt *string `json:"devType_gt,omitempty"`
DevTypeGte *string `json:"devType_gte,omitempty"`
DevTypeContains *string `json:"devType_contains,omitempty"`
DevTypeNotContains *string `json:"devType_not_contains,omitempty"`
DevTypeStartsWith *string `json:"devType_starts_with,omitempty"`
DevTypeNotStartsWith *string `json:"devType_not_starts_with,omitempty"`
DevTypeEndsWith *string `json:"devType_ends_with,omitempty"`
DevTypeNotEndsWith *string `json:"devType_not_ends_with,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
ProbeCountNot *int32 `json:"probeCount_not,omitempty"`
ProbeCountIn []int32 `json:"probeCount_in,omitempty"`
ProbeCountNotIn []int32 `json:"probeCount_not_in,omitempty"`
ProbeCountLt *int32 `json:"probeCount_lt,omitempty"`
ProbeCountLte *int32 `json:"probeCount_lte,omitempty"`
ProbeCountGt *int32 `json:"probeCount_gt,omitempty"`
ProbeCountGte *int32 `json:"probeCount_gte,omitempty"`
LastProbeTime *string `json:"lastProbeTime,omitempty"`
LastProbeTimeNot *string `json:"lastProbeTime_not,omitempty"`
LastProbeTimeIn []string `json:"lastProbeTime_in,omitempty"`
LastProbeTimeNotIn []string `json:"lastProbeTime_not_in,omitempty"`
LastProbeTimeLt *string `json:"lastProbeTime_lt,omitempty"`
LastProbeTimeLte *string `json:"lastProbeTime_lte,omitempty"`
LastProbeTimeGt *string `json:"lastProbeTime_gt,omitempty"`
LastProbeTimeGte *string `json:"lastProbeTime_gte,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
IfOnlineNot *int32 `json:"ifOnline_not,omitempty"`
IfOnlineIn []int32 `json:"ifOnline_in,omitempty"`
IfOnlineNotIn []int32 `json:"ifOnline_not_in,omitempty"`
IfOnlineLt *int32 `json:"ifOnline_lt,omitempty"`
IfOnlineLte *int32 `json:"ifOnline_lte,omitempty"`
IfOnlineGt *int32 `json:"ifOnline_gt,omitempty"`
IfOnlineGte *int32 `json:"ifOnline_gte,omitempty"`
And []MaCinfoScalarWhereInput `json:"AND,omitempty"`
Or []MaCinfoScalarWhereInput `json:"OR,omitempty"`
Not []MaCinfoScalarWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpdateInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeUpdateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoUpdateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
WifiProbers *WiFiProberinfoUpdateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type MaCinfoUpdateManyWithWhereNestedInput struct {
        Where MaCinfoScalarWhereInput `json:"where"`
Data MaCinfoUpdateManyDataInput `json:"data"`
          }

      type IDVerifyDeviceInfoUpdateManyMutationInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
          }

      type MaCinfoUpdateManyDataInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
          }

      type IDVerifyDeviceInfoCreateInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
LocationInfo *LocationInfoCreateOneWithoutIdVerifyDevicesInput `json:"locationInfo,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataCreateManyWithoutIdVerifyDeviceInput `json:"idCardVerifyDatas,omitempty"`
          }

      type PersonInfoUpsertWithoutIdCardVerifyDatasInput struct {
        Update PersonInfoUpdateWithoutIdCardVerifyDatasDataInput `json:"update"`
Create PersonInfoCreateWithoutIdCardVerifyDatasInput `json:"create"`
          }

      type AirHistoryDataCreateInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoCreateOneWithoutAirHistoryDatasInput `json:"cityInfo,omitempty"`
          }

      type IDCardVerifyDataUpdateInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
Person *PersonInfoUpdateOneWithoutIdCardVerifyDatasInput `json:"person,omitempty"`
IDVerifyDevice *IDVerifyDeviceInfoUpdateOneWithoutIdCardVerifyDatasInput `json:"idVerifyDevice,omitempty"`
          }

      type CityCodeInfoCreateWithoutAirHistoryDatasInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type IDCardVerifyDataScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevName *string `json:"devName,omitempty"`
DevNameNot *string `json:"devName_not,omitempty"`
DevNameIn []string `json:"devName_in,omitempty"`
DevNameNotIn []string `json:"devName_not_in,omitempty"`
DevNameLt *string `json:"devName_lt,omitempty"`
DevNameLte *string `json:"devName_lte,omitempty"`
DevNameGt *string `json:"devName_gt,omitempty"`
DevNameGte *string `json:"devName_gte,omitempty"`
DevNameContains *string `json:"devName_contains,omitempty"`
DevNameNotContains *string `json:"devName_not_contains,omitempty"`
DevNameStartsWith *string `json:"devName_starts_with,omitempty"`
DevNameNotStartsWith *string `json:"devName_not_starts_with,omitempty"`
DevNameEndsWith *string `json:"devName_ends_with,omitempty"`
DevNameNotEndsWith *string `json:"devName_not_ends_with,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
DevAddrNot *string `json:"devAddr_not,omitempty"`
DevAddrIn []string `json:"devAddr_in,omitempty"`
DevAddrNotIn []string `json:"devAddr_not_in,omitempty"`
DevAddrLt *string `json:"devAddr_lt,omitempty"`
DevAddrLte *string `json:"devAddr_lte,omitempty"`
DevAddrGt *string `json:"devAddr_gt,omitempty"`
DevAddrGte *string `json:"devAddr_gte,omitempty"`
DevAddrContains *string `json:"devAddr_contains,omitempty"`
DevAddrNotContains *string `json:"devAddr_not_contains,omitempty"`
DevAddrStartsWith *string `json:"devAddr_starts_with,omitempty"`
DevAddrNotStartsWith *string `json:"devAddr_not_starts_with,omitempty"`
DevAddrEndsWith *string `json:"devAddr_ends_with,omitempty"`
DevAddrNotEndsWith *string `json:"devAddr_not_ends_with,omitempty"`
IDCard *string `json:"idCard,omitempty"`
IDCardNot *string `json:"idCard_not,omitempty"`
IDCardIn []string `json:"idCard_in,omitempty"`
IDCardNotIn []string `json:"idCard_not_in,omitempty"`
IDCardLt *string `json:"idCard_lt,omitempty"`
IDCardLte *string `json:"idCard_lte,omitempty"`
IDCardGt *string `json:"idCard_gt,omitempty"`
IDCardGte *string `json:"idCard_gte,omitempty"`
IDCardContains *string `json:"idCard_contains,omitempty"`
IDCardNotContains *string `json:"idCard_not_contains,omitempty"`
IDCardStartsWith *string `json:"idCard_starts_with,omitempty"`
IDCardNotStartsWith *string `json:"idCard_not_starts_with,omitempty"`
IDCardEndsWith *string `json:"idCard_ends_with,omitempty"`
IDCardNotEndsWith *string `json:"idCard_not_ends_with,omitempty"`
PersonType *string `json:"personType,omitempty"`
PersonTypeNot *string `json:"personType_not,omitempty"`
PersonTypeIn []string `json:"personType_in,omitempty"`
PersonTypeNotIn []string `json:"personType_not_in,omitempty"`
PersonTypeLt *string `json:"personType_lt,omitempty"`
PersonTypeLte *string `json:"personType_lte,omitempty"`
PersonTypeGt *string `json:"personType_gt,omitempty"`
PersonTypeGte *string `json:"personType_gte,omitempty"`
PersonTypeContains *string `json:"personType_contains,omitempty"`
PersonTypeNotContains *string `json:"personType_not_contains,omitempty"`
PersonTypeStartsWith *string `json:"personType_starts_with,omitempty"`
PersonTypeNotStartsWith *string `json:"personType_not_starts_with,omitempty"`
PersonTypeEndsWith *string `json:"personType_ends_with,omitempty"`
PersonTypeNotEndsWith *string `json:"personType_not_ends_with,omitempty"`
Score *string `json:"score,omitempty"`
ScoreNot *string `json:"score_not,omitempty"`
ScoreIn []string `json:"score_in,omitempty"`
ScoreNotIn []string `json:"score_not_in,omitempty"`
ScoreLt *string `json:"score_lt,omitempty"`
ScoreLte *string `json:"score_lte,omitempty"`
ScoreGt *string `json:"score_gt,omitempty"`
ScoreGte *string `json:"score_gte,omitempty"`
ScoreContains *string `json:"score_contains,omitempty"`
ScoreNotContains *string `json:"score_not_contains,omitempty"`
ScoreStartsWith *string `json:"score_starts_with,omitempty"`
ScoreNotStartsWith *string `json:"score_not_starts_with,omitempty"`
ScoreEndsWith *string `json:"score_ends_with,omitempty"`
ScoreNotEndsWith *string `json:"score_not_ends_with,omitempty"`
Status *string `json:"status,omitempty"`
StatusNot *string `json:"status_not,omitempty"`
StatusIn []string `json:"status_in,omitempty"`
StatusNotIn []string `json:"status_not_in,omitempty"`
StatusLt *string `json:"status_lt,omitempty"`
StatusLte *string `json:"status_lte,omitempty"`
StatusGt *string `json:"status_gt,omitempty"`
StatusGte *string `json:"status_gte,omitempty"`
StatusContains *string `json:"status_contains,omitempty"`
StatusNotContains *string `json:"status_not_contains,omitempty"`
StatusStartsWith *string `json:"status_starts_with,omitempty"`
StatusNotStartsWith *string `json:"status_not_starts_with,omitempty"`
StatusEndsWith *string `json:"status_ends_with,omitempty"`
StatusNotEndsWith *string `json:"status_not_ends_with,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
FaceImgUriNot *string `json:"faceImgUri_not,omitempty"`
FaceImgUriIn []string `json:"faceImgUri_in,omitempty"`
FaceImgUriNotIn []string `json:"faceImgUri_not_in,omitempty"`
FaceImgUriLt *string `json:"faceImgUri_lt,omitempty"`
FaceImgUriLte *string `json:"faceImgUri_lte,omitempty"`
FaceImgUriGt *string `json:"faceImgUri_gt,omitempty"`
FaceImgUriGte *string `json:"faceImgUri_gte,omitempty"`
FaceImgUriContains *string `json:"faceImgUri_contains,omitempty"`
FaceImgUriNotContains *string `json:"faceImgUri_not_contains,omitempty"`
FaceImgUriStartsWith *string `json:"faceImgUri_starts_with,omitempty"`
FaceImgUriNotStartsWith *string `json:"faceImgUri_not_starts_with,omitempty"`
FaceImgUriEndsWith *string `json:"faceImgUri_ends_with,omitempty"`
FaceImgUriNotEndsWith *string `json:"faceImgUri_not_ends_with,omitempty"`
And []IDCardVerifyDataScalarWhereInput `json:"AND,omitempty"`
Or []IDCardVerifyDataScalarWhereInput `json:"OR,omitempty"`
Not []IDCardVerifyDataScalarWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoCreateInput struct {
        ID *string `json:"id,omitempty"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeCreateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoCreateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
WifiProbers *WiFiProberinfoCreateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type IDCardVerifyDataUpdateManyWithWhereNestedInput struct {
        Where IDCardVerifyDataScalarWhereInput `json:"where"`
Data IDCardVerifyDataUpdateManyDataInput `json:"data"`
          }

      type MonitorNodeCreateWithoutLocationInput struct {
        ID *string `json:"id,omitempty"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
RealTimeData *RealTimeDataCreateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
HistoryDatas *HistoryDataCreateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type IDCardVerifyDataUpdateManyDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
          }

      type RealTimeDataCreateWithoutMonitorNodeInput struct {
        ID *string `json:"id,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type IDVerifyDeviceInfoUpsertWithWhereUniqueWithoutLocationInfoInput struct {
        Where IDVerifyDeviceInfoWhereUniqueInput `json:"where"`
Update IDVerifyDeviceInfoUpdateWithoutLocationInfoDataInput `json:"update"`
Create IDVerifyDeviceInfoCreateWithoutLocationInfoInput `json:"create"`
          }

      type HistoryDataCreateWithoutMonitorNodeInput struct {
        ID *string `json:"id,omitempty"`
RcvTime string `json:"rcvTime"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type IDVerifyDeviceInfoScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevName *string `json:"devName,omitempty"`
DevNameNot *string `json:"devName_not,omitempty"`
DevNameIn []string `json:"devName_in,omitempty"`
DevNameNotIn []string `json:"devName_not_in,omitempty"`
DevNameLt *string `json:"devName_lt,omitempty"`
DevNameLte *string `json:"devName_lte,omitempty"`
DevNameGt *string `json:"devName_gt,omitempty"`
DevNameGte *string `json:"devName_gte,omitempty"`
DevNameContains *string `json:"devName_contains,omitempty"`
DevNameNotContains *string `json:"devName_not_contains,omitempty"`
DevNameStartsWith *string `json:"devName_starts_with,omitempty"`
DevNameNotStartsWith *string `json:"devName_not_starts_with,omitempty"`
DevNameEndsWith *string `json:"devName_ends_with,omitempty"`
DevNameNotEndsWith *string `json:"devName_not_ends_with,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
DevAddrNot *string `json:"devAddr_not,omitempty"`
DevAddrIn []string `json:"devAddr_in,omitempty"`
DevAddrNotIn []string `json:"devAddr_not_in,omitempty"`
DevAddrLt *string `json:"devAddr_lt,omitempty"`
DevAddrLte *string `json:"devAddr_lte,omitempty"`
DevAddrGt *string `json:"devAddr_gt,omitempty"`
DevAddrGte *string `json:"devAddr_gte,omitempty"`
DevAddrContains *string `json:"devAddr_contains,omitempty"`
DevAddrNotContains *string `json:"devAddr_not_contains,omitempty"`
DevAddrStartsWith *string `json:"devAddr_starts_with,omitempty"`
DevAddrNotStartsWith *string `json:"devAddr_not_starts_with,omitempty"`
DevAddrEndsWith *string `json:"devAddr_ends_with,omitempty"`
DevAddrNotEndsWith *string `json:"devAddr_not_ends_with,omitempty"`
And []IDVerifyDeviceInfoScalarWhereInput `json:"AND,omitempty"`
Or []IDVerifyDeviceInfoScalarWhereInput `json:"OR,omitempty"`
Not []IDVerifyDeviceInfoScalarWhereInput `json:"NOT,omitempty"`
          }

      type IDVerifyDeviceInfoCreateWithoutLocationInfoInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataCreateManyWithoutIdVerifyDeviceInput `json:"idCardVerifyDatas,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateManyWithWhereNestedInput struct {
        Where IDVerifyDeviceInfoScalarWhereInput `json:"where"`
Data IDVerifyDeviceInfoUpdateManyDataInput `json:"data"`
          }

      type IDCardVerifyDataCreateWithoutIdVerifyDeviceInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
Person *PersonInfoCreateOneWithoutIdCardVerifyDatasInput `json:"person,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateManyDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
          }

      type PersonInfoCreateWithoutIdCardVerifyDatasInput struct {
        ID *string `json:"id,omitempty"`
IDCard string `json:"idCard"`
CardType string `json:"cardType"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
Macinfos *MaCinfoCreateManyWithoutPersonInput `json:"macinfos,omitempty"`
          }

      type WiFiProberinfoUpdateManyWithoutLocationInfoInput struct {
        Create []WiFiProberinfoCreateWithoutLocationInfoInput `json:"create,omitempty"`
Delete []WiFiProberinfoWhereUniqueInput `json:"delete,omitempty"`
Connect []WiFiProberinfoWhereUniqueInput `json:"connect,omitempty"`
Set []WiFiProberinfoWhereUniqueInput `json:"set,omitempty"`
Disconnect []WiFiProberinfoWhereUniqueInput `json:"disconnect,omitempty"`
Update []WiFiProberinfoUpdateWithWhereUniqueWithoutLocationInfoInput `json:"update,omitempty"`
Upsert []WiFiProberinfoUpsertWithWhereUniqueWithoutLocationInfoInput `json:"upsert,omitempty"`
DeleteMany []WiFiProberinfoScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []WiFiProberinfoUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type MaCinfoCreateWithoutPersonInput struct {
        ID *string `json:"id,omitempty"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataCreateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
AttendanceRecords *AttendanceRecordCreateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type WiFiProberinfoUpdateWithWhereUniqueWithoutLocationInfoInput struct {
        Where WiFiProberinfoWhereUniqueInput `json:"where"`
Data WiFiProberinfoUpdateWithoutLocationInfoDataInput `json:"data"`
          }

      type MacProbeDataCreateWithoutMacInput struct {
        ID *string `json:"id,omitempty"`
ProbeTime string `json:"probeTime"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
WifiProber *WiFiProberinfoCreateOneWithoutMacProbeDatasInput `json:"wifiProber,omitempty"`
          }

      type WiFiProberinfoUpdateWithoutLocationInfoDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
MacProbeDatas *MacProbeDataUpdateManyWithoutWifiProberInput `json:"macProbeDatas,omitempty"`
          }

      type WiFiProberinfoCreateWithoutMacProbeDatasInput struct {
        ID *string `json:"id,omitempty"`
DevNo string `json:"devNo"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
LocationInfo *LocationInfoCreateOneWithoutWifiProbersInput `json:"locationInfo,omitempty"`
          }

      type MacProbeDataUpdateManyWithoutWifiProberInput struct {
        Create []MacProbeDataCreateWithoutWifiProberInput `json:"create,omitempty"`
Delete []MacProbeDataWhereUniqueInput `json:"delete,omitempty"`
Connect []MacProbeDataWhereUniqueInput `json:"connect,omitempty"`
Set []MacProbeDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []MacProbeDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []MacProbeDataUpdateWithWhereUniqueWithoutWifiProberInput `json:"update,omitempty"`
Upsert []MacProbeDataUpsertWithWhereUniqueWithoutWifiProberInput `json:"upsert,omitempty"`
DeleteMany []MacProbeDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []MacProbeDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type LocationInfoCreateWithoutWifiProbersInput struct {
        ID *string `json:"id,omitempty"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeCreateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoCreateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
          }

      type MacProbeDataUpdateWithWhereUniqueWithoutWifiProberInput struct {
        Where MacProbeDataWhereUniqueInput `json:"where"`
Data MacProbeDataUpdateWithoutWifiProberDataInput `json:"data"`
          }

      type AttendanceRecordCreateWithoutMacInput struct {
        ID *string `json:"id,omitempty"`
AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type MacProbeDataUpdateWithoutWifiProberDataInput struct {
        ProbeTime *string `json:"probeTime,omitempty"`
Mac *MaCinfoUpdateOneWithoutMacProbeDatasInput `json:"mac,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
          }

      type WiFiProberinfoCreateWithoutLocationInfoInput struct {
        ID *string `json:"id,omitempty"`
DevNo string `json:"devNo"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
MacProbeDatas *MacProbeDataCreateManyWithoutWifiProberInput `json:"macProbeDatas,omitempty"`
          }

      type MaCinfoUpdateOneWithoutMacProbeDatasInput struct {
        Create *MaCinfoCreateWithoutMacProbeDatasInput `json:"create,omitempty"`
Update *MaCinfoUpdateWithoutMacProbeDatasDataInput `json:"update,omitempty"`
Upsert *MaCinfoUpsertWithoutMacProbeDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *MaCinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MacProbeDataCreateWithoutWifiProberInput struct {
        ID *string `json:"id,omitempty"`
ProbeTime string `json:"probeTime"`
Mac *MaCinfoCreateOneWithoutMacProbeDatasInput `json:"mac,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
          }

      type MaCinfoUpdateWithoutMacProbeDatasDataInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoUpdateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
AttendanceRecords *AttendanceRecordUpdateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type MaCinfoCreateWithoutMacProbeDatasInput struct {
        ID *string `json:"id,omitempty"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoCreateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
AttendanceRecords *AttendanceRecordCreateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type PersonInfoUpdateOneWithoutMacinfosInput struct {
        Create *PersonInfoCreateWithoutMacinfosInput `json:"create,omitempty"`
Update *PersonInfoUpdateWithoutMacinfosDataInput `json:"update,omitempty"`
Upsert *PersonInfoUpsertWithoutMacinfosInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *PersonInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type PersonInfoCreateWithoutMacinfosInput struct {
        ID *string `json:"id,omitempty"`
IDCard string `json:"idCard"`
CardType string `json:"cardType"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataCreateManyWithoutPersonInput `json:"idCardVerifyDatas,omitempty"`
          }

      type PersonInfoUpdateWithoutMacinfosDataInput struct {
        IDCard *string `json:"idCard,omitempty"`
CardType *string `json:"cardType,omitempty"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataUpdateManyWithoutPersonInput `json:"idCardVerifyDatas,omitempty"`
          }

      type IDCardVerifyDataCreateWithoutPersonInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
IDVerifyDevice *IDVerifyDeviceInfoCreateOneWithoutIdCardVerifyDatasInput `json:"idVerifyDevice,omitempty"`
          }

      type IDCardVerifyDataUpdateManyWithoutPersonInput struct {
        Create []IDCardVerifyDataCreateWithoutPersonInput `json:"create,omitempty"`
Delete []IDCardVerifyDataWhereUniqueInput `json:"delete,omitempty"`
Connect []IDCardVerifyDataWhereUniqueInput `json:"connect,omitempty"`
Set []IDCardVerifyDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []IDCardVerifyDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []IDCardVerifyDataUpdateWithWhereUniqueWithoutPersonInput `json:"update,omitempty"`
Upsert []IDCardVerifyDataUpsertWithWhereUniqueWithoutPersonInput `json:"upsert,omitempty"`
DeleteMany []IDCardVerifyDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []IDCardVerifyDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type IDVerifyDeviceInfoCreateWithoutIdCardVerifyDatasInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
LocationInfo *LocationInfoCreateOneWithoutIdVerifyDevicesInput `json:"locationInfo,omitempty"`
          }

      type IDCardVerifyDataUpdateWithWhereUniqueWithoutPersonInput struct {
        Where IDCardVerifyDataWhereUniqueInput `json:"where"`
Data IDCardVerifyDataUpdateWithoutPersonDataInput `json:"data"`
          }

      type LocationInfoCreateWithoutIdVerifyDevicesInput struct {
        ID *string `json:"id,omitempty"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeCreateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
WifiProbers *WiFiProberinfoCreateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type IDCardVerifyDataUpdateWithoutPersonDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
IDVerifyDevice *IDVerifyDeviceInfoUpdateOneWithoutIdCardVerifyDatasInput `json:"idVerifyDevice,omitempty"`
          }

      type AirLiveCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateOneWithoutIdCardVerifyDatasInput struct {
        Create *IDVerifyDeviceInfoCreateWithoutIdCardVerifyDatasInput `json:"create,omitempty"`
Update *IDVerifyDeviceInfoUpdateWithoutIdCardVerifyDatasDataInput `json:"update,omitempty"`
Upsert *IDVerifyDeviceInfoUpsertWithoutIdCardVerifyDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *IDVerifyDeviceInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherLiveCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type IDVerifyDeviceInfoUpdateWithoutIdCardVerifyDatasDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
LocationInfo *LocationInfoUpdateOneWithoutIdVerifyDevicesInput `json:"locationInfo,omitempty"`
          }

      type HistoryDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
MonitorNode *MonitorNodeWhereInput `json:"monitorNode,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
RcvTimeNot *string `json:"rcvTime_not,omitempty"`
RcvTimeIn []string `json:"rcvTime_in,omitempty"`
RcvTimeNotIn []string `json:"rcvTime_not_in,omitempty"`
RcvTimeLt *string `json:"rcvTime_lt,omitempty"`
RcvTimeLte *string `json:"rcvTime_lte,omitempty"`
RcvTimeGt *string `json:"rcvTime_gt,omitempty"`
RcvTimeGte *string `json:"rcvTime_gte,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindSpeedNot *float64 `json:"windSpeed_not,omitempty"`
WindSpeedIn []float64 `json:"windSpeed_in,omitempty"`
WindSpeedNotIn []float64 `json:"windSpeed_not_in,omitempty"`
WindSpeedLt *float64 `json:"windSpeed_lt,omitempty"`
WindSpeedLte *float64 `json:"windSpeed_lte,omitempty"`
WindSpeedGt *float64 `json:"windSpeed_gt,omitempty"`
WindSpeedGte *float64 `json:"windSpeed_gte,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
WindDirectionNot *string `json:"windDirection_not,omitempty"`
WindDirectionIn []string `json:"windDirection_in,omitempty"`
WindDirectionNotIn []string `json:"windDirection_not_in,omitempty"`
WindDirectionLt *string `json:"windDirection_lt,omitempty"`
WindDirectionLte *string `json:"windDirection_lte,omitempty"`
WindDirectionGt *string `json:"windDirection_gt,omitempty"`
WindDirectionGte *string `json:"windDirection_gte,omitempty"`
WindDirectionContains *string `json:"windDirection_contains,omitempty"`
WindDirectionNotContains *string `json:"windDirection_not_contains,omitempty"`
WindDirectionStartsWith *string `json:"windDirection_starts_with,omitempty"`
WindDirectionNotStartsWith *string `json:"windDirection_not_starts_with,omitempty"`
WindDirectionEndsWith *string `json:"windDirection_ends_with,omitempty"`
WindDirectionNotEndsWith *string `json:"windDirection_not_ends_with,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
TemperatureNot *float64 `json:"temperature_not,omitempty"`
TemperatureIn []float64 `json:"temperature_in,omitempty"`
TemperatureNotIn []float64 `json:"temperature_not_in,omitempty"`
TemperatureLt *float64 `json:"temperature_lt,omitempty"`
TemperatureLte *float64 `json:"temperature_lte,omitempty"`
TemperatureGt *float64 `json:"temperature_gt,omitempty"`
TemperatureGte *float64 `json:"temperature_gte,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
HumidityNot *float64 `json:"humidity_not,omitempty"`
HumidityIn []float64 `json:"humidity_in,omitempty"`
HumidityNotIn []float64 `json:"humidity_not_in,omitempty"`
HumidityLt *float64 `json:"humidity_lt,omitempty"`
HumidityLte *float64 `json:"humidity_lte,omitempty"`
HumidityGt *float64 `json:"humidity_gt,omitempty"`
HumidityGte *float64 `json:"humidity_gte,omitempty"`
Noise *float64 `json:"noise,omitempty"`
NoiseNot *float64 `json:"noise_not,omitempty"`
NoiseIn []float64 `json:"noise_in,omitempty"`
NoiseNotIn []float64 `json:"noise_not_in,omitempty"`
NoiseLt *float64 `json:"noise_lt,omitempty"`
NoiseLte *float64 `json:"noise_lte,omitempty"`
NoiseGt *float64 `json:"noise_gt,omitempty"`
NoiseGte *float64 `json:"noise_gte,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm2Not *float64 `json:"pm2_not,omitempty"`
Pm2In []float64 `json:"pm2_in,omitempty"`
Pm2NotIn []float64 `json:"pm2_not_in,omitempty"`
Pm2Lt *float64 `json:"pm2_lt,omitempty"`
Pm2Lte *float64 `json:"pm2_lte,omitempty"`
Pm2Gt *float64 `json:"pm2_gt,omitempty"`
Pm2Gte *float64 `json:"pm2_gte,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Pm10Not *float64 `json:"pm10_not,omitempty"`
Pm10In []float64 `json:"pm10_in,omitempty"`
Pm10NotIn []float64 `json:"pm10_not_in,omitempty"`
Pm10Lt *float64 `json:"pm10_lt,omitempty"`
Pm10Lte *float64 `json:"pm10_lte,omitempty"`
Pm10Gt *float64 `json:"pm10_gt,omitempty"`
Pm10Gte *float64 `json:"pm10_gte,omitempty"`
Co *float64 `json:"co,omitempty"`
CoNot *float64 `json:"co_not,omitempty"`
CoIn []float64 `json:"co_in,omitempty"`
CoNotIn []float64 `json:"co_not_in,omitempty"`
CoLt *float64 `json:"co_lt,omitempty"`
CoLte *float64 `json:"co_lte,omitempty"`
CoGt *float64 `json:"co_gt,omitempty"`
CoGte *float64 `json:"co_gte,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
Co2Not *float64 `json:"co2_not,omitempty"`
Co2In []float64 `json:"co2_in,omitempty"`
Co2NotIn []float64 `json:"co2_not_in,omitempty"`
Co2Lt *float64 `json:"co2_lt,omitempty"`
Co2Lte *float64 `json:"co2_lte,omitempty"`
Co2Gt *float64 `json:"co2_gt,omitempty"`
Co2Gte *float64 `json:"co2_gte,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
AirPressureNot *float64 `json:"airPressure_not,omitempty"`
AirPressureIn []float64 `json:"airPressure_in,omitempty"`
AirPressureNotIn []float64 `json:"airPressure_not_in,omitempty"`
AirPressureLt *float64 `json:"airPressure_lt,omitempty"`
AirPressureLte *float64 `json:"airPressure_lte,omitempty"`
AirPressureGt *float64 `json:"airPressure_gt,omitempty"`
AirPressureGte *float64 `json:"airPressure_gte,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
SunLightNot *float64 `json:"sunLight_not,omitempty"`
SunLightIn []float64 `json:"sunLight_in,omitempty"`
SunLightNotIn []float64 `json:"sunLight_not_in,omitempty"`
SunLightLt *float64 `json:"sunLight_lt,omitempty"`
SunLightLte *float64 `json:"sunLight_lte,omitempty"`
SunLightGt *float64 `json:"sunLight_gt,omitempty"`
SunLightGte *float64 `json:"sunLight_gte,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
And []HistoryDataWhereInput `json:"AND,omitempty"`
Or []HistoryDataWhereInput `json:"OR,omitempty"`
Not []HistoryDataWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpdateOneWithoutIdVerifyDevicesInput struct {
        Create *LocationInfoCreateWithoutIdVerifyDevicesInput `json:"create,omitempty"`
Update *LocationInfoUpdateWithoutIdVerifyDevicesDataInput `json:"update,omitempty"`
Upsert *LocationInfoUpsertWithoutIdVerifyDevicesInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherAirHistorySubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *WeatherAirHistoryWhereInput `json:"node,omitempty"`
And []WeatherAirHistorySubscriptionWhereInput `json:"AND,omitempty"`
Or []WeatherAirHistorySubscriptionWhereInput `json:"OR,omitempty"`
Not []WeatherAirHistorySubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpdateWithoutIdVerifyDevicesDataInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
MonitorNodes *MonitorNodeUpdateManyWithoutLocationInput `json:"monitorNodes,omitempty"`
WifiProbers *WiFiProberinfoUpdateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type WiFiProberinfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMacNot *string `json:"devMac_not,omitempty"`
DevMacIn []string `json:"devMac_in,omitempty"`
DevMacNotIn []string `json:"devMac_not_in,omitempty"`
DevMacLt *string `json:"devMac_lt,omitempty"`
DevMacLte *string `json:"devMac_lte,omitempty"`
DevMacGt *string `json:"devMac_gt,omitempty"`
DevMacGte *string `json:"devMac_gte,omitempty"`
DevMacContains *string `json:"devMac_contains,omitempty"`
DevMacNotContains *string `json:"devMac_not_contains,omitempty"`
DevMacStartsWith *string `json:"devMac_starts_with,omitempty"`
DevMacNotStartsWith *string `json:"devMac_not_starts_with,omitempty"`
DevMacEndsWith *string `json:"devMac_ends_with,omitempty"`
DevMacNotEndsWith *string `json:"devMac_not_ends_with,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
DevMdoelNot *string `json:"devMdoel_not,omitempty"`
DevMdoelIn []string `json:"devMdoel_in,omitempty"`
DevMdoelNotIn []string `json:"devMdoel_not_in,omitempty"`
DevMdoelLt *string `json:"devMdoel_lt,omitempty"`
DevMdoelLte *string `json:"devMdoel_lte,omitempty"`
DevMdoelGt *string `json:"devMdoel_gt,omitempty"`
DevMdoelGte *string `json:"devMdoel_gte,omitempty"`
DevMdoelContains *string `json:"devMdoel_contains,omitempty"`
DevMdoelNotContains *string `json:"devMdoel_not_contains,omitempty"`
DevMdoelStartsWith *string `json:"devMdoel_starts_with,omitempty"`
DevMdoelNotStartsWith *string `json:"devMdoel_not_starts_with,omitempty"`
DevMdoelEndsWith *string `json:"devMdoel_ends_with,omitempty"`
DevMdoelNotEndsWith *string `json:"devMdoel_not_ends_with,omitempty"`
LocationInfo *LocationInfoWhereInput `json:"locationInfo,omitempty"`
MacProbeDatasEvery *MacProbeDataWhereInput `json:"macProbeDatas_every,omitempty"`
MacProbeDatasSome *MacProbeDataWhereInput `json:"macProbeDatas_some,omitempty"`
MacProbeDatasNone *MacProbeDataWhereInput `json:"macProbeDatas_none,omitempty"`
And []WiFiProberinfoWhereInput `json:"AND,omitempty"`
Or []WiFiProberinfoWhereInput `json:"OR,omitempty"`
Not []WiFiProberinfoWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpsertWithoutIdVerifyDevicesInput struct {
        Update LocationInfoUpdateWithoutIdVerifyDevicesDataInput `json:"update"`
Create LocationInfoCreateWithoutIdVerifyDevicesInput `json:"create"`
          }

      type MacProbeRecordSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *MacProbeRecordWhereInput `json:"node,omitempty"`
And []MacProbeRecordSubscriptionWhereInput `json:"AND,omitempty"`
Or []MacProbeRecordSubscriptionWhereInput `json:"OR,omitempty"`
Not []MacProbeRecordSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type IDVerifyDeviceInfoUpsertWithoutIdCardVerifyDatasInput struct {
        Update IDVerifyDeviceInfoUpdateWithoutIdCardVerifyDatasDataInput `json:"update"`
Create IDVerifyDeviceInfoCreateWithoutIdCardVerifyDatasInput `json:"create"`
          }

      type AirLiveWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Time *string `json:"time,omitempty"`
TimeNot *string `json:"time_not,omitempty"`
TimeIn []string `json:"time_in,omitempty"`
TimeNotIn []string `json:"time_not_in,omitempty"`
TimeLt *string `json:"time_lt,omitempty"`
TimeLte *string `json:"time_lte,omitempty"`
TimeGt *string `json:"time_gt,omitempty"`
TimeGte *string `json:"time_gte,omitempty"`
TimeContains *string `json:"time_contains,omitempty"`
TimeNotContains *string `json:"time_not_contains,omitempty"`
TimeStartsWith *string `json:"time_starts_with,omitempty"`
TimeNotStartsWith *string `json:"time_not_starts_with,omitempty"`
TimeEndsWith *string `json:"time_ends_with,omitempty"`
TimeNotEndsWith *string `json:"time_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"o3,omitempty"`
O3Not *string `json:"o3_not,omitempty"`
O3In []string `json:"o3_in,omitempty"`
O3NotIn []string `json:"o3_not_in,omitempty"`
O3Lt *string `json:"o3_lt,omitempty"`
O3Lte *string `json:"o3_lte,omitempty"`
O3Gt *string `json:"o3_gt,omitempty"`
O3Gte *string `json:"o3_gte,omitempty"`
O3Contains *string `json:"o3_contains,omitempty"`
O3NotContains *string `json:"o3_not_contains,omitempty"`
O3StartsWith *string `json:"o3_starts_with,omitempty"`
O3NotStartsWith *string `json:"o3_not_starts_with,omitempty"`
O3EndsWith *string `json:"o3_ends_with,omitempty"`
O3NotEndsWith *string `json:"o3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"primary,omitempty"`
PrimaryNot *string `json:"primary_not,omitempty"`
PrimaryIn []string `json:"primary_in,omitempty"`
PrimaryNotIn []string `json:"primary_not_in,omitempty"`
PrimaryLt *string `json:"primary_lt,omitempty"`
PrimaryLte *string `json:"primary_lte,omitempty"`
PrimaryGt *string `json:"primary_gt,omitempty"`
PrimaryGte *string `json:"primary_gte,omitempty"`
PrimaryContains *string `json:"primary_contains,omitempty"`
PrimaryNotContains *string `json:"primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"primary_not_ends_with,omitempty"`
Rcode *string `json:"rcode,omitempty"`
RcodeNot *string `json:"rcode_not,omitempty"`
RcodeIn []string `json:"rcode_in,omitempty"`
RcodeNotIn []string `json:"rcode_not_in,omitempty"`
RcodeLt *string `json:"rcode_lt,omitempty"`
RcodeLte *string `json:"rcode_lte,omitempty"`
RcodeGt *string `json:"rcode_gt,omitempty"`
RcodeGte *string `json:"rcode_gte,omitempty"`
RcodeContains *string `json:"rcode_contains,omitempty"`
RcodeNotContains *string `json:"rcode_not_contains,omitempty"`
RcodeStartsWith *string `json:"rcode_starts_with,omitempty"`
RcodeNotStartsWith *string `json:"rcode_not_starts_with,omitempty"`
RcodeEndsWith *string `json:"rcode_ends_with,omitempty"`
RcodeNotEndsWith *string `json:"rcode_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
And []AirLiveWhereInput `json:"AND,omitempty"`
Or []AirLiveWhereInput `json:"OR,omitempty"`
Not []AirLiveWhereInput `json:"NOT,omitempty"`
          }

      type IDCardVerifyDataUpsertWithWhereUniqueWithoutPersonInput struct {
        Where IDCardVerifyDataWhereUniqueInput `json:"where"`
Update IDCardVerifyDataUpdateWithoutPersonDataInput `json:"update"`
Create IDCardVerifyDataCreateWithoutPersonInput `json:"create"`
          }

      type WeatherHistoryDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
WindspeedNot *string `json:"windspeed_not,omitempty"`
WindspeedIn []string `json:"windspeed_in,omitempty"`
WindspeedNotIn []string `json:"windspeed_not_in,omitempty"`
WindspeedLt *string `json:"windspeed_lt,omitempty"`
WindspeedLte *string `json:"windspeed_lte,omitempty"`
WindspeedGt *string `json:"windspeed_gt,omitempty"`
WindspeedGte *string `json:"windspeed_gte,omitempty"`
WindspeedContains *string `json:"windspeed_contains,omitempty"`
WindspeedNotContains *string `json:"windspeed_not_contains,omitempty"`
WindspeedStartsWith *string `json:"windspeed_starts_with,omitempty"`
WindspeedNotStartsWith *string `json:"windspeed_not_starts_with,omitempty"`
WindspeedEndsWith *string `json:"windspeed_ends_with,omitempty"`
WindspeedNotEndsWith *string `json:"windspeed_not_ends_with,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
AirpressureNot *string `json:"airpressure_not,omitempty"`
AirpressureIn []string `json:"airpressure_in,omitempty"`
AirpressureNotIn []string `json:"airpressure_not_in,omitempty"`
AirpressureLt *string `json:"airpressure_lt,omitempty"`
AirpressureLte *string `json:"airpressure_lte,omitempty"`
AirpressureGt *string `json:"airpressure_gt,omitempty"`
AirpressureGte *string `json:"airpressure_gte,omitempty"`
AirpressureContains *string `json:"airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
PhenomenaNot *string `json:"phenomena_not,omitempty"`
PhenomenaIn []string `json:"phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"phenomena_lt,omitempty"`
PhenomenaLte *string `json:"phenomena_lte,omitempty"`
PhenomenaGt *string `json:"phenomena_gt,omitempty"`
PhenomenaGte *string `json:"phenomena_gte,omitempty"`
PhenomenaContains *string `json:"phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Humidity *string `json:"humidity,omitempty"`
HumidityNot *string `json:"humidity_not,omitempty"`
HumidityIn []string `json:"humidity_in,omitempty"`
HumidityNotIn []string `json:"humidity_not_in,omitempty"`
HumidityLt *string `json:"humidity_lt,omitempty"`
HumidityLte *string `json:"humidity_lte,omitempty"`
HumidityGt *string `json:"humidity_gt,omitempty"`
HumidityGte *string `json:"humidity_gte,omitempty"`
HumidityContains *string `json:"humidity_contains,omitempty"`
HumidityNotContains *string `json:"humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"humidity_not_ends_with,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
UpdatetimeNot *string `json:"updatetime_not,omitempty"`
UpdatetimeIn []string `json:"updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"updatetime_not_ends_with,omitempty"`
Windpower *string `json:"windpower,omitempty"`
WindpowerNot *string `json:"windpower_not,omitempty"`
WindpowerIn []string `json:"windpower_in,omitempty"`
WindpowerNotIn []string `json:"windpower_not_in,omitempty"`
WindpowerLt *string `json:"windpower_lt,omitempty"`
WindpowerLte *string `json:"windpower_lte,omitempty"`
WindpowerGt *string `json:"windpower_gt,omitempty"`
WindpowerGte *string `json:"windpower_gte,omitempty"`
WindpowerContains *string `json:"windpower_contains,omitempty"`
WindpowerNotContains *string `json:"windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"windpower_not_ends_with,omitempty"`
Feelst *string `json:"feelst,omitempty"`
FeelstNot *string `json:"feelst_not,omitempty"`
FeelstIn []string `json:"feelst_in,omitempty"`
FeelstNotIn []string `json:"feelst_not_in,omitempty"`
FeelstLt *string `json:"feelst_lt,omitempty"`
FeelstLte *string `json:"feelst_lte,omitempty"`
FeelstGt *string `json:"feelst_gt,omitempty"`
FeelstGte *string `json:"feelst_gte,omitempty"`
FeelstContains *string `json:"feelst_contains,omitempty"`
FeelstNotContains *string `json:"feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"feelst_not_ends_with,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
WinddirectNot *string `json:"winddirect_not,omitempty"`
WinddirectIn []string `json:"winddirect_in,omitempty"`
WinddirectNotIn []string `json:"winddirect_not_in,omitempty"`
WinddirectLt *string `json:"winddirect_lt,omitempty"`
WinddirectLte *string `json:"winddirect_lte,omitempty"`
WinddirectGt *string `json:"winddirect_gt,omitempty"`
WinddirectGte *string `json:"winddirect_gte,omitempty"`
WinddirectContains *string `json:"winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"winddirect_not_ends_with,omitempty"`
Rcode *string `json:"rcode,omitempty"`
RcodeNot *string `json:"rcode_not,omitempty"`
RcodeIn []string `json:"rcode_in,omitempty"`
RcodeNotIn []string `json:"rcode_not_in,omitempty"`
RcodeLt *string `json:"rcode_lt,omitempty"`
RcodeLte *string `json:"rcode_lte,omitempty"`
RcodeGt *string `json:"rcode_gt,omitempty"`
RcodeGte *string `json:"rcode_gte,omitempty"`
RcodeContains *string `json:"rcode_contains,omitempty"`
RcodeNotContains *string `json:"rcode_not_contains,omitempty"`
RcodeStartsWith *string `json:"rcode_starts_with,omitempty"`
RcodeNotStartsWith *string `json:"rcode_not_starts_with,omitempty"`
RcodeEndsWith *string `json:"rcode_ends_with,omitempty"`
RcodeNotEndsWith *string `json:"rcode_not_ends_with,omitempty"`
Rain *string `json:"rain,omitempty"`
RainNot *string `json:"rain_not,omitempty"`
RainIn []string `json:"rain_in,omitempty"`
RainNotIn []string `json:"rain_not_in,omitempty"`
RainLt *string `json:"rain_lt,omitempty"`
RainLte *string `json:"rain_lte,omitempty"`
RainGt *string `json:"rain_gt,omitempty"`
RainGte *string `json:"rain_gte,omitempty"`
RainContains *string `json:"rain_contains,omitempty"`
RainNotContains *string `json:"rain_not_contains,omitempty"`
RainStartsWith *string `json:"rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"rain_not_ends_with,omitempty"`
Temperature *string `json:"temperature,omitempty"`
TemperatureNot *string `json:"temperature_not,omitempty"`
TemperatureIn []string `json:"temperature_in,omitempty"`
TemperatureNotIn []string `json:"temperature_not_in,omitempty"`
TemperatureLt *string `json:"temperature_lt,omitempty"`
TemperatureLte *string `json:"temperature_lte,omitempty"`
TemperatureGt *string `json:"temperature_gt,omitempty"`
TemperatureGte *string `json:"temperature_gte,omitempty"`
TemperatureContains *string `json:"temperature_contains,omitempty"`
TemperatureNotContains *string `json:"temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"temperature_not_ends_with,omitempty"`
And []WeatherHistoryDataWhereInput `json:"AND,omitempty"`
Or []WeatherHistoryDataWhereInput `json:"OR,omitempty"`
Not []WeatherHistoryDataWhereInput `json:"NOT,omitempty"`
          }

      type PersonInfoUpsertWithoutMacinfosInput struct {
        Update PersonInfoUpdateWithoutMacinfosDataInput `json:"update"`
Create PersonInfoCreateWithoutMacinfosInput `json:"create"`
          }

      type PersonInfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
IDCard *string `json:"idCard,omitempty"`
IDCardNot *string `json:"idCard_not,omitempty"`
IDCardIn []string `json:"idCard_in,omitempty"`
IDCardNotIn []string `json:"idCard_not_in,omitempty"`
IDCardLt *string `json:"idCard_lt,omitempty"`
IDCardLte *string `json:"idCard_lte,omitempty"`
IDCardGt *string `json:"idCard_gt,omitempty"`
IDCardGte *string `json:"idCard_gte,omitempty"`
IDCardContains *string `json:"idCard_contains,omitempty"`
IDCardNotContains *string `json:"idCard_not_contains,omitempty"`
IDCardStartsWith *string `json:"idCard_starts_with,omitempty"`
IDCardNotStartsWith *string `json:"idCard_not_starts_with,omitempty"`
IDCardEndsWith *string `json:"idCard_ends_with,omitempty"`
IDCardNotEndsWith *string `json:"idCard_not_ends_with,omitempty"`
CardType *string `json:"cardType,omitempty"`
CardTypeNot *string `json:"cardType_not,omitempty"`
CardTypeIn []string `json:"cardType_in,omitempty"`
CardTypeNotIn []string `json:"cardType_not_in,omitempty"`
CardTypeLt *string `json:"cardType_lt,omitempty"`
CardTypeLte *string `json:"cardType_lte,omitempty"`
CardTypeGt *string `json:"cardType_gt,omitempty"`
CardTypeGte *string `json:"cardType_gte,omitempty"`
CardTypeContains *string `json:"cardType_contains,omitempty"`
CardTypeNotContains *string `json:"cardType_not_contains,omitempty"`
CardTypeStartsWith *string `json:"cardType_starts_with,omitempty"`
CardTypeNotStartsWith *string `json:"cardType_not_starts_with,omitempty"`
CardTypeEndsWith *string `json:"cardType_ends_with,omitempty"`
CardTypeNotEndsWith *string `json:"cardType_not_ends_with,omitempty"`
Validity *string `json:"validity,omitempty"`
ValidityNot *string `json:"validity_not,omitempty"`
ValidityIn []string `json:"validity_in,omitempty"`
ValidityNotIn []string `json:"validity_not_in,omitempty"`
ValidityLt *string `json:"validity_lt,omitempty"`
ValidityLte *string `json:"validity_lte,omitempty"`
ValidityGt *string `json:"validity_gt,omitempty"`
ValidityGte *string `json:"validity_gte,omitempty"`
ValidityContains *string `json:"validity_contains,omitempty"`
ValidityNotContains *string `json:"validity_not_contains,omitempty"`
ValidityStartsWith *string `json:"validity_starts_with,omitempty"`
ValidityNotStartsWith *string `json:"validity_not_starts_with,omitempty"`
ValidityEndsWith *string `json:"validity_ends_with,omitempty"`
ValidityNotEndsWith *string `json:"validity_not_ends_with,omitempty"`
Birthday *string `json:"birthday,omitempty"`
BirthdayNot *string `json:"birthday_not,omitempty"`
BirthdayIn []string `json:"birthday_in,omitempty"`
BirthdayNotIn []string `json:"birthday_not_in,omitempty"`
BirthdayLt *string `json:"birthday_lt,omitempty"`
BirthdayLte *string `json:"birthday_lte,omitempty"`
BirthdayGt *string `json:"birthday_gt,omitempty"`
BirthdayGte *string `json:"birthday_gte,omitempty"`
BirthdayContains *string `json:"birthday_contains,omitempty"`
BirthdayNotContains *string `json:"birthday_not_contains,omitempty"`
BirthdayStartsWith *string `json:"birthday_starts_with,omitempty"`
BirthdayNotStartsWith *string `json:"birthday_not_starts_with,omitempty"`
BirthdayEndsWith *string `json:"birthday_ends_with,omitempty"`
BirthdayNotEndsWith *string `json:"birthday_not_ends_with,omitempty"`
PersonName *string `json:"personName,omitempty"`
PersonNameNot *string `json:"personName_not,omitempty"`
PersonNameIn []string `json:"personName_in,omitempty"`
PersonNameNotIn []string `json:"personName_not_in,omitempty"`
PersonNameLt *string `json:"personName_lt,omitempty"`
PersonNameLte *string `json:"personName_lte,omitempty"`
PersonNameGt *string `json:"personName_gt,omitempty"`
PersonNameGte *string `json:"personName_gte,omitempty"`
PersonNameContains *string `json:"personName_contains,omitempty"`
PersonNameNotContains *string `json:"personName_not_contains,omitempty"`
PersonNameStartsWith *string `json:"personName_starts_with,omitempty"`
PersonNameNotStartsWith *string `json:"personName_not_starts_with,omitempty"`
PersonNameEndsWith *string `json:"personName_ends_with,omitempty"`
PersonNameNotEndsWith *string `json:"personName_not_ends_with,omitempty"`
Address *string `json:"address,omitempty"`
AddressNot *string `json:"address_not,omitempty"`
AddressIn []string `json:"address_in,omitempty"`
AddressNotIn []string `json:"address_not_in,omitempty"`
AddressLt *string `json:"address_lt,omitempty"`
AddressLte *string `json:"address_lte,omitempty"`
AddressGt *string `json:"address_gt,omitempty"`
AddressGte *string `json:"address_gte,omitempty"`
AddressContains *string `json:"address_contains,omitempty"`
AddressNotContains *string `json:"address_not_contains,omitempty"`
AddressStartsWith *string `json:"address_starts_with,omitempty"`
AddressNotStartsWith *string `json:"address_not_starts_with,omitempty"`
AddressEndsWith *string `json:"address_ends_with,omitempty"`
AddressNotEndsWith *string `json:"address_not_ends_with,omitempty"`
Nation *string `json:"nation,omitempty"`
NationNot *string `json:"nation_not,omitempty"`
NationIn []string `json:"nation_in,omitempty"`
NationNotIn []string `json:"nation_not_in,omitempty"`
NationLt *string `json:"nation_lt,omitempty"`
NationLte *string `json:"nation_lte,omitempty"`
NationGt *string `json:"nation_gt,omitempty"`
NationGte *string `json:"nation_gte,omitempty"`
NationContains *string `json:"nation_contains,omitempty"`
NationNotContains *string `json:"nation_not_contains,omitempty"`
NationStartsWith *string `json:"nation_starts_with,omitempty"`
NationNotStartsWith *string `json:"nation_not_starts_with,omitempty"`
NationEndsWith *string `json:"nation_ends_with,omitempty"`
NationNotEndsWith *string `json:"nation_not_ends_with,omitempty"`
Authority *string `json:"authority,omitempty"`
AuthorityNot *string `json:"authority_not,omitempty"`
AuthorityIn []string `json:"authority_in,omitempty"`
AuthorityNotIn []string `json:"authority_not_in,omitempty"`
AuthorityLt *string `json:"authority_lt,omitempty"`
AuthorityLte *string `json:"authority_lte,omitempty"`
AuthorityGt *string `json:"authority_gt,omitempty"`
AuthorityGte *string `json:"authority_gte,omitempty"`
AuthorityContains *string `json:"authority_contains,omitempty"`
AuthorityNotContains *string `json:"authority_not_contains,omitempty"`
AuthorityStartsWith *string `json:"authority_starts_with,omitempty"`
AuthorityNotStartsWith *string `json:"authority_not_starts_with,omitempty"`
AuthorityEndsWith *string `json:"authority_ends_with,omitempty"`
AuthorityNotEndsWith *string `json:"authority_not_ends_with,omitempty"`
Gender *string `json:"gender,omitempty"`
GenderNot *string `json:"gender_not,omitempty"`
GenderIn []string `json:"gender_in,omitempty"`
GenderNotIn []string `json:"gender_not_in,omitempty"`
GenderLt *string `json:"gender_lt,omitempty"`
GenderLte *string `json:"gender_lte,omitempty"`
GenderGt *string `json:"gender_gt,omitempty"`
GenderGte *string `json:"gender_gte,omitempty"`
GenderContains *string `json:"gender_contains,omitempty"`
GenderNotContains *string `json:"gender_not_contains,omitempty"`
GenderStartsWith *string `json:"gender_starts_with,omitempty"`
GenderNotStartsWith *string `json:"gender_not_starts_with,omitempty"`
GenderEndsWith *string `json:"gender_ends_with,omitempty"`
GenderNotEndsWith *string `json:"gender_not_ends_with,omitempty"`
Class *string `json:"class,omitempty"`
ClassNot *string `json:"class_not,omitempty"`
ClassIn []string `json:"class_in,omitempty"`
ClassNotIn []string `json:"class_not_in,omitempty"`
ClassLt *string `json:"class_lt,omitempty"`
ClassLte *string `json:"class_lte,omitempty"`
ClassGt *string `json:"class_gt,omitempty"`
ClassGte *string `json:"class_gte,omitempty"`
ClassContains *string `json:"class_contains,omitempty"`
ClassNotContains *string `json:"class_not_contains,omitempty"`
ClassStartsWith *string `json:"class_starts_with,omitempty"`
ClassNotStartsWith *string `json:"class_not_starts_with,omitempty"`
ClassEndsWith *string `json:"class_ends_with,omitempty"`
ClassNotEndsWith *string `json:"class_not_ends_with,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
StudentNumberNot *string `json:"studentNumber_not,omitempty"`
StudentNumberIn []string `json:"studentNumber_in,omitempty"`
StudentNumberNotIn []string `json:"studentNumber_not_in,omitempty"`
StudentNumberLt *string `json:"studentNumber_lt,omitempty"`
StudentNumberLte *string `json:"studentNumber_lte,omitempty"`
StudentNumberGt *string `json:"studentNumber_gt,omitempty"`
StudentNumberGte *string `json:"studentNumber_gte,omitempty"`
StudentNumberContains *string `json:"studentNumber_contains,omitempty"`
StudentNumberNotContains *string `json:"studentNumber_not_contains,omitempty"`
StudentNumberStartsWith *string `json:"studentNumber_starts_with,omitempty"`
StudentNumberNotStartsWith *string `json:"studentNumber_not_starts_with,omitempty"`
StudentNumberEndsWith *string `json:"studentNumber_ends_with,omitempty"`
StudentNumberNotEndsWith *string `json:"studentNumber_not_ends_with,omitempty"`
Phone *string `json:"phone,omitempty"`
PhoneNot *string `json:"phone_not,omitempty"`
PhoneIn []string `json:"phone_in,omitempty"`
PhoneNotIn []string `json:"phone_not_in,omitempty"`
PhoneLt *string `json:"phone_lt,omitempty"`
PhoneLte *string `json:"phone_lte,omitempty"`
PhoneGt *string `json:"phone_gt,omitempty"`
PhoneGte *string `json:"phone_gte,omitempty"`
PhoneContains *string `json:"phone_contains,omitempty"`
PhoneNotContains *string `json:"phone_not_contains,omitempty"`
PhoneStartsWith *string `json:"phone_starts_with,omitempty"`
PhoneNotStartsWith *string `json:"phone_not_starts_with,omitempty"`
PhoneEndsWith *string `json:"phone_ends_with,omitempty"`
PhoneNotEndsWith *string `json:"phone_not_ends_with,omitempty"`
Remark *string `json:"remark,omitempty"`
RemarkNot *string `json:"remark_not,omitempty"`
RemarkIn []string `json:"remark_in,omitempty"`
RemarkNotIn []string `json:"remark_not_in,omitempty"`
RemarkLt *string `json:"remark_lt,omitempty"`
RemarkLte *string `json:"remark_lte,omitempty"`
RemarkGt *string `json:"remark_gt,omitempty"`
RemarkGte *string `json:"remark_gte,omitempty"`
RemarkContains *string `json:"remark_contains,omitempty"`
RemarkNotContains *string `json:"remark_not_contains,omitempty"`
RemarkStartsWith *string `json:"remark_starts_with,omitempty"`
RemarkNotStartsWith *string `json:"remark_not_starts_with,omitempty"`
RemarkEndsWith *string `json:"remark_ends_with,omitempty"`
RemarkNotEndsWith *string `json:"remark_not_ends_with,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
BaseFaceImgUriNot *string `json:"baseFaceImgUri_not,omitempty"`
BaseFaceImgUriIn []string `json:"baseFaceImgUri_in,omitempty"`
BaseFaceImgUriNotIn []string `json:"baseFaceImgUri_not_in,omitempty"`
BaseFaceImgUriLt *string `json:"baseFaceImgUri_lt,omitempty"`
BaseFaceImgUriLte *string `json:"baseFaceImgUri_lte,omitempty"`
BaseFaceImgUriGt *string `json:"baseFaceImgUri_gt,omitempty"`
BaseFaceImgUriGte *string `json:"baseFaceImgUri_gte,omitempty"`
BaseFaceImgUriContains *string `json:"baseFaceImgUri_contains,omitempty"`
BaseFaceImgUriNotContains *string `json:"baseFaceImgUri_not_contains,omitempty"`
BaseFaceImgUriStartsWith *string `json:"baseFaceImgUri_starts_with,omitempty"`
BaseFaceImgUriNotStartsWith *string `json:"baseFaceImgUri_not_starts_with,omitempty"`
BaseFaceImgUriEndsWith *string `json:"baseFaceImgUri_ends_with,omitempty"`
BaseFaceImgUriNotEndsWith *string `json:"baseFaceImgUri_not_ends_with,omitempty"`
IDCardVerifyDatasEvery *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_every,omitempty"`
IDCardVerifyDatasSome *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_some,omitempty"`
IDCardVerifyDatasNone *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_none,omitempty"`
MacinfosEvery *MaCinfoWhereInput `json:"macinfos_every,omitempty"`
MacinfosSome *MaCinfoWhereInput `json:"macinfos_some,omitempty"`
MacinfosNone *MaCinfoWhereInput `json:"macinfos_none,omitempty"`
And []PersonInfoWhereInput `json:"AND,omitempty"`
Or []PersonInfoWhereInput `json:"OR,omitempty"`
Not []PersonInfoWhereInput `json:"NOT,omitempty"`
          }

      type MaCinfoUpsertWithoutMacProbeDatasInput struct {
        Update MaCinfoUpdateWithoutMacProbeDatasDataInput `json:"update"`
Create MaCinfoCreateWithoutMacProbeDatasInput `json:"create"`
          }

      type CityCodeInfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *CityCodeInfoWhereInput `json:"node,omitempty"`
And []CityCodeInfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []CityCodeInfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []CityCodeInfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type MacProbeDataUpsertWithWhereUniqueWithoutWifiProberInput struct {
        Where MacProbeDataWhereUniqueInput `json:"where"`
Update MacProbeDataUpdateWithoutWifiProberDataInput `json:"update"`
Create MacProbeDataCreateWithoutWifiProberInput `json:"create"`
          }

      type AirHistoryDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *AirHistoryDataWhereInput `json:"node,omitempty"`
And []AirHistoryDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []AirHistoryDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []AirHistoryDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type WiFiProberinfoUpsertWithWhereUniqueWithoutLocationInfoInput struct {
        Where WiFiProberinfoWhereUniqueInput `json:"where"`
Update WiFiProberinfoUpdateWithoutLocationInfoDataInput `json:"update"`
Create WiFiProberinfoCreateWithoutLocationInfoInput `json:"create"`
          }

      type AttendanceRecordWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type WiFiProberinfoScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMacNot *string `json:"devMac_not,omitempty"`
DevMacIn []string `json:"devMac_in,omitempty"`
DevMacNotIn []string `json:"devMac_not_in,omitempty"`
DevMacLt *string `json:"devMac_lt,omitempty"`
DevMacLte *string `json:"devMac_lte,omitempty"`
DevMacGt *string `json:"devMac_gt,omitempty"`
DevMacGte *string `json:"devMac_gte,omitempty"`
DevMacContains *string `json:"devMac_contains,omitempty"`
DevMacNotContains *string `json:"devMac_not_contains,omitempty"`
DevMacStartsWith *string `json:"devMac_starts_with,omitempty"`
DevMacNotStartsWith *string `json:"devMac_not_starts_with,omitempty"`
DevMacEndsWith *string `json:"devMac_ends_with,omitempty"`
DevMacNotEndsWith *string `json:"devMac_not_ends_with,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
DevMdoelNot *string `json:"devMdoel_not,omitempty"`
DevMdoelIn []string `json:"devMdoel_in,omitempty"`
DevMdoelNotIn []string `json:"devMdoel_not_in,omitempty"`
DevMdoelLt *string `json:"devMdoel_lt,omitempty"`
DevMdoelLte *string `json:"devMdoel_lte,omitempty"`
DevMdoelGt *string `json:"devMdoel_gt,omitempty"`
DevMdoelGte *string `json:"devMdoel_gte,omitempty"`
DevMdoelContains *string `json:"devMdoel_contains,omitempty"`
DevMdoelNotContains *string `json:"devMdoel_not_contains,omitempty"`
DevMdoelStartsWith *string `json:"devMdoel_starts_with,omitempty"`
DevMdoelNotStartsWith *string `json:"devMdoel_not_starts_with,omitempty"`
DevMdoelEndsWith *string `json:"devMdoel_ends_with,omitempty"`
DevMdoelNotEndsWith *string `json:"devMdoel_not_ends_with,omitempty"`
And []WiFiProberinfoScalarWhereInput `json:"AND,omitempty"`
Or []WiFiProberinfoScalarWhereInput `json:"OR,omitempty"`
Not []WiFiProberinfoScalarWhereInput `json:"NOT,omitempty"`
          }

      type CityCodeInfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
          }

      type WiFiProberinfoUpdateManyWithWhereNestedInput struct {
        Where WiFiProberinfoScalarWhereInput `json:"where"`
Data WiFiProberinfoUpdateManyDataInput `json:"data"`
          }

      type CityCodeInfoCreateWithoutWeatherLiveInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type WiFiProberinfoUpdateManyDataInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
          }

      type IDVerifyDeviceInfoWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevNoNot *string `json:"devNo_not,omitempty"`
DevNoIn []string `json:"devNo_in,omitempty"`
DevNoNotIn []string `json:"devNo_not_in,omitempty"`
DevNoLt *string `json:"devNo_lt,omitempty"`
DevNoLte *string `json:"devNo_lte,omitempty"`
DevNoGt *string `json:"devNo_gt,omitempty"`
DevNoGte *string `json:"devNo_gte,omitempty"`
DevNoContains *string `json:"devNo_contains,omitempty"`
DevNoNotContains *string `json:"devNo_not_contains,omitempty"`
DevNoStartsWith *string `json:"devNo_starts_with,omitempty"`
DevNoNotStartsWith *string `json:"devNo_not_starts_with,omitempty"`
DevNoEndsWith *string `json:"devNo_ends_with,omitempty"`
DevNoNotEndsWith *string `json:"devNo_not_ends_with,omitempty"`
DevName *string `json:"devName,omitempty"`
DevNameNot *string `json:"devName_not,omitempty"`
DevNameIn []string `json:"devName_in,omitempty"`
DevNameNotIn []string `json:"devName_not_in,omitempty"`
DevNameLt *string `json:"devName_lt,omitempty"`
DevNameLte *string `json:"devName_lte,omitempty"`
DevNameGt *string `json:"devName_gt,omitempty"`
DevNameGte *string `json:"devName_gte,omitempty"`
DevNameContains *string `json:"devName_contains,omitempty"`
DevNameNotContains *string `json:"devName_not_contains,omitempty"`
DevNameStartsWith *string `json:"devName_starts_with,omitempty"`
DevNameNotStartsWith *string `json:"devName_not_starts_with,omitempty"`
DevNameEndsWith *string `json:"devName_ends_with,omitempty"`
DevNameNotEndsWith *string `json:"devName_not_ends_with,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
DevAddrNot *string `json:"devAddr_not,omitempty"`
DevAddrIn []string `json:"devAddr_in,omitempty"`
DevAddrNotIn []string `json:"devAddr_not_in,omitempty"`
DevAddrLt *string `json:"devAddr_lt,omitempty"`
DevAddrLte *string `json:"devAddr_lte,omitempty"`
DevAddrGt *string `json:"devAddr_gt,omitempty"`
DevAddrGte *string `json:"devAddr_gte,omitempty"`
DevAddrContains *string `json:"devAddr_contains,omitempty"`
DevAddrNotContains *string `json:"devAddr_not_contains,omitempty"`
DevAddrStartsWith *string `json:"devAddr_starts_with,omitempty"`
DevAddrNotStartsWith *string `json:"devAddr_not_starts_with,omitempty"`
DevAddrEndsWith *string `json:"devAddr_ends_with,omitempty"`
DevAddrNotEndsWith *string `json:"devAddr_not_ends_with,omitempty"`
LocationInfo *LocationInfoWhereInput `json:"locationInfo,omitempty"`
IDCardVerifyDatasEvery *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_every,omitempty"`
IDCardVerifyDatasSome *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_some,omitempty"`
IDCardVerifyDatasNone *IDCardVerifyDataWhereInput `json:"idCardVerifyDatas_none,omitempty"`
And []IDVerifyDeviceInfoWhereInput `json:"AND,omitempty"`
Or []IDVerifyDeviceInfoWhereInput `json:"OR,omitempty"`
Not []IDVerifyDeviceInfoWhereInput `json:"NOT,omitempty"`
          }

      type LocationInfoUpsertNestedInput struct {
        Update LocationInfoUpdateDataInput `json:"update"`
Create LocationInfoCreateInput `json:"create"`
          }

      type HistoryDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type AirLiveUpdateOneWithoutCityInfoInput struct {
        Create *AirLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Update *AirLiveUpdateWithoutCityInfoDataInput `json:"update,omitempty"`
Upsert *AirLiveUpsertWithoutCityInfoInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *AirLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type IDCardVerifyDataWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type AirLiveUpdateWithoutCityInfoDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type IDVerifyDeviceInfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
          }

      type AirLiveUpsertWithoutCityInfoInput struct {
        Update AirLiveUpdateWithoutCityInfoDataInput `json:"update"`
Create AirLiveCreateWithoutCityInfoInput `json:"create"`
          }

      type LocationInfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type WeatherLiveUpdateOneWithoutCityInfoInput struct {
        Create *WeatherLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Update *WeatherLiveUpdateWithoutCityInfoDataInput `json:"update,omitempty"`
Upsert *WeatherLiveUpsertWithoutCityInfoInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *WeatherLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoCreateWithoutWeatherAirLiveInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type WeatherLiveUpdateWithoutCityInfoDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type WeatherAirHistoryUpdateManyMutationInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type WeatherLiveUpsertWithoutCityInfoInput struct {
        Update WeatherLiveUpdateWithoutCityInfoDataInput `json:"update"`
Create WeatherLiveCreateWithoutCityInfoInput `json:"create"`
          }

      type MonitorNodeWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
MonitorSn *string `json:"monitorSN,omitempty"`
MonitorSnNot *string `json:"monitorSN_not,omitempty"`
MonitorSnIn []string `json:"monitorSN_in,omitempty"`
MonitorSnNotIn []string `json:"monitorSN_not_in,omitempty"`
MonitorSnLt *string `json:"monitorSN_lt,omitempty"`
MonitorSnLte *string `json:"monitorSN_lte,omitempty"`
MonitorSnGt *string `json:"monitorSN_gt,omitempty"`
MonitorSnGte *string `json:"monitorSN_gte,omitempty"`
MonitorSnContains *string `json:"monitorSN_contains,omitempty"`
MonitorSnNotContains *string `json:"monitorSN_not_contains,omitempty"`
MonitorSnStartsWith *string `json:"monitorSN_starts_with,omitempty"`
MonitorSnNotStartsWith *string `json:"monitorSN_not_starts_with,omitempty"`
MonitorSnEndsWith *string `json:"monitorSN_ends_with,omitempty"`
MonitorSnNotEndsWith *string `json:"monitorSN_not_ends_with,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorNameNot *string `json:"monitorName_not,omitempty"`
MonitorNameIn []string `json:"monitorName_in,omitempty"`
MonitorNameNotIn []string `json:"monitorName_not_in,omitempty"`
MonitorNameLt *string `json:"monitorName_lt,omitempty"`
MonitorNameLte *string `json:"monitorName_lte,omitempty"`
MonitorNameGt *string `json:"monitorName_gt,omitempty"`
MonitorNameGte *string `json:"monitorName_gte,omitempty"`
MonitorNameContains *string `json:"monitorName_contains,omitempty"`
MonitorNameNotContains *string `json:"monitorName_not_contains,omitempty"`
MonitorNameStartsWith *string `json:"monitorName_starts_with,omitempty"`
MonitorNameNotStartsWith *string `json:"monitorName_not_starts_with,omitempty"`
MonitorNameEndsWith *string `json:"monitorName_ends_with,omitempty"`
MonitorNameNotEndsWith *string `json:"monitorName_not_ends_with,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorTypeNot *string `json:"monitorType_not,omitempty"`
MonitorTypeIn []string `json:"monitorType_in,omitempty"`
MonitorTypeNotIn []string `json:"monitorType_not_in,omitempty"`
MonitorTypeLt *string `json:"monitorType_lt,omitempty"`
MonitorTypeLte *string `json:"monitorType_lte,omitempty"`
MonitorTypeGt *string `json:"monitorType_gt,omitempty"`
MonitorTypeGte *string `json:"monitorType_gte,omitempty"`
MonitorTypeContains *string `json:"monitorType_contains,omitempty"`
MonitorTypeNotContains *string `json:"monitorType_not_contains,omitempty"`
MonitorTypeStartsWith *string `json:"monitorType_starts_with,omitempty"`
MonitorTypeNotStartsWith *string `json:"monitorType_not_starts_with,omitempty"`
MonitorTypeEndsWith *string `json:"monitorType_ends_with,omitempty"`
MonitorTypeNotEndsWith *string `json:"monitorType_not_ends_with,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
MonitorStatusNot *string `json:"monitorStatus_not,omitempty"`
MonitorStatusIn []string `json:"monitorStatus_in,omitempty"`
MonitorStatusNotIn []string `json:"monitorStatus_not_in,omitempty"`
MonitorStatusLt *string `json:"monitorStatus_lt,omitempty"`
MonitorStatusLte *string `json:"monitorStatus_lte,omitempty"`
MonitorStatusGt *string `json:"monitorStatus_gt,omitempty"`
MonitorStatusGte *string `json:"monitorStatus_gte,omitempty"`
MonitorStatusContains *string `json:"monitorStatus_contains,omitempty"`
MonitorStatusNotContains *string `json:"monitorStatus_not_contains,omitempty"`
MonitorStatusStartsWith *string `json:"monitorStatus_starts_with,omitempty"`
MonitorStatusNotStartsWith *string `json:"monitorStatus_not_starts_with,omitempty"`
MonitorStatusEndsWith *string `json:"monitorStatus_ends_with,omitempty"`
MonitorStatusNotEndsWith *string `json:"monitorStatus_not_ends_with,omitempty"`
Location *LocationInfoWhereInput `json:"location,omitempty"`
RealTimeData *RealTimeDataWhereInput `json:"realTimeData,omitempty"`
HistoryDatasEvery *HistoryDataWhereInput `json:"historyDatas_every,omitempty"`
HistoryDatasSome *HistoryDataWhereInput `json:"historyDatas_some,omitempty"`
HistoryDatasNone *HistoryDataWhereInput `json:"historyDatas_none,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
And []MonitorNodeWhereInput `json:"AND,omitempty"`
Or []MonitorNodeWhereInput `json:"OR,omitempty"`
Not []MonitorNodeWhereInput `json:"NOT,omitempty"`
          }

      type WeatherAirLiveUpdateOneWithoutCityInfoInput struct {
        Create *WeatherAirLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Update *WeatherAirLiveUpdateWithoutCityInfoDataInput `json:"update,omitempty"`
Upsert *WeatherAirLiveUpsertWithoutCityInfoInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *WeatherAirLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type MaCinfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Mac *string `json:"mac,omitempty"`
          }

      type WeatherAirLiveUpdateWithoutCityInfoDataInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type MonitorNodeWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
MonitorSn *string `json:"monitorSN,omitempty"`
          }

      type WeatherAirLiveUpsertWithoutCityInfoInput struct {
        Update WeatherAirLiveUpdateWithoutCityInfoDataInput `json:"update"`
Create WeatherAirLiveCreateWithoutCityInfoInput `json:"create"`
          }

      type PersonInfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
IDCard *string `json:"idCard,omitempty"`
          }

      type WeatherAirHistoryUpdateManyWithoutCityInfoInput struct {
        Create []WeatherAirHistoryCreateWithoutCityInfoInput `json:"create,omitempty"`
Delete []WeatherAirHistoryWhereUniqueInput `json:"delete,omitempty"`
Connect []WeatherAirHistoryWhereUniqueInput `json:"connect,omitempty"`
Set []WeatherAirHistoryWhereUniqueInput `json:"set,omitempty"`
Disconnect []WeatherAirHistoryWhereUniqueInput `json:"disconnect,omitempty"`
Update []WeatherAirHistoryUpdateWithWhereUniqueWithoutCityInfoInput `json:"update,omitempty"`
Upsert []WeatherAirHistoryUpsertWithWhereUniqueWithoutCityInfoInput `json:"upsert,omitempty"`
DeleteMany []WeatherAirHistoryScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []WeatherAirHistoryUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type MonitorNodeCreateOneWithoutRealTimeDataInput struct {
        Create *MonitorNodeCreateWithoutRealTimeDataInput `json:"create,omitempty"`
Connect *MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherAirHistoryUpdateWithWhereUniqueWithoutCityInfoInput struct {
        Where WeatherAirHistoryWhereUniqueInput `json:"where"`
Data WeatherAirHistoryUpdateWithoutCityInfoDataInput `json:"data"`
          }

      type PersonInfoUpdateInput struct {
        IDCard *string `json:"idCard,omitempty"`
CardType *string `json:"cardType,omitempty"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataUpdateManyWithoutPersonInput `json:"idCardVerifyDatas,omitempty"`
Macinfos *MaCinfoUpdateManyWithoutPersonInput `json:"macinfos,omitempty"`
          }

      type WeatherAirHistoryUpdateWithoutCityInfoDataInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type MonitorNodeUpdateInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
Location *LocationInfoUpdateOneWithoutMonitorNodesInput `json:"location,omitempty"`
RealTimeData *RealTimeDataUpdateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
HistoryDatas *HistoryDataUpdateManyWithoutMonitorNodeInput `json:"historyDatas,omitempty"`
          }

      type WeatherAirHistoryUpsertWithWhereUniqueWithoutCityInfoInput struct {
        Where WeatherAirHistoryWhereUniqueInput `json:"where"`
Update WeatherAirHistoryUpdateWithoutCityInfoDataInput `json:"update"`
Create WeatherAirHistoryCreateWithoutCityInfoInput `json:"create"`
          }

      type MaCinfoUpdateInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoUpdateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataUpdateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
AttendanceRecords *AttendanceRecordUpdateManyWithoutMacInput `json:"attendanceRecords,omitempty"`
          }

      type WeatherAirHistoryScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
WindSpeedNot *string `json:"WindSpeed_not,omitempty"`
WindSpeedIn []string `json:"WindSpeed_in,omitempty"`
WindSpeedNotIn []string `json:"WindSpeed_not_in,omitempty"`
WindSpeedLt *string `json:"WindSpeed_lt,omitempty"`
WindSpeedLte *string `json:"WindSpeed_lte,omitempty"`
WindSpeedGt *string `json:"WindSpeed_gt,omitempty"`
WindSpeedGte *string `json:"WindSpeed_gte,omitempty"`
WindSpeedContains *string `json:"WindSpeed_contains,omitempty"`
WindSpeedNotContains *string `json:"WindSpeed_not_contains,omitempty"`
WindSpeedStartsWith *string `json:"WindSpeed_starts_with,omitempty"`
WindSpeedNotStartsWith *string `json:"WindSpeed_not_starts_with,omitempty"`
WindSpeedEndsWith *string `json:"WindSpeed_ends_with,omitempty"`
WindSpeedNotEndsWith *string `json:"WindSpeed_not_ends_with,omitempty"`
CityName *string `json:"CityName,omitempty"`
CityNameNot *string `json:"CityName_not,omitempty"`
CityNameIn []string `json:"CityName_in,omitempty"`
CityNameNotIn []string `json:"CityName_not_in,omitempty"`
CityNameLt *string `json:"CityName_lt,omitempty"`
CityNameLte *string `json:"CityName_lte,omitempty"`
CityNameGt *string `json:"CityName_gt,omitempty"`
CityNameGte *string `json:"CityName_gte,omitempty"`
CityNameContains *string `json:"CityName_contains,omitempty"`
CityNameNotContains *string `json:"CityName_not_contains,omitempty"`
CityNameStartsWith *string `json:"CityName_starts_with,omitempty"`
CityNameNotStartsWith *string `json:"CityName_not_starts_with,omitempty"`
CityNameEndsWith *string `json:"CityName_ends_with,omitempty"`
CityNameNotEndsWith *string `json:"CityName_not_ends_with,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
AirpressureNot *string `json:"Airpressure_not,omitempty"`
AirpressureIn []string `json:"Airpressure_in,omitempty"`
AirpressureNotIn []string `json:"Airpressure_not_in,omitempty"`
AirpressureLt *string `json:"Airpressure_lt,omitempty"`
AirpressureLte *string `json:"Airpressure_lte,omitempty"`
AirpressureGt *string `json:"Airpressure_gt,omitempty"`
AirpressureGte *string `json:"Airpressure_gte,omitempty"`
AirpressureContains *string `json:"Airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"Airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"Airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"Airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"Airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"Airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
PhenomenaNot *string `json:"Phenomena_not,omitempty"`
PhenomenaIn []string `json:"Phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"Phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"Phenomena_lt,omitempty"`
PhenomenaLte *string `json:"Phenomena_lte,omitempty"`
PhenomenaGt *string `json:"Phenomena_gt,omitempty"`
PhenomenaGte *string `json:"Phenomena_gte,omitempty"`
PhenomenaContains *string `json:"Phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"Phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"Phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"Phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"Phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"Phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
RdescNot *string `json:"Rdesc_not,omitempty"`
RdescIn []string `json:"Rdesc_in,omitempty"`
RdescNotIn []string `json:"Rdesc_not_in,omitempty"`
RdescLt *string `json:"Rdesc_lt,omitempty"`
RdescLte *string `json:"Rdesc_lte,omitempty"`
RdescGt *string `json:"Rdesc_gt,omitempty"`
RdescGte *string `json:"Rdesc_gte,omitempty"`
RdescContains *string `json:"Rdesc_contains,omitempty"`
RdescNotContains *string `json:"Rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"Rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"Rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"Rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"Rdesc_not_ends_with,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
HumidityNot *string `json:"Humidity_not,omitempty"`
HumidityIn []string `json:"Humidity_in,omitempty"`
HumidityNotIn []string `json:"Humidity_not_in,omitempty"`
HumidityLt *string `json:"Humidity_lt,omitempty"`
HumidityLte *string `json:"Humidity_lte,omitempty"`
HumidityGt *string `json:"Humidity_gt,omitempty"`
HumidityGte *string `json:"Humidity_gte,omitempty"`
HumidityContains *string `json:"Humidity_contains,omitempty"`
HumidityNotContains *string `json:"Humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"Humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"Humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"Humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"Humidity_not_ends_with,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
UpdatetimeNot *string `json:"Updatetime_not,omitempty"`
UpdatetimeIn []string `json:"Updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"Updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"Updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"Updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"Updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"Updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"Updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"Updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"Updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"Updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"Updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"Updatetime_not_ends_with,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
WindpowerNot *string `json:"Windpower_not,omitempty"`
WindpowerIn []string `json:"Windpower_in,omitempty"`
WindpowerNotIn []string `json:"Windpower_not_in,omitempty"`
WindpowerLt *string `json:"Windpower_lt,omitempty"`
WindpowerLte *string `json:"Windpower_lte,omitempty"`
WindpowerGt *string `json:"Windpower_gt,omitempty"`
WindpowerGte *string `json:"Windpower_gte,omitempty"`
WindpowerContains *string `json:"Windpower_contains,omitempty"`
WindpowerNotContains *string `json:"Windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"Windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"Windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"Windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"Windpower_not_ends_with,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
FeelstNot *string `json:"Feelst_not,omitempty"`
FeelstIn []string `json:"Feelst_in,omitempty"`
FeelstNotIn []string `json:"Feelst_not_in,omitempty"`
FeelstLt *string `json:"Feelst_lt,omitempty"`
FeelstLte *string `json:"Feelst_lte,omitempty"`
FeelstGt *string `json:"Feelst_gt,omitempty"`
FeelstGte *string `json:"Feelst_gte,omitempty"`
FeelstContains *string `json:"Feelst_contains,omitempty"`
FeelstNotContains *string `json:"Feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"Feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"Feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"Feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"Feelst_not_ends_with,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
WinddirectNot *string `json:"Winddirect_not,omitempty"`
WinddirectIn []string `json:"Winddirect_in,omitempty"`
WinddirectNotIn []string `json:"Winddirect_not_in,omitempty"`
WinddirectLt *string `json:"Winddirect_lt,omitempty"`
WinddirectLte *string `json:"Winddirect_lte,omitempty"`
WinddirectGt *string `json:"Winddirect_gt,omitempty"`
WinddirectGte *string `json:"Winddirect_gte,omitempty"`
WinddirectContains *string `json:"Winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"Winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"Winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"Winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"Winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"Winddirect_not_ends_with,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
RcodeNot *int32 `json:"Rcode_not,omitempty"`
RcodeIn []int32 `json:"Rcode_in,omitempty"`
RcodeNotIn []int32 `json:"Rcode_not_in,omitempty"`
RcodeLt *int32 `json:"Rcode_lt,omitempty"`
RcodeLte *int32 `json:"Rcode_lte,omitempty"`
RcodeGt *int32 `json:"Rcode_gt,omitempty"`
RcodeGte *int32 `json:"Rcode_gte,omitempty"`
Rain *string `json:"Rain,omitempty"`
RainNot *string `json:"Rain_not,omitempty"`
RainIn []string `json:"Rain_in,omitempty"`
RainNotIn []string `json:"Rain_not_in,omitempty"`
RainLt *string `json:"Rain_lt,omitempty"`
RainLte *string `json:"Rain_lte,omitempty"`
RainGt *string `json:"Rain_gt,omitempty"`
RainGte *string `json:"Rain_gte,omitempty"`
RainContains *string `json:"Rain_contains,omitempty"`
RainNotContains *string `json:"Rain_not_contains,omitempty"`
RainStartsWith *string `json:"Rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"Rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"Rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"Rain_not_ends_with,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
TemperatureNot *string `json:"Temperature_not,omitempty"`
TemperatureIn []string `json:"Temperature_in,omitempty"`
TemperatureNotIn []string `json:"Temperature_not_in,omitempty"`
TemperatureLt *string `json:"Temperature_lt,omitempty"`
TemperatureLte *string `json:"Temperature_lte,omitempty"`
TemperatureGt *string `json:"Temperature_gt,omitempty"`
TemperatureGte *string `json:"Temperature_gte,omitempty"`
TemperatureContains *string `json:"Temperature_contains,omitempty"`
TemperatureNotContains *string `json:"Temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"Temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"Temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"Temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"Temperature_not_ends_with,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
CitycodeNot *string `json:"Citycode_not,omitempty"`
CitycodeIn []string `json:"Citycode_in,omitempty"`
CitycodeNotIn []string `json:"Citycode_not_in,omitempty"`
CitycodeLt *string `json:"Citycode_lt,omitempty"`
CitycodeLte *string `json:"Citycode_lte,omitempty"`
CitycodeGt *string `json:"Citycode_gt,omitempty"`
CitycodeGte *string `json:"Citycode_gte,omitempty"`
CitycodeContains *string `json:"Citycode_contains,omitempty"`
CitycodeNotContains *string `json:"Citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"Citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"Citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"Citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"Citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"O3,omitempty"`
O3Not *string `json:"O3_not,omitempty"`
O3In []string `json:"O3_in,omitempty"`
O3NotIn []string `json:"O3_not_in,omitempty"`
O3Lt *string `json:"O3_lt,omitempty"`
O3Lte *string `json:"O3_lte,omitempty"`
O3Gt *string `json:"O3_gt,omitempty"`
O3Gte *string `json:"O3_gte,omitempty"`
O3Contains *string `json:"O3_contains,omitempty"`
O3NotContains *string `json:"O3_not_contains,omitempty"`
O3StartsWith *string `json:"O3_starts_with,omitempty"`
O3NotStartsWith *string `json:"O3_not_starts_with,omitempty"`
O3EndsWith *string `json:"O3_ends_with,omitempty"`
O3NotEndsWith *string `json:"O3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"Primary,omitempty"`
PrimaryNot *string `json:"Primary_not,omitempty"`
PrimaryIn []string `json:"Primary_in,omitempty"`
PrimaryNotIn []string `json:"Primary_not_in,omitempty"`
PrimaryLt *string `json:"Primary_lt,omitempty"`
PrimaryLte *string `json:"Primary_lte,omitempty"`
PrimaryGt *string `json:"Primary_gt,omitempty"`
PrimaryGte *string `json:"Primary_gte,omitempty"`
PrimaryContains *string `json:"Primary_contains,omitempty"`
PrimaryNotContains *string `json:"Primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"Primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"Primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"Primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"Primary_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
And []WeatherAirHistoryScalarWhereInput `json:"AND,omitempty"`
Or []WeatherAirHistoryScalarWhereInput `json:"OR,omitempty"`
Not []WeatherAirHistoryScalarWhereInput `json:"NOT,omitempty"`
          }

      type MacProbeRecordUpdateInput struct {
        Mac *string `json:"mac,omitempty"`
DevNo *string `json:"devNo,omitempty"`
EntryTime *string `json:"entryTime,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
          }

      type WeatherAirHistoryUpdateManyWithWhereNestedInput struct {
        Where WeatherAirHistoryScalarWhereInput `json:"where"`
Data WeatherAirHistoryUpdateManyDataInput `json:"data"`
          }

      type MacProbeDataUpdateInput struct {
        ProbeTime *string `json:"probeTime,omitempty"`
Mac *MaCinfoUpdateOneWithoutMacProbeDatasInput `json:"mac,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
WifiProber *WiFiProberinfoUpdateOneWithoutMacProbeDatasInput `json:"wifiProber,omitempty"`
          }

      type WeatherAirHistoryUpdateManyDataInput struct {
        WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type WiFiProberinfoWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
          }

      type WeatherHistoryDataUpdateManyWithoutCityInfoInput struct {
        Create []WeatherHistoryDataCreateWithoutCityInfoInput `json:"create,omitempty"`
Delete []WeatherHistoryDataWhereUniqueInput `json:"delete,omitempty"`
Connect []WeatherHistoryDataWhereUniqueInput `json:"connect,omitempty"`
Set []WeatherHistoryDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []WeatherHistoryDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []WeatherHistoryDataUpdateWithWhereUniqueWithoutCityInfoInput `json:"update,omitempty"`
Upsert []WeatherHistoryDataUpsertWithWhereUniqueWithoutCityInfoInput `json:"upsert,omitempty"`
DeleteMany []WeatherHistoryDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []WeatherHistoryDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type LocationInfoCreateOneInput struct {
        Create *LocationInfoCreateInput `json:"create,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpdateWithWhereUniqueWithoutCityInfoInput struct {
        Where WeatherHistoryDataWhereUniqueInput `json:"where"`
Data WeatherHistoryDataUpdateWithoutCityInfoDataInput `json:"data"`
          }

      type RealTimeDataCreateOneWithoutMonitorNodeInput struct {
        Create *RealTimeDataCreateWithoutMonitorNodeInput `json:"create,omitempty"`
Connect *RealTimeDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpdateWithoutCityInfoDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type IDVerifyDeviceInfoCreateManyWithoutLocationInfoInput struct {
        Create []IDVerifyDeviceInfoCreateWithoutLocationInfoInput `json:"create,omitempty"`
Connect []IDVerifyDeviceInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpsertWithWhereUniqueWithoutCityInfoInput struct {
        Where WeatherHistoryDataWhereUniqueInput `json:"where"`
Update WeatherHistoryDataUpdateWithoutCityInfoDataInput `json:"update"`
Create WeatherHistoryDataCreateWithoutCityInfoInput `json:"create"`
          }

      type PersonInfoCreateOneWithoutIdCardVerifyDatasInput struct {
        Create *PersonInfoCreateWithoutIdCardVerifyDatasInput `json:"create,omitempty"`
Connect *PersonInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
WindspeedNot *string `json:"windspeed_not,omitempty"`
WindspeedIn []string `json:"windspeed_in,omitempty"`
WindspeedNotIn []string `json:"windspeed_not_in,omitempty"`
WindspeedLt *string `json:"windspeed_lt,omitempty"`
WindspeedLte *string `json:"windspeed_lte,omitempty"`
WindspeedGt *string `json:"windspeed_gt,omitempty"`
WindspeedGte *string `json:"windspeed_gte,omitempty"`
WindspeedContains *string `json:"windspeed_contains,omitempty"`
WindspeedNotContains *string `json:"windspeed_not_contains,omitempty"`
WindspeedStartsWith *string `json:"windspeed_starts_with,omitempty"`
WindspeedNotStartsWith *string `json:"windspeed_not_starts_with,omitempty"`
WindspeedEndsWith *string `json:"windspeed_ends_with,omitempty"`
WindspeedNotEndsWith *string `json:"windspeed_not_ends_with,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
AirpressureNot *string `json:"airpressure_not,omitempty"`
AirpressureIn []string `json:"airpressure_in,omitempty"`
AirpressureNotIn []string `json:"airpressure_not_in,omitempty"`
AirpressureLt *string `json:"airpressure_lt,omitempty"`
AirpressureLte *string `json:"airpressure_lte,omitempty"`
AirpressureGt *string `json:"airpressure_gt,omitempty"`
AirpressureGte *string `json:"airpressure_gte,omitempty"`
AirpressureContains *string `json:"airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
PhenomenaNot *string `json:"phenomena_not,omitempty"`
PhenomenaIn []string `json:"phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"phenomena_lt,omitempty"`
PhenomenaLte *string `json:"phenomena_lte,omitempty"`
PhenomenaGt *string `json:"phenomena_gt,omitempty"`
PhenomenaGte *string `json:"phenomena_gte,omitempty"`
PhenomenaContains *string `json:"phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Humidity *string `json:"humidity,omitempty"`
HumidityNot *string `json:"humidity_not,omitempty"`
HumidityIn []string `json:"humidity_in,omitempty"`
HumidityNotIn []string `json:"humidity_not_in,omitempty"`
HumidityLt *string `json:"humidity_lt,omitempty"`
HumidityLte *string `json:"humidity_lte,omitempty"`
HumidityGt *string `json:"humidity_gt,omitempty"`
HumidityGte *string `json:"humidity_gte,omitempty"`
HumidityContains *string `json:"humidity_contains,omitempty"`
HumidityNotContains *string `json:"humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"humidity_not_ends_with,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
UpdatetimeNot *string `json:"updatetime_not,omitempty"`
UpdatetimeIn []string `json:"updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"updatetime_not_ends_with,omitempty"`
Windpower *string `json:"windpower,omitempty"`
WindpowerNot *string `json:"windpower_not,omitempty"`
WindpowerIn []string `json:"windpower_in,omitempty"`
WindpowerNotIn []string `json:"windpower_not_in,omitempty"`
WindpowerLt *string `json:"windpower_lt,omitempty"`
WindpowerLte *string `json:"windpower_lte,omitempty"`
WindpowerGt *string `json:"windpower_gt,omitempty"`
WindpowerGte *string `json:"windpower_gte,omitempty"`
WindpowerContains *string `json:"windpower_contains,omitempty"`
WindpowerNotContains *string `json:"windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"windpower_not_ends_with,omitempty"`
Feelst *string `json:"feelst,omitempty"`
FeelstNot *string `json:"feelst_not,omitempty"`
FeelstIn []string `json:"feelst_in,omitempty"`
FeelstNotIn []string `json:"feelst_not_in,omitempty"`
FeelstLt *string `json:"feelst_lt,omitempty"`
FeelstLte *string `json:"feelst_lte,omitempty"`
FeelstGt *string `json:"feelst_gt,omitempty"`
FeelstGte *string `json:"feelst_gte,omitempty"`
FeelstContains *string `json:"feelst_contains,omitempty"`
FeelstNotContains *string `json:"feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"feelst_not_ends_with,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
WinddirectNot *string `json:"winddirect_not,omitempty"`
WinddirectIn []string `json:"winddirect_in,omitempty"`
WinddirectNotIn []string `json:"winddirect_not_in,omitempty"`
WinddirectLt *string `json:"winddirect_lt,omitempty"`
WinddirectLte *string `json:"winddirect_lte,omitempty"`
WinddirectGt *string `json:"winddirect_gt,omitempty"`
WinddirectGte *string `json:"winddirect_gte,omitempty"`
WinddirectContains *string `json:"winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"winddirect_not_ends_with,omitempty"`
Rcode *string `json:"rcode,omitempty"`
RcodeNot *string `json:"rcode_not,omitempty"`
RcodeIn []string `json:"rcode_in,omitempty"`
RcodeNotIn []string `json:"rcode_not_in,omitempty"`
RcodeLt *string `json:"rcode_lt,omitempty"`
RcodeLte *string `json:"rcode_lte,omitempty"`
RcodeGt *string `json:"rcode_gt,omitempty"`
RcodeGte *string `json:"rcode_gte,omitempty"`
RcodeContains *string `json:"rcode_contains,omitempty"`
RcodeNotContains *string `json:"rcode_not_contains,omitempty"`
RcodeStartsWith *string `json:"rcode_starts_with,omitempty"`
RcodeNotStartsWith *string `json:"rcode_not_starts_with,omitempty"`
RcodeEndsWith *string `json:"rcode_ends_with,omitempty"`
RcodeNotEndsWith *string `json:"rcode_not_ends_with,omitempty"`
Rain *string `json:"rain,omitempty"`
RainNot *string `json:"rain_not,omitempty"`
RainIn []string `json:"rain_in,omitempty"`
RainNotIn []string `json:"rain_not_in,omitempty"`
RainLt *string `json:"rain_lt,omitempty"`
RainLte *string `json:"rain_lte,omitempty"`
RainGt *string `json:"rain_gt,omitempty"`
RainGte *string `json:"rain_gte,omitempty"`
RainContains *string `json:"rain_contains,omitempty"`
RainNotContains *string `json:"rain_not_contains,omitempty"`
RainStartsWith *string `json:"rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"rain_not_ends_with,omitempty"`
Temperature *string `json:"temperature,omitempty"`
TemperatureNot *string `json:"temperature_not,omitempty"`
TemperatureIn []string `json:"temperature_in,omitempty"`
TemperatureNotIn []string `json:"temperature_not_in,omitempty"`
TemperatureLt *string `json:"temperature_lt,omitempty"`
TemperatureLte *string `json:"temperature_lte,omitempty"`
TemperatureGt *string `json:"temperature_gt,omitempty"`
TemperatureGte *string `json:"temperature_gte,omitempty"`
TemperatureContains *string `json:"temperature_contains,omitempty"`
TemperatureNotContains *string `json:"temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"temperature_not_ends_with,omitempty"`
And []WeatherHistoryDataScalarWhereInput `json:"AND,omitempty"`
Or []WeatherHistoryDataScalarWhereInput `json:"OR,omitempty"`
Not []WeatherHistoryDataScalarWhereInput `json:"NOT,omitempty"`
          }

      type MacProbeDataCreateManyWithoutMacInput struct {
        Create []MacProbeDataCreateWithoutMacInput `json:"create,omitempty"`
Connect []MacProbeDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpdateManyWithWhereNestedInput struct {
        Where WeatherHistoryDataScalarWhereInput `json:"where"`
Data WeatherHistoryDataUpdateManyDataInput `json:"data"`
          }

      type LocationInfoCreateOneWithoutWifiProbersInput struct {
        Create *LocationInfoCreateWithoutWifiProbersInput `json:"create,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpdateManyDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type WiFiProberinfoCreateManyWithoutLocationInfoInput struct {
        Create []WiFiProberinfoCreateWithoutLocationInfoInput `json:"create,omitempty"`
Connect []WiFiProberinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoUpsertWithoutAirHistoryDatasInput struct {
        Update CityCodeInfoUpdateWithoutAirHistoryDatasDataInput `json:"update"`
Create CityCodeInfoCreateWithoutAirHistoryDatasInput `json:"create"`
          }

      type MaCinfoCreateOneWithoutMacProbeDatasInput struct {
        Create *MaCinfoCreateWithoutMacProbeDatasInput `json:"create,omitempty"`
Connect *MaCinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirHistoryDataUpdateManyMutationInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type IDCardVerifyDataCreateManyWithoutPersonInput struct {
        Create []IDCardVerifyDataCreateWithoutPersonInput `json:"create,omitempty"`
Connect []IDCardVerifyDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type IDCardVerifyDataCreateInput struct {
        ID *string `json:"id,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
Person *PersonInfoCreateOneWithoutIdCardVerifyDatasInput `json:"person,omitempty"`
IDVerifyDevice *IDVerifyDeviceInfoCreateOneWithoutIdCardVerifyDatasInput `json:"idVerifyDevice,omitempty"`
          }

      type LocationInfoCreateOneWithoutIdVerifyDevicesInput struct {
        Create *LocationInfoCreateWithoutIdVerifyDevicesInput `json:"create,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type HistoryDataUpdateManyMutationInput struct {
        RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type WeatherLiveCreateOneWithoutCityInfoInput struct {
        Create *WeatherLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect *WeatherLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirLiveCreateInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoCreateOneWithoutAirLiveInput `json:"cityInfo,omitempty"`
          }

      type WeatherAirLiveSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *WeatherAirLiveWhereInput `json:"node,omitempty"`
And []WeatherAirLiveSubscriptionWhereInput `json:"AND,omitempty"`
Or []WeatherAirLiveSubscriptionWhereInput `json:"OR,omitempty"`
Not []WeatherAirLiveSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type CityCodeInfoCreateOneWithoutAirLiveInput struct {
        Create *CityCodeInfoCreateWithoutAirLiveInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MacProbeDataWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
ProbeTime *string `json:"probeTime,omitempty"`
ProbeTimeNot *string `json:"probeTime_not,omitempty"`
ProbeTimeIn []string `json:"probeTime_in,omitempty"`
ProbeTimeNotIn []string `json:"probeTime_not_in,omitempty"`
ProbeTimeLt *string `json:"probeTime_lt,omitempty"`
ProbeTimeLte *string `json:"probeTime_lte,omitempty"`
ProbeTimeGt *string `json:"probeTime_gt,omitempty"`
ProbeTimeGte *string `json:"probeTime_gte,omitempty"`
ProbeTimeContains *string `json:"probeTime_contains,omitempty"`
ProbeTimeNotContains *string `json:"probeTime_not_contains,omitempty"`
ProbeTimeStartsWith *string `json:"probeTime_starts_with,omitempty"`
ProbeTimeNotStartsWith *string `json:"probeTime_not_starts_with,omitempty"`
ProbeTimeEndsWith *string `json:"probeTime_ends_with,omitempty"`
ProbeTimeNotEndsWith *string `json:"probeTime_not_ends_with,omitempty"`
Mac *MaCinfoWhereInput `json:"mac,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
IsConnetNot *string `json:"isConnet_not,omitempty"`
IsConnetIn []string `json:"isConnet_in,omitempty"`
IsConnetNotIn []string `json:"isConnet_not_in,omitempty"`
IsConnetLt *string `json:"isConnet_lt,omitempty"`
IsConnetLte *string `json:"isConnet_lte,omitempty"`
IsConnetGt *string `json:"isConnet_gt,omitempty"`
IsConnetGte *string `json:"isConnet_gte,omitempty"`
IsConnetContains *string `json:"isConnet_contains,omitempty"`
IsConnetNotContains *string `json:"isConnet_not_contains,omitempty"`
IsConnetStartsWith *string `json:"isConnet_starts_with,omitempty"`
IsConnetNotStartsWith *string `json:"isConnet_not_starts_with,omitempty"`
IsConnetEndsWith *string `json:"isConnet_ends_with,omitempty"`
IsConnetNotEndsWith *string `json:"isConnet_not_ends_with,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterMacNot *string `json:"routerMAC_not,omitempty"`
RouterMacIn []string `json:"routerMAC_in,omitempty"`
RouterMacNotIn []string `json:"routerMAC_not_in,omitempty"`
RouterMacLt *string `json:"routerMAC_lt,omitempty"`
RouterMacLte *string `json:"routerMAC_lte,omitempty"`
RouterMacGt *string `json:"routerMAC_gt,omitempty"`
RouterMacGte *string `json:"routerMAC_gte,omitempty"`
RouterMacContains *string `json:"routerMAC_contains,omitempty"`
RouterMacNotContains *string `json:"routerMAC_not_contains,omitempty"`
RouterMacStartsWith *string `json:"routerMAC_starts_with,omitempty"`
RouterMacNotStartsWith *string `json:"routerMAC_not_starts_with,omitempty"`
RouterMacEndsWith *string `json:"routerMAC_ends_with,omitempty"`
RouterMacNotEndsWith *string `json:"routerMAC_not_ends_with,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
RouterSsidNot *string `json:"routerSSID_not,omitempty"`
RouterSsidIn []string `json:"routerSSID_in,omitempty"`
RouterSsidNotIn []string `json:"routerSSID_not_in,omitempty"`
RouterSsidLt *string `json:"routerSSID_lt,omitempty"`
RouterSsidLte *string `json:"routerSSID_lte,omitempty"`
RouterSsidGt *string `json:"routerSSID_gt,omitempty"`
RouterSsidGte *string `json:"routerSSID_gte,omitempty"`
RouterSsidContains *string `json:"routerSSID_contains,omitempty"`
RouterSsidNotContains *string `json:"routerSSID_not_contains,omitempty"`
RouterSsidStartsWith *string `json:"routerSSID_starts_with,omitempty"`
RouterSsidNotStartsWith *string `json:"routerSSID_not_starts_with,omitempty"`
RouterSsidEndsWith *string `json:"routerSSID_ends_with,omitempty"`
RouterSsidNotEndsWith *string `json:"routerSSID_not_ends_with,omitempty"`
Destance *string `json:"destance,omitempty"`
DestanceNot *string `json:"destance_not,omitempty"`
DestanceIn []string `json:"destance_in,omitempty"`
DestanceNotIn []string `json:"destance_not_in,omitempty"`
DestanceLt *string `json:"destance_lt,omitempty"`
DestanceLte *string `json:"destance_lte,omitempty"`
DestanceGt *string `json:"destance_gt,omitempty"`
DestanceGte *string `json:"destance_gte,omitempty"`
DestanceContains *string `json:"destance_contains,omitempty"`
DestanceNotContains *string `json:"destance_not_contains,omitempty"`
DestanceStartsWith *string `json:"destance_starts_with,omitempty"`
DestanceNotStartsWith *string `json:"destance_not_starts_with,omitempty"`
DestanceEndsWith *string `json:"destance_ends_with,omitempty"`
DestanceNotEndsWith *string `json:"destance_not_ends_with,omitempty"`
WifiProber *WiFiProberinfoWhereInput `json:"wifiProber,omitempty"`
And []MacProbeDataWhereInput `json:"AND,omitempty"`
Or []MacProbeDataWhereInput `json:"OR,omitempty"`
Not []MacProbeDataWhereInput `json:"NOT,omitempty"`
          }

      type CityCodeInfoCreateWithoutAirLiveInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type WeatherAirLiveWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
WindSpeedNot *string `json:"WindSpeed_not,omitempty"`
WindSpeedIn []string `json:"WindSpeed_in,omitempty"`
WindSpeedNotIn []string `json:"WindSpeed_not_in,omitempty"`
WindSpeedLt *string `json:"WindSpeed_lt,omitempty"`
WindSpeedLte *string `json:"WindSpeed_lte,omitempty"`
WindSpeedGt *string `json:"WindSpeed_gt,omitempty"`
WindSpeedGte *string `json:"WindSpeed_gte,omitempty"`
WindSpeedContains *string `json:"WindSpeed_contains,omitempty"`
WindSpeedNotContains *string `json:"WindSpeed_not_contains,omitempty"`
WindSpeedStartsWith *string `json:"WindSpeed_starts_with,omitempty"`
WindSpeedNotStartsWith *string `json:"WindSpeed_not_starts_with,omitempty"`
WindSpeedEndsWith *string `json:"WindSpeed_ends_with,omitempty"`
WindSpeedNotEndsWith *string `json:"WindSpeed_not_ends_with,omitempty"`
CityName *string `json:"CityName,omitempty"`
CityNameNot *string `json:"CityName_not,omitempty"`
CityNameIn []string `json:"CityName_in,omitempty"`
CityNameNotIn []string `json:"CityName_not_in,omitempty"`
CityNameLt *string `json:"CityName_lt,omitempty"`
CityNameLte *string `json:"CityName_lte,omitempty"`
CityNameGt *string `json:"CityName_gt,omitempty"`
CityNameGte *string `json:"CityName_gte,omitempty"`
CityNameContains *string `json:"CityName_contains,omitempty"`
CityNameNotContains *string `json:"CityName_not_contains,omitempty"`
CityNameStartsWith *string `json:"CityName_starts_with,omitempty"`
CityNameNotStartsWith *string `json:"CityName_not_starts_with,omitempty"`
CityNameEndsWith *string `json:"CityName_ends_with,omitempty"`
CityNameNotEndsWith *string `json:"CityName_not_ends_with,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
AirpressureNot *string `json:"Airpressure_not,omitempty"`
AirpressureIn []string `json:"Airpressure_in,omitempty"`
AirpressureNotIn []string `json:"Airpressure_not_in,omitempty"`
AirpressureLt *string `json:"Airpressure_lt,omitempty"`
AirpressureLte *string `json:"Airpressure_lte,omitempty"`
AirpressureGt *string `json:"Airpressure_gt,omitempty"`
AirpressureGte *string `json:"Airpressure_gte,omitempty"`
AirpressureContains *string `json:"Airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"Airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"Airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"Airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"Airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"Airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
PhenomenaNot *string `json:"Phenomena_not,omitempty"`
PhenomenaIn []string `json:"Phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"Phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"Phenomena_lt,omitempty"`
PhenomenaLte *string `json:"Phenomena_lte,omitempty"`
PhenomenaGt *string `json:"Phenomena_gt,omitempty"`
PhenomenaGte *string `json:"Phenomena_gte,omitempty"`
PhenomenaContains *string `json:"Phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"Phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"Phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"Phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"Phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"Phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
RdescNot *string `json:"Rdesc_not,omitempty"`
RdescIn []string `json:"Rdesc_in,omitempty"`
RdescNotIn []string `json:"Rdesc_not_in,omitempty"`
RdescLt *string `json:"Rdesc_lt,omitempty"`
RdescLte *string `json:"Rdesc_lte,omitempty"`
RdescGt *string `json:"Rdesc_gt,omitempty"`
RdescGte *string `json:"Rdesc_gte,omitempty"`
RdescContains *string `json:"Rdesc_contains,omitempty"`
RdescNotContains *string `json:"Rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"Rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"Rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"Rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"Rdesc_not_ends_with,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
HumidityNot *string `json:"Humidity_not,omitempty"`
HumidityIn []string `json:"Humidity_in,omitempty"`
HumidityNotIn []string `json:"Humidity_not_in,omitempty"`
HumidityLt *string `json:"Humidity_lt,omitempty"`
HumidityLte *string `json:"Humidity_lte,omitempty"`
HumidityGt *string `json:"Humidity_gt,omitempty"`
HumidityGte *string `json:"Humidity_gte,omitempty"`
HumidityContains *string `json:"Humidity_contains,omitempty"`
HumidityNotContains *string `json:"Humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"Humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"Humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"Humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"Humidity_not_ends_with,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
UpdatetimeNot *string `json:"Updatetime_not,omitempty"`
UpdatetimeIn []string `json:"Updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"Updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"Updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"Updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"Updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"Updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"Updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"Updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"Updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"Updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"Updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"Updatetime_not_ends_with,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
WindpowerNot *string `json:"Windpower_not,omitempty"`
WindpowerIn []string `json:"Windpower_in,omitempty"`
WindpowerNotIn []string `json:"Windpower_not_in,omitempty"`
WindpowerLt *string `json:"Windpower_lt,omitempty"`
WindpowerLte *string `json:"Windpower_lte,omitempty"`
WindpowerGt *string `json:"Windpower_gt,omitempty"`
WindpowerGte *string `json:"Windpower_gte,omitempty"`
WindpowerContains *string `json:"Windpower_contains,omitempty"`
WindpowerNotContains *string `json:"Windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"Windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"Windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"Windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"Windpower_not_ends_with,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
FeelstNot *string `json:"Feelst_not,omitempty"`
FeelstIn []string `json:"Feelst_in,omitempty"`
FeelstNotIn []string `json:"Feelst_not_in,omitempty"`
FeelstLt *string `json:"Feelst_lt,omitempty"`
FeelstLte *string `json:"Feelst_lte,omitempty"`
FeelstGt *string `json:"Feelst_gt,omitempty"`
FeelstGte *string `json:"Feelst_gte,omitempty"`
FeelstContains *string `json:"Feelst_contains,omitempty"`
FeelstNotContains *string `json:"Feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"Feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"Feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"Feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"Feelst_not_ends_with,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
WinddirectNot *string `json:"Winddirect_not,omitempty"`
WinddirectIn []string `json:"Winddirect_in,omitempty"`
WinddirectNotIn []string `json:"Winddirect_not_in,omitempty"`
WinddirectLt *string `json:"Winddirect_lt,omitempty"`
WinddirectLte *string `json:"Winddirect_lte,omitempty"`
WinddirectGt *string `json:"Winddirect_gt,omitempty"`
WinddirectGte *string `json:"Winddirect_gte,omitempty"`
WinddirectContains *string `json:"Winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"Winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"Winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"Winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"Winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"Winddirect_not_ends_with,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
RcodeNot *int32 `json:"Rcode_not,omitempty"`
RcodeIn []int32 `json:"Rcode_in,omitempty"`
RcodeNotIn []int32 `json:"Rcode_not_in,omitempty"`
RcodeLt *int32 `json:"Rcode_lt,omitempty"`
RcodeLte *int32 `json:"Rcode_lte,omitempty"`
RcodeGt *int32 `json:"Rcode_gt,omitempty"`
RcodeGte *int32 `json:"Rcode_gte,omitempty"`
Rain *string `json:"Rain,omitempty"`
RainNot *string `json:"Rain_not,omitempty"`
RainIn []string `json:"Rain_in,omitempty"`
RainNotIn []string `json:"Rain_not_in,omitempty"`
RainLt *string `json:"Rain_lt,omitempty"`
RainLte *string `json:"Rain_lte,omitempty"`
RainGt *string `json:"Rain_gt,omitempty"`
RainGte *string `json:"Rain_gte,omitempty"`
RainContains *string `json:"Rain_contains,omitempty"`
RainNotContains *string `json:"Rain_not_contains,omitempty"`
RainStartsWith *string `json:"Rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"Rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"Rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"Rain_not_ends_with,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
TemperatureNot *string `json:"Temperature_not,omitempty"`
TemperatureIn []string `json:"Temperature_in,omitempty"`
TemperatureNotIn []string `json:"Temperature_not_in,omitempty"`
TemperatureLt *string `json:"Temperature_lt,omitempty"`
TemperatureLte *string `json:"Temperature_lte,omitempty"`
TemperatureGt *string `json:"Temperature_gt,omitempty"`
TemperatureGte *string `json:"Temperature_gte,omitempty"`
TemperatureContains *string `json:"Temperature_contains,omitempty"`
TemperatureNotContains *string `json:"Temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"Temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"Temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"Temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"Temperature_not_ends_with,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
CitycodeNot *string `json:"Citycode_not,omitempty"`
CitycodeIn []string `json:"Citycode_in,omitempty"`
CitycodeNotIn []string `json:"Citycode_not_in,omitempty"`
CitycodeLt *string `json:"Citycode_lt,omitempty"`
CitycodeLte *string `json:"Citycode_lte,omitempty"`
CitycodeGt *string `json:"Citycode_gt,omitempty"`
CitycodeGte *string `json:"Citycode_gte,omitempty"`
CitycodeContains *string `json:"Citycode_contains,omitempty"`
CitycodeNotContains *string `json:"Citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"Citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"Citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"Citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"Citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"O3,omitempty"`
O3Not *string `json:"O3_not,omitempty"`
O3In []string `json:"O3_in,omitempty"`
O3NotIn []string `json:"O3_not_in,omitempty"`
O3Lt *string `json:"O3_lt,omitempty"`
O3Lte *string `json:"O3_lte,omitempty"`
O3Gt *string `json:"O3_gt,omitempty"`
O3Gte *string `json:"O3_gte,omitempty"`
O3Contains *string `json:"O3_contains,omitempty"`
O3NotContains *string `json:"O3_not_contains,omitempty"`
O3StartsWith *string `json:"O3_starts_with,omitempty"`
O3NotStartsWith *string `json:"O3_not_starts_with,omitempty"`
O3EndsWith *string `json:"O3_ends_with,omitempty"`
O3NotEndsWith *string `json:"O3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"Primary,omitempty"`
PrimaryNot *string `json:"Primary_not,omitempty"`
PrimaryIn []string `json:"Primary_in,omitempty"`
PrimaryNotIn []string `json:"Primary_not_in,omitempty"`
PrimaryLt *string `json:"Primary_lt,omitempty"`
PrimaryLte *string `json:"Primary_lte,omitempty"`
PrimaryGt *string `json:"Primary_gt,omitempty"`
PrimaryGte *string `json:"Primary_gte,omitempty"`
PrimaryContains *string `json:"Primary_contains,omitempty"`
PrimaryNotContains *string `json:"Primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"Primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"Primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"Primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"Primary_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
And []WeatherAirLiveWhereInput `json:"AND,omitempty"`
Or []WeatherAirLiveWhereInput `json:"OR,omitempty"`
Not []WeatherAirLiveWhereInput `json:"NOT,omitempty"`
          }

      type AirHistoryDataCreateManyWithoutCityInfoInput struct {
        Create []AirHistoryDataCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect []AirHistoryDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type HistoryDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *HistoryDataWhereInput `json:"node,omitempty"`
And []HistoryDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []HistoryDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []HistoryDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type AirHistoryDataCreateWithoutCityInfoInput struct {
        ID *string `json:"id,omitempty"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type WiFiProberinfoUpdateInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
LocationInfo *LocationInfoUpdateOneWithoutWifiProbersInput `json:"locationInfo,omitempty"`
MacProbeDatas *MacProbeDataUpdateManyWithoutWifiProberInput `json:"macProbeDatas,omitempty"`
          }

      type AirLiveUpdateInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
CityInfo *CityCodeInfoUpdateOneWithoutAirLiveInput `json:"cityInfo,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutWeatherLiveInput struct {
        Create *CityCodeInfoCreateWithoutWeatherLiveInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutWeatherLiveDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutWeatherLiveInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutAirLiveInput struct {
        Create *CityCodeInfoCreateWithoutAirLiveInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutAirLiveDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutAirLiveInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherHistoryDataUpdateManyMutationInput struct {
        Citycode *string `json:"citycode,omitempty"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
          }

      type CityCodeInfoUpdateWithoutAirLiveDataInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type CityCodeInfoCreateOneWithoutWeatherHistoryDatasInput struct {
        Create *CityCodeInfoCreateWithoutWeatherHistoryDatasInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirHistoryDataUpdateManyWithoutCityInfoInput struct {
        Create []AirHistoryDataCreateWithoutCityInfoInput `json:"create,omitempty"`
Delete []AirHistoryDataWhereUniqueInput `json:"delete,omitempty"`
Connect []AirHistoryDataWhereUniqueInput `json:"connect,omitempty"`
Set []AirHistoryDataWhereUniqueInput `json:"set,omitempty"`
Disconnect []AirHistoryDataWhereUniqueInput `json:"disconnect,omitempty"`
Update []AirHistoryDataUpdateWithWhereUniqueWithoutCityInfoInput `json:"update,omitempty"`
Upsert []AirHistoryDataUpsertWithWhereUniqueWithoutCityInfoInput `json:"upsert,omitempty"`
DeleteMany []AirHistoryDataScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []AirHistoryDataUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutWeatherAirLiveInput struct {
        Create *CityCodeInfoCreateWithoutWeatherAirLiveInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutWeatherAirLiveDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutWeatherAirLiveInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirHistoryDataUpdateWithWhereUniqueWithoutCityInfoInput struct {
        Where AirHistoryDataWhereUniqueInput `json:"where"`
Data AirHistoryDataUpdateWithoutCityInfoDataInput `json:"data"`
          }

      type CityCodeInfoUpsertWithoutWeatherAirHistoryInput struct {
        Update CityCodeInfoUpdateWithoutWeatherAirHistoryDataInput `json:"update"`
Create CityCodeInfoCreateWithoutWeatherAirHistoryInput `json:"create"`
          }

      type AirHistoryDataUpdateWithoutCityInfoDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type CityCodeInfoCreateOneWithoutWeatherAirHistoryInput struct {
        Create *CityCodeInfoCreateWithoutWeatherAirHistoryInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirHistoryDataUpsertWithWhereUniqueWithoutCityInfoInput struct {
        Where AirHistoryDataWhereUniqueInput `json:"where"`
Update AirHistoryDataUpdateWithoutCityInfoDataInput `json:"update"`
Create AirHistoryDataCreateWithoutCityInfoInput `json:"create"`
          }

      type RealTimeDataUpdateInput struct {
        MonitorNode *MonitorNodeUpdateOneRequiredWithoutRealTimeDataInput `json:"monitorNode,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type AirHistoryDataScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Citycode *string `json:"citycode,omitempty"`
CitycodeNot *string `json:"citycode_not,omitempty"`
CitycodeIn []string `json:"citycode_in,omitempty"`
CitycodeNotIn []string `json:"citycode_not_in,omitempty"`
CitycodeLt *string `json:"citycode_lt,omitempty"`
CitycodeLte *string `json:"citycode_lte,omitempty"`
CitycodeGt *string `json:"citycode_gt,omitempty"`
CitycodeGte *string `json:"citycode_gte,omitempty"`
CitycodeContains *string `json:"citycode_contains,omitempty"`
CitycodeNotContains *string `json:"citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Time *string `json:"time,omitempty"`
TimeNot *string `json:"time_not,omitempty"`
TimeIn []string `json:"time_in,omitempty"`
TimeNotIn []string `json:"time_not_in,omitempty"`
TimeLt *string `json:"time_lt,omitempty"`
TimeLte *string `json:"time_lte,omitempty"`
TimeGt *string `json:"time_gt,omitempty"`
TimeGte *string `json:"time_gte,omitempty"`
TimeContains *string `json:"time_contains,omitempty"`
TimeNotContains *string `json:"time_not_contains,omitempty"`
TimeStartsWith *string `json:"time_starts_with,omitempty"`
TimeNotStartsWith *string `json:"time_not_starts_with,omitempty"`
TimeEndsWith *string `json:"time_ends_with,omitempty"`
TimeNotEndsWith *string `json:"time_not_ends_with,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
RdescNot *string `json:"rdesc_not,omitempty"`
RdescIn []string `json:"rdesc_in,omitempty"`
RdescNotIn []string `json:"rdesc_not_in,omitempty"`
RdescLt *string `json:"rdesc_lt,omitempty"`
RdescLte *string `json:"rdesc_lte,omitempty"`
RdescGt *string `json:"rdesc_gt,omitempty"`
RdescGte *string `json:"rdesc_gte,omitempty"`
RdescContains *string `json:"rdesc_contains,omitempty"`
RdescNotContains *string `json:"rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"rdesc_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"o3,omitempty"`
O3Not *string `json:"o3_not,omitempty"`
O3In []string `json:"o3_in,omitempty"`
O3NotIn []string `json:"o3_not_in,omitempty"`
O3Lt *string `json:"o3_lt,omitempty"`
O3Lte *string `json:"o3_lte,omitempty"`
O3Gt *string `json:"o3_gt,omitempty"`
O3Gte *string `json:"o3_gte,omitempty"`
O3Contains *string `json:"o3_contains,omitempty"`
O3NotContains *string `json:"o3_not_contains,omitempty"`
O3StartsWith *string `json:"o3_starts_with,omitempty"`
O3NotStartsWith *string `json:"o3_not_starts_with,omitempty"`
O3EndsWith *string `json:"o3_ends_with,omitempty"`
O3NotEndsWith *string `json:"o3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"primary,omitempty"`
PrimaryNot *string `json:"primary_not,omitempty"`
PrimaryIn []string `json:"primary_in,omitempty"`
PrimaryNotIn []string `json:"primary_not_in,omitempty"`
PrimaryLt *string `json:"primary_lt,omitempty"`
PrimaryLte *string `json:"primary_lte,omitempty"`
PrimaryGt *string `json:"primary_gt,omitempty"`
PrimaryGte *string `json:"primary_gte,omitempty"`
PrimaryContains *string `json:"primary_contains,omitempty"`
PrimaryNotContains *string `json:"primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"primary_not_ends_with,omitempty"`
Rcode *string `json:"rcode,omitempty"`
RcodeNot *string `json:"rcode_not,omitempty"`
RcodeIn []string `json:"rcode_in,omitempty"`
RcodeNotIn []string `json:"rcode_not_in,omitempty"`
RcodeLt *string `json:"rcode_lt,omitempty"`
RcodeLte *string `json:"rcode_lte,omitempty"`
RcodeGt *string `json:"rcode_gt,omitempty"`
RcodeGte *string `json:"rcode_gte,omitempty"`
RcodeContains *string `json:"rcode_contains,omitempty"`
RcodeNotContains *string `json:"rcode_not_contains,omitempty"`
RcodeStartsWith *string `json:"rcode_starts_with,omitempty"`
RcodeNotStartsWith *string `json:"rcode_not_starts_with,omitempty"`
RcodeEndsWith *string `json:"rcode_ends_with,omitempty"`
RcodeNotEndsWith *string `json:"rcode_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
And []AirHistoryDataScalarWhereInput `json:"AND,omitempty"`
Or []AirHistoryDataScalarWhereInput `json:"OR,omitempty"`
Not []AirHistoryDataScalarWhereInput `json:"NOT,omitempty"`
          }

      type WeatherAirHistoryWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
CityName *string `json:"CityName,omitempty"`
          }

      type AirHistoryDataUpdateManyWithWhereNestedInput struct {
        Where AirHistoryDataScalarWhereInput `json:"where"`
Data AirHistoryDataUpdateManyDataInput `json:"data"`
          }

      type MacProbeRecordUpdateManyMutationInput struct {
        Mac *string `json:"mac,omitempty"`
DevNo *string `json:"devNo,omitempty"`
EntryTime *string `json:"entryTime,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
          }

      type AirHistoryDataUpdateManyDataInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type LocationInfoUpdateManyMutationInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
          }

      type CityCodeInfoUpsertWithoutAirLiveInput struct {
        Update CityCodeInfoUpdateWithoutAirLiveDataInput `json:"update"`
Create CityCodeInfoCreateWithoutAirLiveInput `json:"create"`
          }

      type CityCodeInfoCreateOneWithoutAirHistoryDatasInput struct {
        Create *CityCodeInfoCreateWithoutAirHistoryDatasInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirLiveUpdateManyMutationInput struct {
        Citycode *string `json:"citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
          }

      type HistoryDataCreateManyWithoutMonitorNodeInput struct {
        Create []HistoryDataCreateWithoutMonitorNodeInput `json:"create,omitempty"`
Connect []HistoryDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type AttendanceRecordCreateInput struct {
        ID *string `json:"id,omitempty"`
AttDate *string `json:"attDate,omitempty"`
Mac *MaCinfoCreateOneWithoutAttendanceRecordsInput `json:"mac,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type MaCinfoCreateManyWithoutPersonInput struct {
        Create []MaCinfoCreateWithoutPersonInput `json:"create,omitempty"`
Connect []MaCinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MaCinfoCreateOneWithoutAttendanceRecordsInput struct {
        Create *MaCinfoCreateWithoutAttendanceRecordsInput `json:"create,omitempty"`
Connect *MaCinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AttendanceRecordCreateManyWithoutMacInput struct {
        Create []AttendanceRecordCreateWithoutMacInput `json:"create,omitempty"`
Connect []AttendanceRecordWhereUniqueInput `json:"connect,omitempty"`
          }

      type MaCinfoCreateWithoutAttendanceRecordsInput struct {
        ID *string `json:"id,omitempty"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoCreateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataCreateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
          }

      type PersonInfoCreateOneWithoutMacinfosInput struct {
        Create *PersonInfoCreateWithoutMacinfosInput `json:"create,omitempty"`
Connect *PersonInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type AttendanceRecordUpdateInput struct {
        AttDate *string `json:"attDate,omitempty"`
Mac *MaCinfoUpdateOneWithoutAttendanceRecordsInput `json:"mac,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type AirLiveCreateOneWithoutCityInfoInput struct {
        Create *AirLiveCreateWithoutCityInfoInput `json:"create,omitempty"`
Connect *AirLiveWhereUniqueInput `json:"connect,omitempty"`
          }

      type MaCinfoUpdateOneWithoutAttendanceRecordsInput struct {
        Create *MaCinfoCreateWithoutAttendanceRecordsInput `json:"create,omitempty"`
Update *MaCinfoUpdateWithoutAttendanceRecordsDataInput `json:"update,omitempty"`
Upsert *MaCinfoUpsertWithoutAttendanceRecordsInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *MaCinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type RealTimeDataSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *RealTimeDataWhereInput `json:"node,omitempty"`
And []RealTimeDataSubscriptionWhereInput `json:"AND,omitempty"`
Or []RealTimeDataSubscriptionWhereInput `json:"OR,omitempty"`
Not []RealTimeDataSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type MaCinfoUpdateWithoutAttendanceRecordsDataInput struct {
        Mac *string `json:"mac,omitempty"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
Person *PersonInfoUpdateOneWithoutMacinfosInput `json:"person,omitempty"`
IfOnline *int32 `json:"ifOnline,omitempty"`
MacProbeDatas *MacProbeDataUpdateManyWithoutMacInput `json:"macProbeDatas,omitempty"`
          }

      type IDVerifyDeviceInfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *IDVerifyDeviceInfoWhereInput `json:"node,omitempty"`
And []IDVerifyDeviceInfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []IDVerifyDeviceInfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []IDVerifyDeviceInfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type MaCinfoUpsertWithoutAttendanceRecordsInput struct {
        Update MaCinfoUpdateWithoutAttendanceRecordsDataInput `json:"update"`
Create MaCinfoCreateWithoutAttendanceRecordsInput `json:"create"`
          }

      type CityCodeInfoUpsertWithoutWeatherLiveInput struct {
        Update CityCodeInfoUpdateWithoutWeatherLiveDataInput `json:"update"`
Create CityCodeInfoCreateWithoutWeatherLiveInput `json:"create"`
          }

      type AttendanceRecordUpdateManyMutationInput struct {
        AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutWeatherHistoryDatasInput struct {
        Create *CityCodeInfoCreateWithoutWeatherHistoryDatasInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutWeatherHistoryDatasDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutWeatherHistoryDatasInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoCreateInput struct {
        ID *string `json:"id,omitempty"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
LocationInfo *LocationInfoCreateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveCreateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveCreateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveCreateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryCreateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataCreateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataCreateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type CityCodeInfoCreateOneWithoutWeatherAirLiveInput struct {
        Create *CityCodeInfoCreateWithoutWeatherAirLiveInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoUpdateInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
LocationInfo *LocationInfoUpdateOneInput `json:"locationInfo,omitempty"`
AirLive *AirLiveUpdateOneWithoutCityInfoInput `json:"airLive,omitempty"`
WeatherLive *WeatherLiveUpdateOneWithoutCityInfoInput `json:"weatherLive,omitempty"`
WeatherAirLive *WeatherAirLiveUpdateOneWithoutCityInfoInput `json:"weatherAirLive,omitempty"`
WeatherAirHistory *WeatherAirHistoryUpdateManyWithoutCityInfoInput `json:"weatherAirHistory,omitempty"`
AirHistoryDatas *AirHistoryDataUpdateManyWithoutCityInfoInput `json:"airHistoryDatas,omitempty"`
WeatherHistoryDatas *WeatherHistoryDataUpdateManyWithoutCityInfoInput `json:"weatherHistoryDatas,omitempty"`
          }

      type MonitorNodeUpsertWithoutRealTimeDataInput struct {
        Update MonitorNodeUpdateWithoutRealTimeDataDataInput `json:"update"`
Create MonitorNodeCreateWithoutRealTimeDataInput `json:"create"`
          }

      type CityCodeInfoUpdateManyMutationInput struct {
        AirCitycode *string `json:"airCitycode,omitempty"`
WeatherCityCode *string `json:"weatherCityCode,omitempty"`
CityName *string `json:"cityName,omitempty"`
          }

      type WeatherAirLiveWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
CityName *string `json:"CityName,omitempty"`
          }

      type DataUnitCreateInput struct {
        ID *string `json:"id,omitempty"`
DataItem string `json:"dataItem"`
Unit string `json:"unit"`
          }

      type IDVerifyDeviceInfoUpdateInput struct {
        DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
LocationInfo *LocationInfoUpdateOneWithoutIdVerifyDevicesInput `json:"locationInfo,omitempty"`
IDCardVerifyDatas *IDCardVerifyDataUpdateManyWithoutIdVerifyDeviceInput `json:"idCardVerifyDatas,omitempty"`
          }

      type DataUnitUpdateInput struct {
        DataItem *string `json:"dataItem,omitempty"`
Unit *string `json:"unit,omitempty"`
          }

      type IDCardVerifyDataCreateManyWithoutIdVerifyDeviceInput struct {
        Create []IDCardVerifyDataCreateWithoutIdVerifyDeviceInput `json:"create,omitempty"`
Connect []IDCardVerifyDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type DataUnitUpdateManyMutationInput struct {
        DataItem *string `json:"dataItem,omitempty"`
Unit *string `json:"unit,omitempty"`
          }

      type MacProbeDataCreateManyWithoutWifiProberInput struct {
        Create []MacProbeDataCreateWithoutWifiProberInput `json:"create,omitempty"`
Connect []MacProbeDataWhereUniqueInput `json:"connect,omitempty"`
          }

      type HistoryDataCreateInput struct {
        ID *string `json:"id,omitempty"`
MonitorNode MonitorNodeCreateOneWithoutHistoryDatasInput `json:"monitorNode"`
RcvTime string `json:"rcvTime"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type WiFiProberinfoSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *WiFiProberinfoWhereInput `json:"node,omitempty"`
And []WiFiProberinfoSubscriptionWhereInput `json:"AND,omitempty"`
Or []WiFiProberinfoSubscriptionWhereInput `json:"OR,omitempty"`
Not []WiFiProberinfoSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeCreateOneWithoutHistoryDatasInput struct {
        Create *MonitorNodeCreateWithoutHistoryDatasInput `json:"create,omitempty"`
Connect *MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
          }

      type AirLiveSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *AirLiveWhereInput `json:"node,omitempty"`
And []AirLiveSubscriptionWhereInput `json:"AND,omitempty"`
Or []AirLiveSubscriptionWhereInput `json:"OR,omitempty"`
Not []AirLiveSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type MonitorNodeCreateWithoutHistoryDatasInput struct {
        ID *string `json:"id,omitempty"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
Location *LocationInfoCreateOneWithoutMonitorNodesInput `json:"location,omitempty"`
RealTimeData *RealTimeDataCreateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
          }

      type CityCodeInfoUpsertWithoutWeatherAirLiveInput struct {
        Update CityCodeInfoUpdateWithoutWeatherAirLiveDataInput `json:"update"`
Create CityCodeInfoCreateWithoutWeatherAirLiveInput `json:"create"`
          }

      type LocationInfoCreateOneWithoutMonitorNodesInput struct {
        Create *LocationInfoCreateWithoutMonitorNodesInput `json:"create,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type RealTimeDataCreateInput struct {
        ID *string `json:"id,omitempty"`
MonitorNode MonitorNodeCreateOneWithoutRealTimeDataInput `json:"monitorNode"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type LocationInfoCreateWithoutMonitorNodesInput struct {
        ID *string `json:"id,omitempty"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoCreateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
WifiProbers *WiFiProberinfoCreateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type MonitorNodeCreateManyWithoutLocationInput struct {
        Create []MonitorNodeCreateWithoutLocationInput `json:"create,omitempty"`
Connect []MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
          }

      type HistoryDataUpdateInput struct {
        MonitorNode *MonitorNodeUpdateOneRequiredWithoutHistoryDatasInput `json:"monitorNode,omitempty"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
          }

      type IDVerifyDeviceInfoCreateOneWithoutIdCardVerifyDatasInput struct {
        Create *IDVerifyDeviceInfoCreateWithoutIdCardVerifyDatasInput `json:"create,omitempty"`
Connect *IDVerifyDeviceInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MonitorNodeUpdateOneRequiredWithoutHistoryDatasInput struct {
        Create *MonitorNodeCreateWithoutHistoryDatasInput `json:"create,omitempty"`
Update *MonitorNodeUpdateWithoutHistoryDatasDataInput `json:"update,omitempty"`
Upsert *MonitorNodeUpsertWithoutHistoryDatasInput `json:"upsert,omitempty"`
Connect *MonitorNodeWhereUniqueInput `json:"connect,omitempty"`
          }

      type CityCodeInfoCreateOneWithoutWeatherLiveInput struct {
        Create *CityCodeInfoCreateWithoutWeatherLiveInput `json:"create,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type LocationInfoUpsertWithoutMonitorNodesInput struct {
        Update LocationInfoUpdateWithoutMonitorNodesDataInput `json:"update"`
Create LocationInfoCreateWithoutMonitorNodesInput `json:"create"`
          }

      type LocationInfoUpdateWithoutMonitorNodesDataInput struct {
        Describe *string `json:"describe,omitempty"`
Longitude *float64 `json:"longitude,omitempty"`
Latitude *float64 `json:"latitude,omitempty"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
IDVerifyDevices *IDVerifyDeviceInfoUpdateManyWithoutLocationInfoInput `json:"idVerifyDevices,omitempty"`
WifiProbers *WiFiProberinfoUpdateManyWithoutLocationInfoInput `json:"wifiProbers,omitempty"`
          }

      type LocationInfoUpdateOneWithoutMonitorNodesInput struct {
        Create *LocationInfoCreateWithoutMonitorNodesInput `json:"create,omitempty"`
Update *LocationInfoUpdateWithoutMonitorNodesDataInput `json:"update,omitempty"`
Upsert *LocationInfoUpsertWithoutMonitorNodesInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *LocationInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MonitorNodeUpdateWithoutHistoryDatasDataInput struct {
        MonitorSn *string `json:"monitorSN,omitempty"`
MonitorName *string `json:"monitorName,omitempty"`
MonitorType *string `json:"monitorType,omitempty"`
MonitorStatus *string `json:"monitorStatus,omitempty"`
Location *LocationInfoUpdateOneWithoutMonitorNodesInput `json:"location,omitempty"`
RealTimeData *RealTimeDataUpdateOneWithoutMonitorNodeInput `json:"realTimeData,omitempty"`
          }

      type CityCodeInfoUpdateOneWithoutWeatherAirHistoryInput struct {
        Create *CityCodeInfoCreateWithoutWeatherAirHistoryInput `json:"create,omitempty"`
Update *CityCodeInfoUpdateWithoutWeatherAirHistoryDataInput `json:"update,omitempty"`
Upsert *CityCodeInfoUpsertWithoutWeatherAirHistoryInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *CityCodeInfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type WeatherAirHistoryWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
WindSpeed *string `json:"WindSpeed,omitempty"`
WindSpeedNot *string `json:"WindSpeed_not,omitempty"`
WindSpeedIn []string `json:"WindSpeed_in,omitempty"`
WindSpeedNotIn []string `json:"WindSpeed_not_in,omitempty"`
WindSpeedLt *string `json:"WindSpeed_lt,omitempty"`
WindSpeedLte *string `json:"WindSpeed_lte,omitempty"`
WindSpeedGt *string `json:"WindSpeed_gt,omitempty"`
WindSpeedGte *string `json:"WindSpeed_gte,omitempty"`
WindSpeedContains *string `json:"WindSpeed_contains,omitempty"`
WindSpeedNotContains *string `json:"WindSpeed_not_contains,omitempty"`
WindSpeedStartsWith *string `json:"WindSpeed_starts_with,omitempty"`
WindSpeedNotStartsWith *string `json:"WindSpeed_not_starts_with,omitempty"`
WindSpeedEndsWith *string `json:"WindSpeed_ends_with,omitempty"`
WindSpeedNotEndsWith *string `json:"WindSpeed_not_ends_with,omitempty"`
CityName *string `json:"CityName,omitempty"`
CityNameNot *string `json:"CityName_not,omitempty"`
CityNameIn []string `json:"CityName_in,omitempty"`
CityNameNotIn []string `json:"CityName_not_in,omitempty"`
CityNameLt *string `json:"CityName_lt,omitempty"`
CityNameLte *string `json:"CityName_lte,omitempty"`
CityNameGt *string `json:"CityName_gt,omitempty"`
CityNameGte *string `json:"CityName_gte,omitempty"`
CityNameContains *string `json:"CityName_contains,omitempty"`
CityNameNotContains *string `json:"CityName_not_contains,omitempty"`
CityNameStartsWith *string `json:"CityName_starts_with,omitempty"`
CityNameNotStartsWith *string `json:"CityName_not_starts_with,omitempty"`
CityNameEndsWith *string `json:"CityName_ends_with,omitempty"`
CityNameNotEndsWith *string `json:"CityName_not_ends_with,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
AirpressureNot *string `json:"Airpressure_not,omitempty"`
AirpressureIn []string `json:"Airpressure_in,omitempty"`
AirpressureNotIn []string `json:"Airpressure_not_in,omitempty"`
AirpressureLt *string `json:"Airpressure_lt,omitempty"`
AirpressureLte *string `json:"Airpressure_lte,omitempty"`
AirpressureGt *string `json:"Airpressure_gt,omitempty"`
AirpressureGte *string `json:"Airpressure_gte,omitempty"`
AirpressureContains *string `json:"Airpressure_contains,omitempty"`
AirpressureNotContains *string `json:"Airpressure_not_contains,omitempty"`
AirpressureStartsWith *string `json:"Airpressure_starts_with,omitempty"`
AirpressureNotStartsWith *string `json:"Airpressure_not_starts_with,omitempty"`
AirpressureEndsWith *string `json:"Airpressure_ends_with,omitempty"`
AirpressureNotEndsWith *string `json:"Airpressure_not_ends_with,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
PhenomenaNot *string `json:"Phenomena_not,omitempty"`
PhenomenaIn []string `json:"Phenomena_in,omitempty"`
PhenomenaNotIn []string `json:"Phenomena_not_in,omitempty"`
PhenomenaLt *string `json:"Phenomena_lt,omitempty"`
PhenomenaLte *string `json:"Phenomena_lte,omitempty"`
PhenomenaGt *string `json:"Phenomena_gt,omitempty"`
PhenomenaGte *string `json:"Phenomena_gte,omitempty"`
PhenomenaContains *string `json:"Phenomena_contains,omitempty"`
PhenomenaNotContains *string `json:"Phenomena_not_contains,omitempty"`
PhenomenaStartsWith *string `json:"Phenomena_starts_with,omitempty"`
PhenomenaNotStartsWith *string `json:"Phenomena_not_starts_with,omitempty"`
PhenomenaEndsWith *string `json:"Phenomena_ends_with,omitempty"`
PhenomenaNotEndsWith *string `json:"Phenomena_not_ends_with,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
RdescNot *string `json:"Rdesc_not,omitempty"`
RdescIn []string `json:"Rdesc_in,omitempty"`
RdescNotIn []string `json:"Rdesc_not_in,omitempty"`
RdescLt *string `json:"Rdesc_lt,omitempty"`
RdescLte *string `json:"Rdesc_lte,omitempty"`
RdescGt *string `json:"Rdesc_gt,omitempty"`
RdescGte *string `json:"Rdesc_gte,omitempty"`
RdescContains *string `json:"Rdesc_contains,omitempty"`
RdescNotContains *string `json:"Rdesc_not_contains,omitempty"`
RdescStartsWith *string `json:"Rdesc_starts_with,omitempty"`
RdescNotStartsWith *string `json:"Rdesc_not_starts_with,omitempty"`
RdescEndsWith *string `json:"Rdesc_ends_with,omitempty"`
RdescNotEndsWith *string `json:"Rdesc_not_ends_with,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
HumidityNot *string `json:"Humidity_not,omitempty"`
HumidityIn []string `json:"Humidity_in,omitempty"`
HumidityNotIn []string `json:"Humidity_not_in,omitempty"`
HumidityLt *string `json:"Humidity_lt,omitempty"`
HumidityLte *string `json:"Humidity_lte,omitempty"`
HumidityGt *string `json:"Humidity_gt,omitempty"`
HumidityGte *string `json:"Humidity_gte,omitempty"`
HumidityContains *string `json:"Humidity_contains,omitempty"`
HumidityNotContains *string `json:"Humidity_not_contains,omitempty"`
HumidityStartsWith *string `json:"Humidity_starts_with,omitempty"`
HumidityNotStartsWith *string `json:"Humidity_not_starts_with,omitempty"`
HumidityEndsWith *string `json:"Humidity_ends_with,omitempty"`
HumidityNotEndsWith *string `json:"Humidity_not_ends_with,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
UpdatetimeNot *string `json:"Updatetime_not,omitempty"`
UpdatetimeIn []string `json:"Updatetime_in,omitempty"`
UpdatetimeNotIn []string `json:"Updatetime_not_in,omitempty"`
UpdatetimeLt *string `json:"Updatetime_lt,omitempty"`
UpdatetimeLte *string `json:"Updatetime_lte,omitempty"`
UpdatetimeGt *string `json:"Updatetime_gt,omitempty"`
UpdatetimeGte *string `json:"Updatetime_gte,omitempty"`
UpdatetimeContains *string `json:"Updatetime_contains,omitempty"`
UpdatetimeNotContains *string `json:"Updatetime_not_contains,omitempty"`
UpdatetimeStartsWith *string `json:"Updatetime_starts_with,omitempty"`
UpdatetimeNotStartsWith *string `json:"Updatetime_not_starts_with,omitempty"`
UpdatetimeEndsWith *string `json:"Updatetime_ends_with,omitempty"`
UpdatetimeNotEndsWith *string `json:"Updatetime_not_ends_with,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
WindpowerNot *string `json:"Windpower_not,omitempty"`
WindpowerIn []string `json:"Windpower_in,omitempty"`
WindpowerNotIn []string `json:"Windpower_not_in,omitempty"`
WindpowerLt *string `json:"Windpower_lt,omitempty"`
WindpowerLte *string `json:"Windpower_lte,omitempty"`
WindpowerGt *string `json:"Windpower_gt,omitempty"`
WindpowerGte *string `json:"Windpower_gte,omitempty"`
WindpowerContains *string `json:"Windpower_contains,omitempty"`
WindpowerNotContains *string `json:"Windpower_not_contains,omitempty"`
WindpowerStartsWith *string `json:"Windpower_starts_with,omitempty"`
WindpowerNotStartsWith *string `json:"Windpower_not_starts_with,omitempty"`
WindpowerEndsWith *string `json:"Windpower_ends_with,omitempty"`
WindpowerNotEndsWith *string `json:"Windpower_not_ends_with,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
FeelstNot *string `json:"Feelst_not,omitempty"`
FeelstIn []string `json:"Feelst_in,omitempty"`
FeelstNotIn []string `json:"Feelst_not_in,omitempty"`
FeelstLt *string `json:"Feelst_lt,omitempty"`
FeelstLte *string `json:"Feelst_lte,omitempty"`
FeelstGt *string `json:"Feelst_gt,omitempty"`
FeelstGte *string `json:"Feelst_gte,omitempty"`
FeelstContains *string `json:"Feelst_contains,omitempty"`
FeelstNotContains *string `json:"Feelst_not_contains,omitempty"`
FeelstStartsWith *string `json:"Feelst_starts_with,omitempty"`
FeelstNotStartsWith *string `json:"Feelst_not_starts_with,omitempty"`
FeelstEndsWith *string `json:"Feelst_ends_with,omitempty"`
FeelstNotEndsWith *string `json:"Feelst_not_ends_with,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
WinddirectNot *string `json:"Winddirect_not,omitempty"`
WinddirectIn []string `json:"Winddirect_in,omitempty"`
WinddirectNotIn []string `json:"Winddirect_not_in,omitempty"`
WinddirectLt *string `json:"Winddirect_lt,omitempty"`
WinddirectLte *string `json:"Winddirect_lte,omitempty"`
WinddirectGt *string `json:"Winddirect_gt,omitempty"`
WinddirectGte *string `json:"Winddirect_gte,omitempty"`
WinddirectContains *string `json:"Winddirect_contains,omitempty"`
WinddirectNotContains *string `json:"Winddirect_not_contains,omitempty"`
WinddirectStartsWith *string `json:"Winddirect_starts_with,omitempty"`
WinddirectNotStartsWith *string `json:"Winddirect_not_starts_with,omitempty"`
WinddirectEndsWith *string `json:"Winddirect_ends_with,omitempty"`
WinddirectNotEndsWith *string `json:"Winddirect_not_ends_with,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
RcodeNot *int32 `json:"Rcode_not,omitempty"`
RcodeIn []int32 `json:"Rcode_in,omitempty"`
RcodeNotIn []int32 `json:"Rcode_not_in,omitempty"`
RcodeLt *int32 `json:"Rcode_lt,omitempty"`
RcodeLte *int32 `json:"Rcode_lte,omitempty"`
RcodeGt *int32 `json:"Rcode_gt,omitempty"`
RcodeGte *int32 `json:"Rcode_gte,omitempty"`
Rain *string `json:"Rain,omitempty"`
RainNot *string `json:"Rain_not,omitempty"`
RainIn []string `json:"Rain_in,omitempty"`
RainNotIn []string `json:"Rain_not_in,omitempty"`
RainLt *string `json:"Rain_lt,omitempty"`
RainLte *string `json:"Rain_lte,omitempty"`
RainGt *string `json:"Rain_gt,omitempty"`
RainGte *string `json:"Rain_gte,omitempty"`
RainContains *string `json:"Rain_contains,omitempty"`
RainNotContains *string `json:"Rain_not_contains,omitempty"`
RainStartsWith *string `json:"Rain_starts_with,omitempty"`
RainNotStartsWith *string `json:"Rain_not_starts_with,omitempty"`
RainEndsWith *string `json:"Rain_ends_with,omitempty"`
RainNotEndsWith *string `json:"Rain_not_ends_with,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
TemperatureNot *string `json:"Temperature_not,omitempty"`
TemperatureIn []string `json:"Temperature_in,omitempty"`
TemperatureNotIn []string `json:"Temperature_not_in,omitempty"`
TemperatureLt *string `json:"Temperature_lt,omitempty"`
TemperatureLte *string `json:"Temperature_lte,omitempty"`
TemperatureGt *string `json:"Temperature_gt,omitempty"`
TemperatureGte *string `json:"Temperature_gte,omitempty"`
TemperatureContains *string `json:"Temperature_contains,omitempty"`
TemperatureNotContains *string `json:"Temperature_not_contains,omitempty"`
TemperatureStartsWith *string `json:"Temperature_starts_with,omitempty"`
TemperatureNotStartsWith *string `json:"Temperature_not_starts_with,omitempty"`
TemperatureEndsWith *string `json:"Temperature_ends_with,omitempty"`
TemperatureNotEndsWith *string `json:"Temperature_not_ends_with,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
CitycodeNot *string `json:"Citycode_not,omitempty"`
CitycodeIn []string `json:"Citycode_in,omitempty"`
CitycodeNotIn []string `json:"Citycode_not_in,omitempty"`
CitycodeLt *string `json:"Citycode_lt,omitempty"`
CitycodeLte *string `json:"Citycode_lte,omitempty"`
CitycodeGt *string `json:"Citycode_gt,omitempty"`
CitycodeGte *string `json:"Citycode_gte,omitempty"`
CitycodeContains *string `json:"Citycode_contains,omitempty"`
CitycodeNotContains *string `json:"Citycode_not_contains,omitempty"`
CitycodeStartsWith *string `json:"Citycode_starts_with,omitempty"`
CitycodeNotStartsWith *string `json:"Citycode_not_starts_with,omitempty"`
CitycodeEndsWith *string `json:"Citycode_ends_with,omitempty"`
CitycodeNotEndsWith *string `json:"Citycode_not_ends_with,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm25Not *string `json:"PM25_not,omitempty"`
Pm25In []string `json:"PM25_in,omitempty"`
Pm25NotIn []string `json:"PM25_not_in,omitempty"`
Pm25Lt *string `json:"PM25_lt,omitempty"`
Pm25Lte *string `json:"PM25_lte,omitempty"`
Pm25Gt *string `json:"PM25_gt,omitempty"`
Pm25Gte *string `json:"PM25_gte,omitempty"`
Pm25Contains *string `json:"PM25_contains,omitempty"`
Pm25NotContains *string `json:"PM25_not_contains,omitempty"`
Pm25StartsWith *string `json:"PM25_starts_with,omitempty"`
Pm25NotStartsWith *string `json:"PM25_not_starts_with,omitempty"`
Pm25EndsWith *string `json:"PM25_ends_with,omitempty"`
Pm25NotEndsWith *string `json:"PM25_not_ends_with,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
Pm10Not *string `json:"PM10_not,omitempty"`
Pm10In []string `json:"PM10_in,omitempty"`
Pm10NotIn []string `json:"PM10_not_in,omitempty"`
Pm10Lt *string `json:"PM10_lt,omitempty"`
Pm10Lte *string `json:"PM10_lte,omitempty"`
Pm10Gt *string `json:"PM10_gt,omitempty"`
Pm10Gte *string `json:"PM10_gte,omitempty"`
Pm10Contains *string `json:"PM10_contains,omitempty"`
Pm10NotContains *string `json:"PM10_not_contains,omitempty"`
Pm10StartsWith *string `json:"PM10_starts_with,omitempty"`
Pm10NotStartsWith *string `json:"PM10_not_starts_with,omitempty"`
Pm10EndsWith *string `json:"PM10_ends_with,omitempty"`
Pm10NotEndsWith *string `json:"PM10_not_ends_with,omitempty"`
So2 *string `json:"SO2,omitempty"`
So2Not *string `json:"SO2_not,omitempty"`
So2In []string `json:"SO2_in,omitempty"`
So2NotIn []string `json:"SO2_not_in,omitempty"`
So2Lt *string `json:"SO2_lt,omitempty"`
So2Lte *string `json:"SO2_lte,omitempty"`
So2Gt *string `json:"SO2_gt,omitempty"`
So2Gte *string `json:"SO2_gte,omitempty"`
So2Contains *string `json:"SO2_contains,omitempty"`
So2NotContains *string `json:"SO2_not_contains,omitempty"`
So2StartsWith *string `json:"SO2_starts_with,omitempty"`
So2NotStartsWith *string `json:"SO2_not_starts_with,omitempty"`
So2EndsWith *string `json:"SO2_ends_with,omitempty"`
So2NotEndsWith *string `json:"SO2_not_ends_with,omitempty"`
O3 *string `json:"O3,omitempty"`
O3Not *string `json:"O3_not,omitempty"`
O3In []string `json:"O3_in,omitempty"`
O3NotIn []string `json:"O3_not_in,omitempty"`
O3Lt *string `json:"O3_lt,omitempty"`
O3Lte *string `json:"O3_lte,omitempty"`
O3Gt *string `json:"O3_gt,omitempty"`
O3Gte *string `json:"O3_gte,omitempty"`
O3Contains *string `json:"O3_contains,omitempty"`
O3NotContains *string `json:"O3_not_contains,omitempty"`
O3StartsWith *string `json:"O3_starts_with,omitempty"`
O3NotStartsWith *string `json:"O3_not_starts_with,omitempty"`
O3EndsWith *string `json:"O3_ends_with,omitempty"`
O3NotEndsWith *string `json:"O3_not_ends_with,omitempty"`
No2 *string `json:"NO2,omitempty"`
No2Not *string `json:"NO2_not,omitempty"`
No2In []string `json:"NO2_in,omitempty"`
No2NotIn []string `json:"NO2_not_in,omitempty"`
No2Lt *string `json:"NO2_lt,omitempty"`
No2Lte *string `json:"NO2_lte,omitempty"`
No2Gt *string `json:"NO2_gt,omitempty"`
No2Gte *string `json:"NO2_gte,omitempty"`
No2Contains *string `json:"NO2_contains,omitempty"`
No2NotContains *string `json:"NO2_not_contains,omitempty"`
No2StartsWith *string `json:"NO2_starts_with,omitempty"`
No2NotStartsWith *string `json:"NO2_not_starts_with,omitempty"`
No2EndsWith *string `json:"NO2_ends_with,omitempty"`
No2NotEndsWith *string `json:"NO2_not_ends_with,omitempty"`
Primary *string `json:"Primary,omitempty"`
PrimaryNot *string `json:"Primary_not,omitempty"`
PrimaryIn []string `json:"Primary_in,omitempty"`
PrimaryNotIn []string `json:"Primary_not_in,omitempty"`
PrimaryLt *string `json:"Primary_lt,omitempty"`
PrimaryLte *string `json:"Primary_lte,omitempty"`
PrimaryGt *string `json:"Primary_gt,omitempty"`
PrimaryGte *string `json:"Primary_gte,omitempty"`
PrimaryContains *string `json:"Primary_contains,omitempty"`
PrimaryNotContains *string `json:"Primary_not_contains,omitempty"`
PrimaryStartsWith *string `json:"Primary_starts_with,omitempty"`
PrimaryNotStartsWith *string `json:"Primary_not_starts_with,omitempty"`
PrimaryEndsWith *string `json:"Primary_ends_with,omitempty"`
PrimaryNotEndsWith *string `json:"Primary_not_ends_with,omitempty"`
Co *string `json:"CO,omitempty"`
CoNot *string `json:"CO_not,omitempty"`
CoIn []string `json:"CO_in,omitempty"`
CoNotIn []string `json:"CO_not_in,omitempty"`
CoLt *string `json:"CO_lt,omitempty"`
CoLte *string `json:"CO_lte,omitempty"`
CoGt *string `json:"CO_gt,omitempty"`
CoGte *string `json:"CO_gte,omitempty"`
CoContains *string `json:"CO_contains,omitempty"`
CoNotContains *string `json:"CO_not_contains,omitempty"`
CoStartsWith *string `json:"CO_starts_with,omitempty"`
CoNotStartsWith *string `json:"CO_not_starts_with,omitempty"`
CoEndsWith *string `json:"CO_ends_with,omitempty"`
CoNotEndsWith *string `json:"CO_not_ends_with,omitempty"`
Aqi *string `json:"AQI,omitempty"`
AqiNot *string `json:"AQI_not,omitempty"`
AqiIn []string `json:"AQI_in,omitempty"`
AqiNotIn []string `json:"AQI_not_in,omitempty"`
AqiLt *string `json:"AQI_lt,omitempty"`
AqiLte *string `json:"AQI_lte,omitempty"`
AqiGt *string `json:"AQI_gt,omitempty"`
AqiGte *string `json:"AQI_gte,omitempty"`
AqiContains *string `json:"AQI_contains,omitempty"`
AqiNotContains *string `json:"AQI_not_contains,omitempty"`
AqiStartsWith *string `json:"AQI_starts_with,omitempty"`
AqiNotStartsWith *string `json:"AQI_not_starts_with,omitempty"`
AqiEndsWith *string `json:"AQI_ends_with,omitempty"`
AqiNotEndsWith *string `json:"AQI_not_ends_with,omitempty"`
CityInfo *CityCodeInfoWhereInput `json:"cityInfo,omitempty"`
And []WeatherAirHistoryWhereInput `json:"AND,omitempty"`
Or []WeatherAirHistoryWhereInput `json:"OR,omitempty"`
Not []WeatherAirHistoryWhereInput `json:"NOT,omitempty"`
          }

      type WiFiProberinfoCreateOneWithoutMacProbeDatasInput struct {
        Create *WiFiProberinfoCreateWithoutMacProbeDatasInput `json:"create,omitempty"`
Connect *WiFiProberinfoWhereUniqueInput `json:"connect,omitempty"`
          }

      type MacProbeDataUpdateManyMutationInput struct {
        ProbeTime *string `json:"probeTime,omitempty"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
          }


        type WiFiProberinfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance WiFiProberinfoPreviousValuesExec) Exec(ctx context.Context) (*WiFiProberinfoPreviousValues, error) {
            var v WiFiProberinfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WiFiProberinfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WiFiProberinfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance WiFiProberinfoPreviousValuesExecArray) Exec(ctx context.Context) ([]WiFiProberinfoPreviousValues, error) {
            var v []WiFiProberinfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WiFiProberinfoPreviousValues struct {
          ID string `json:"id"`
DevNo string `json:"devNo"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
        }


        type RealTimeDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RealTimeDataExec) MonitorNode() *MonitorNodeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNode"},
                    "monitorNode",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodeExec{ret}
                }

          func (instance RealTimeDataExec) Exec(ctx context.Context) (*RealTimeData, error) {
            var v RealTimeData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RealTimeDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RealTimeDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance RealTimeDataExecArray) Exec(ctx context.Context) ([]RealTimeData, error) {
            var v []RealTimeData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RealTimeData struct {
          ID string `json:"id"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
UpdatedAt string `json:"updatedAt"`
        }

        type AirLiveEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirLiveEdgeExec) Node() *AirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirLive"},
                    "node",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirLiveExec{ret}
                }

          func (instance AirLiveEdgeExec) Exec(ctx context.Context) (*AirLiveEdge, error) {
            var v AirLiveEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirLiveEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirLiveEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirLiveEdgeExecArray) Exec(ctx context.Context) ([]AirLiveEdge, error) {
            var v []AirLiveEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirLiveEdge struct {
          Cursor string `json:"cursor"`
        }

        type HistoryDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *HistoryDataExec) MonitorNode() *MonitorNodeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNode"},
                    "monitorNode",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodeExec{ret}
                }

          func (instance HistoryDataExec) Exec(ctx context.Context) (*HistoryData, error) {
            var v HistoryData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance HistoryDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type HistoryDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance HistoryDataExecArray) Exec(ctx context.Context) ([]HistoryData, error) {
            var v []HistoryData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type HistoryData struct {
          ID string `json:"id"`
RcvTime string `json:"rcvTime"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
CreatedAt string `json:"createdAt"`
        }

        type AirLiveConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirLiveConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *AirLiveConnectionExec) Edges() *AirLiveEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirLiveEdge"},
                    "edges",
                    []string{"cursor"})

                  return &AirLiveEdgeExec{ret}
                }

                  func (instance *AirLiveConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateAirLive"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance AirLiveConnectionExec) Exec(ctx context.Context) (*AirLiveConnection, error) {
            var v AirLiveConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirLiveConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirLiveConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirLiveConnectionExecArray) Exec(ctx context.Context) ([]AirLiveConnection, error) {
            var v []AirLiveConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirLiveConnection struct {
          
        }



        type WeatherHistoryDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance WeatherHistoryDataPreviousValuesExec) Exec(ctx context.Context) (*WeatherHistoryDataPreviousValues, error) {
            var v WeatherHistoryDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherHistoryDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherHistoryDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherHistoryDataPreviousValuesExecArray) Exec(ctx context.Context) ([]WeatherHistoryDataPreviousValues, error) {
            var v []WeatherHistoryDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherHistoryDataPreviousValues struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
UpdatedAt string `json:"updatedAt"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
        }

        type WeatherLivePreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance WeatherLivePreviousValuesExec) Exec(ctx context.Context) (*WeatherLivePreviousValues, error) {
            var v WeatherLivePreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherLivePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherLivePreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherLivePreviousValuesExecArray) Exec(ctx context.Context) ([]WeatherLivePreviousValues, error) {
            var v []WeatherLivePreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherLivePreviousValues struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
UpdatedAt string `json:"updatedAt"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
        }

        type WiFiProberinfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WiFiProberinfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *WiFiProberinfoConnectionExec) Edges() *WiFiProberinfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WiFiProberinfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &WiFiProberinfoEdgeExec{ret}
                }

                  func (instance *WiFiProberinfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateWiFiProberinfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance WiFiProberinfoConnectionExec) Exec(ctx context.Context) (*WiFiProberinfoConnection, error) {
            var v WiFiProberinfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WiFiProberinfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WiFiProberinfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance WiFiProberinfoConnectionExecArray) Exec(ctx context.Context) ([]WiFiProberinfoConnection, error) {
            var v []WiFiProberinfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WiFiProberinfoConnection struct {
          
        }

        type WiFiProberinfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WiFiProberinfoEdgeExec) Node() *WiFiProberinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WiFiProberinfo"},
                    "node",
                    []string{"id","devNo","devMac","devMdoel"})

                  return &WiFiProberinfoExec{ret}
                }

          func (instance WiFiProberinfoEdgeExec) Exec(ctx context.Context) (*WiFiProberinfoEdge, error) {
            var v WiFiProberinfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WiFiProberinfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WiFiProberinfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance WiFiProberinfoEdgeExecArray) Exec(ctx context.Context) ([]WiFiProberinfoEdge, error) {
            var v []WiFiProberinfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WiFiProberinfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type WeatherLiveConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherLiveConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *WeatherLiveConnectionExec) Edges() *WeatherLiveEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherLiveEdge"},
                    "edges",
                    []string{"cursor"})

                  return &WeatherLiveEdgeExec{ret}
                }

                  func (instance *WeatherLiveConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateWeatherLive"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance WeatherLiveConnectionExec) Exec(ctx context.Context) (*WeatherLiveConnection, error) {
            var v WeatherLiveConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherLiveConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherLiveConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherLiveConnectionExecArray) Exec(ctx context.Context) ([]WeatherLiveConnection, error) {
            var v []WeatherLiveConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherLiveConnection struct {
          
        }



        type AirHistoryDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirHistoryDataExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance AirHistoryDataExec) Exec(ctx context.Context) (*AirHistoryData, error) {
            var v AirHistoryData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirHistoryDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirHistoryDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirHistoryDataExecArray) Exec(ctx context.Context) ([]AirHistoryData, error) {
            var v []AirHistoryData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirHistoryData struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type WeatherHistoryDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherHistoryDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *WeatherHistoryDataConnectionExec) Edges() *WeatherHistoryDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherHistoryDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &WeatherHistoryDataEdgeExec{ret}
                }

                  func (instance *WeatherHistoryDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateWeatherHistoryData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance WeatherHistoryDataConnectionExec) Exec(ctx context.Context) (*WeatherHistoryDataConnection, error) {
            var v WeatherHistoryDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherHistoryDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherHistoryDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherHistoryDataConnectionExecArray) Exec(ctx context.Context) ([]WeatherHistoryDataConnection, error) {
            var v []WeatherHistoryDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherHistoryDataConnection struct {
          
        }

        type AirHistoryDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirHistoryDataSubscriptionPayloadExec) Node() *AirHistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirHistoryData"},
                    "node",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirHistoryDataExec{ret}
                }

                func (instance *AirHistoryDataSubscriptionPayloadExec) PreviousValues() *AirHistoryDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirHistoryDataPreviousValues"},
                    "previousValues",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirHistoryDataPreviousValuesExec{ret}
                }

          func (instance AirHistoryDataSubscriptionPayloadExec) Exec(ctx context.Context) (*AirHistoryDataSubscriptionPayload, error) {
            var v AirHistoryDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirHistoryDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirHistoryDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirHistoryDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AirHistoryDataSubscriptionPayload, error) {
            var v []AirHistoryDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirHistoryDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type WeatherAirLiveEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirLiveEdgeExec) Node() *WeatherAirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirLive"},
                    "node",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirLiveExec{ret}
                }

          func (instance WeatherAirLiveEdgeExec) Exec(ctx context.Context) (*WeatherAirLiveEdge, error) {
            var v WeatherAirLiveEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirLiveEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirLiveEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirLiveEdgeExecArray) Exec(ctx context.Context) ([]WeatherAirLiveEdge, error) {
            var v []WeatherAirLiveEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirLiveEdge struct {
          Cursor string `json:"cursor"`
        }

        type AirHistoryDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance AirHistoryDataPreviousValuesExec) Exec(ctx context.Context) (*AirHistoryDataPreviousValues, error) {
            var v AirHistoryDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirHistoryDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirHistoryDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirHistoryDataPreviousValuesExecArray) Exec(ctx context.Context) ([]AirHistoryDataPreviousValues, error) {
            var v []AirHistoryDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirHistoryDataPreviousValues struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type CityCodeInfoExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CityCodeInfoExec) LocationInfo() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "locationInfo",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

                func (instance *CityCodeInfoExec) AirLive() *AirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirLive"},
                    "airLive",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirLiveExec{ret}
                }

                func (instance *CityCodeInfoExec) WeatherLive() *WeatherLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherLive"},
                    "weatherLive",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherLiveExec{ret}
                }

                func (instance *CityCodeInfoExec) WeatherAirLive() *WeatherAirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirLive"},
                    "weatherAirLive",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirLiveExec{ret}
                }

                type WeatherAirHistoryParamsExec struct {
                  Where *WeatherAirHistoryWhereInput
OrderBy *WeatherAirHistoryOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *CityCodeInfoExec) WeatherAirHistory(params *WeatherAirHistoryParamsExec) *WeatherAirHistoryExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"WeatherAirHistoryWhereInput", "WeatherAirHistoryOrderByInput", "WeatherAirHistory"},
                    "weatherAirHistory",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirHistoryExecArray{ret}
                }

                type AirHistoryDatasParamsExec struct {
                  Where *AirHistoryDataWhereInput
OrderBy *AirHistoryDataOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *CityCodeInfoExec) AirHistoryDatas(params *AirHistoryDatasParamsExec) *AirHistoryDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"AirHistoryDataWhereInput", "AirHistoryDataOrderByInput", "AirHistoryData"},
                    "airHistoryDatas",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirHistoryDataExecArray{ret}
                }

                type WeatherHistoryDatasParamsExec struct {
                  Where *WeatherHistoryDataWhereInput
OrderBy *WeatherHistoryDataOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *CityCodeInfoExec) WeatherHistoryDatas(params *WeatherHistoryDatasParamsExec) *WeatherHistoryDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"WeatherHistoryDataWhereInput", "WeatherHistoryDataOrderByInput", "WeatherHistoryData"},
                    "weatherHistoryDatas",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherHistoryDataExecArray{ret}
                }

          func (instance CityCodeInfoExec) Exec(ctx context.Context) (*CityCodeInfo, error) {
            var v CityCodeInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance CityCodeInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CityCodeInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance CityCodeInfoExecArray) Exec(ctx context.Context) ([]CityCodeInfo, error) {
            var v []CityCodeInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type CityCodeInfo struct {
          ID string `json:"id"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
        }


        type WeatherAirHistoryEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirHistoryEdgeExec) Node() *WeatherAirHistoryExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirHistory"},
                    "node",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirHistoryExec{ret}
                }

          func (instance WeatherAirHistoryEdgeExec) Exec(ctx context.Context) (*WeatherAirHistoryEdge, error) {
            var v WeatherAirHistoryEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirHistoryEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirHistoryEdgeExecArray) Exec(ctx context.Context) ([]WeatherAirHistoryEdge, error) {
            var v []WeatherAirHistoryEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirHistoryEdge struct {
          Cursor string `json:"cursor"`
        }

        type AirLiveSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirLiveSubscriptionPayloadExec) Node() *AirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirLive"},
                    "node",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirLiveExec{ret}
                }

                func (instance *AirLiveSubscriptionPayloadExec) PreviousValues() *AirLivePreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirLivePreviousValues"},
                    "previousValues",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirLivePreviousValuesExec{ret}
                }

          func (instance AirLiveSubscriptionPayloadExec) Exec(ctx context.Context) (*AirLiveSubscriptionPayload, error) {
            var v AirLiveSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirLiveSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirLiveSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirLiveSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AirLiveSubscriptionPayload, error) {
            var v []AirLiveSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirLiveSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type AirLivePreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance AirLivePreviousValuesExec) Exec(ctx context.Context) (*AirLivePreviousValues, error) {
            var v AirLivePreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirLivePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirLivePreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirLivePreviousValuesExecArray) Exec(ctx context.Context) ([]AirLivePreviousValues, error) {
            var v []AirLivePreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirLivePreviousValues struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type RealTimeDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RealTimeDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *RealTimeDataConnectionExec) Edges() *RealTimeDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RealTimeDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &RealTimeDataEdgeExec{ret}
                }

                  func (instance *RealTimeDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateRealTimeData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance RealTimeDataConnectionExec) Exec(ctx context.Context) (*RealTimeDataConnection, error) {
            var v RealTimeDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RealTimeDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RealTimeDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance RealTimeDataConnectionExecArray) Exec(ctx context.Context) ([]RealTimeDataConnection, error) {
            var v []RealTimeDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RealTimeDataConnection struct {
          
        }

        type AirHistoryDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirHistoryDataEdgeExec) Node() *AirHistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirHistoryData"},
                    "node",
                    []string{"id","citycode","PM25","time","rdesc","PM10","SO2","o3","NO2","primary","rcode","CO","AQI"})

                  return &AirHistoryDataExec{ret}
                }

          func (instance AirHistoryDataEdgeExec) Exec(ctx context.Context) (*AirHistoryDataEdge, error) {
            var v AirHistoryDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirHistoryDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirHistoryDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirHistoryDataEdgeExecArray) Exec(ctx context.Context) ([]AirHistoryDataEdge, error) {
            var v []AirHistoryDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirHistoryDataEdge struct {
          Cursor string `json:"cursor"`
        }


        type AttendanceRecordSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AttendanceRecordSubscriptionPayloadExec) Node() *AttendanceRecordExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AttendanceRecord"},
                    "node",
                    []string{"id","attDate","totalSecond"})

                  return &AttendanceRecordExec{ret}
                }

                func (instance *AttendanceRecordSubscriptionPayloadExec) PreviousValues() *AttendanceRecordPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AttendanceRecordPreviousValues"},
                    "previousValues",
                    []string{"id","attDate","totalSecond"})

                  return &AttendanceRecordPreviousValuesExec{ret}
                }

          func (instance AttendanceRecordSubscriptionPayloadExec) Exec(ctx context.Context) (*AttendanceRecordSubscriptionPayload, error) {
            var v AttendanceRecordSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AttendanceRecordSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AttendanceRecordSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance AttendanceRecordSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AttendanceRecordSubscriptionPayload, error) {
            var v []AttendanceRecordSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AttendanceRecordSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type PersonInfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PersonInfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *PersonInfoConnectionExec) Edges() *PersonInfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &PersonInfoEdgeExec{ret}
                }

                  func (instance *PersonInfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregatePersonInfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance PersonInfoConnectionExec) Exec(ctx context.Context) (*PersonInfoConnection, error) {
            var v PersonInfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PersonInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PersonInfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance PersonInfoConnectionExecArray) Exec(ctx context.Context) ([]PersonInfoConnection, error) {
            var v []PersonInfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PersonInfoConnection struct {
          
        }

        type AttendanceRecordPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance AttendanceRecordPreviousValuesExec) Exec(ctx context.Context) (*AttendanceRecordPreviousValues, error) {
            var v AttendanceRecordPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AttendanceRecordPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AttendanceRecordPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance AttendanceRecordPreviousValuesExecArray) Exec(ctx context.Context) ([]AttendanceRecordPreviousValues, error) {
            var v []AttendanceRecordPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AttendanceRecordPreviousValues struct {
          ID string `json:"id"`
AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
        }


        type WeatherLiveSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherLiveSubscriptionPayloadExec) Node() *WeatherLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherLive"},
                    "node",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherLiveExec{ret}
                }

                func (instance *WeatherLiveSubscriptionPayloadExec) PreviousValues() *WeatherLivePreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherLivePreviousValues"},
                    "previousValues",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherLivePreviousValuesExec{ret}
                }

          func (instance WeatherLiveSubscriptionPayloadExec) Exec(ctx context.Context) (*WeatherLiveSubscriptionPayload, error) {
            var v WeatherLiveSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherLiveSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherLiveSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherLiveSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WeatherLiveSubscriptionPayload, error) {
            var v []WeatherLiveSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherLiveSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type MonitorNodeConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MonitorNodeConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *MonitorNodeConnectionExec) Edges() *MonitorNodeEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNodeEdge"},
                    "edges",
                    []string{"cursor"})

                  return &MonitorNodeEdgeExec{ret}
                }

                  func (instance *MonitorNodeConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateMonitorNode"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance MonitorNodeConnectionExec) Exec(ctx context.Context) (*MonitorNodeConnection, error) {
            var v MonitorNodeConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MonitorNodeConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MonitorNodeConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance MonitorNodeConnectionExecArray) Exec(ctx context.Context) ([]MonitorNodeConnection, error) {
            var v []MonitorNodeConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MonitorNodeConnection struct {
          
        }

        type CityCodeInfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CityCodeInfoSubscriptionPayloadExec) Node() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "node",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

                func (instance *CityCodeInfoSubscriptionPayloadExec) PreviousValues() *CityCodeInfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfoPreviousValues"},
                    "previousValues",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoPreviousValuesExec{ret}
                }

          func (instance CityCodeInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*CityCodeInfoSubscriptionPayload, error) {
            var v CityCodeInfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance CityCodeInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CityCodeInfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance CityCodeInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CityCodeInfoSubscriptionPayload, error) {
            var v []CityCodeInfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type CityCodeInfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type MaCinfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MaCinfoEdgeExec) Node() *MaCinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfo"},
                    "node",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoExec{ret}
                }

          func (instance MaCinfoEdgeExec) Exec(ctx context.Context) (*MaCinfoEdge, error) {
            var v MaCinfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MaCinfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MaCinfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance MaCinfoEdgeExecArray) Exec(ctx context.Context) ([]MaCinfoEdge, error) {
            var v []MaCinfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MaCinfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type CityCodeInfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance CityCodeInfoPreviousValuesExec) Exec(ctx context.Context) (*CityCodeInfoPreviousValues, error) {
            var v CityCodeInfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance CityCodeInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CityCodeInfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance CityCodeInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]CityCodeInfoPreviousValues, error) {
            var v []CityCodeInfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type CityCodeInfoPreviousValues struct {
          ID string `json:"id"`
AirCitycode string `json:"airCitycode"`
WeatherCityCode string `json:"weatherCityCode"`
CityName string `json:"cityName"`
        }


        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
            var v PageInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }

        type MacProbeRecordConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeRecordConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *MacProbeRecordConnectionExec) Edges() *MacProbeRecordEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeRecordEdge"},
                    "edges",
                    []string{"cursor"})

                  return &MacProbeRecordEdgeExec{ret}
                }

                  func (instance *MacProbeRecordConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateMACProbeRecord"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance MacProbeRecordConnectionExec) Exec(ctx context.Context) (*MacProbeRecordConnection, error) {
            var v MacProbeRecordConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeRecordConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeRecordConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeRecordConnectionExecArray) Exec(ctx context.Context) ([]MacProbeRecordConnection, error) {
            var v []MacProbeRecordConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeRecordConnection struct {
          
        }

        type DataUnitSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *DataUnitSubscriptionPayloadExec) Node() *DataUnitExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "DataUnit"},
                    "node",
                    []string{"id","dataItem","unit"})

                  return &DataUnitExec{ret}
                }

                func (instance *DataUnitSubscriptionPayloadExec) PreviousValues() *DataUnitPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "DataUnitPreviousValues"},
                    "previousValues",
                    []string{"id","dataItem","unit"})

                  return &DataUnitPreviousValuesExec{ret}
                }

          func (instance DataUnitSubscriptionPayloadExec) Exec(ctx context.Context) (*DataUnitSubscriptionPayload, error) {
            var v DataUnitSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance DataUnitSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type DataUnitSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance DataUnitSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DataUnitSubscriptionPayload, error) {
            var v []DataUnitSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type DataUnitSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type DataUnitPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance DataUnitPreviousValuesExec) Exec(ctx context.Context) (*DataUnitPreviousValues, error) {
            var v DataUnitPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance DataUnitPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type DataUnitPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance DataUnitPreviousValuesExecArray) Exec(ctx context.Context) ([]DataUnitPreviousValues, error) {
            var v []DataUnitPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type DataUnitPreviousValues struct {
          ID string `json:"id"`
DataItem string `json:"dataItem"`
Unit string `json:"unit"`
        }

        type MacProbeDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *MacProbeDataConnectionExec) Edges() *MacProbeDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &MacProbeDataEdgeExec{ret}
                }

                  func (instance *MacProbeDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateMACProbeData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance MacProbeDataConnectionExec) Exec(ctx context.Context) (*MacProbeDataConnection, error) {
            var v MacProbeDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeDataConnectionExecArray) Exec(ctx context.Context) ([]MacProbeDataConnection, error) {
            var v []MacProbeDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeDataConnection struct {
          
        }

        type AirHistoryDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirHistoryDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *AirHistoryDataConnectionExec) Edges() *AirHistoryDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AirHistoryDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &AirHistoryDataEdgeExec{ret}
                }

                  func (instance *AirHistoryDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateAirHistoryData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance AirHistoryDataConnectionExec) Exec(ctx context.Context) (*AirHistoryDataConnection, error) {
            var v AirHistoryDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirHistoryDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirHistoryDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirHistoryDataConnectionExecArray) Exec(ctx context.Context) ([]AirHistoryDataConnection, error) {
            var v []AirHistoryDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirHistoryDataConnection struct {
          
        }

        type LocationInfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LocationInfoEdgeExec) Node() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "node",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

          func (instance LocationInfoEdgeExec) Exec(ctx context.Context) (*LocationInfoEdge, error) {
            var v LocationInfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance LocationInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LocationInfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance LocationInfoEdgeExecArray) Exec(ctx context.Context) ([]LocationInfoEdge, error) {
            var v []LocationInfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type LocationInfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type HistoryDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *HistoryDataSubscriptionPayloadExec) Node() *HistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "HistoryData"},
                    "node",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

                  return &HistoryDataExec{ret}
                }

                func (instance *HistoryDataSubscriptionPayloadExec) PreviousValues() *HistoryDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "HistoryDataPreviousValues"},
                    "previousValues",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

                  return &HistoryDataPreviousValuesExec{ret}
                }

          func (instance HistoryDataSubscriptionPayloadExec) Exec(ctx context.Context) (*HistoryDataSubscriptionPayload, error) {
            var v HistoryDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance HistoryDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type HistoryDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance HistoryDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]HistoryDataSubscriptionPayload, error) {
            var v []HistoryDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type HistoryDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type HistoryDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance HistoryDataPreviousValuesExec) Exec(ctx context.Context) (*HistoryDataPreviousValues, error) {
            var v HistoryDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance HistoryDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type HistoryDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance HistoryDataPreviousValuesExecArray) Exec(ctx context.Context) ([]HistoryDataPreviousValues, error) {
            var v []HistoryDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type HistoryDataPreviousValues struct {
          ID string `json:"id"`
RcvTime string `json:"rcvTime"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
CreatedAt string `json:"createdAt"`
        }

        type IDVerifyDeviceInfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDVerifyDeviceInfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *IDVerifyDeviceInfoConnectionExec) Edges() *IDVerifyDeviceInfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDVerifyDeviceInfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &IDVerifyDeviceInfoEdgeExec{ret}
                }

                  func (instance *IDVerifyDeviceInfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateIDVerifyDeviceInfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance IDVerifyDeviceInfoConnectionExec) Exec(ctx context.Context) (*IDVerifyDeviceInfoConnection, error) {
            var v IDVerifyDeviceInfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDVerifyDeviceInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDVerifyDeviceInfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDVerifyDeviceInfoConnectionExecArray) Exec(ctx context.Context) ([]IDVerifyDeviceInfoConnection, error) {
            var v []IDVerifyDeviceInfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDVerifyDeviceInfoConnection struct {
          
        }

        type WeatherHistoryDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherHistoryDataExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance WeatherHistoryDataExec) Exec(ctx context.Context) (*WeatherHistoryData, error) {
            var v WeatherHistoryData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherHistoryDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherHistoryDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherHistoryDataExecArray) Exec(ctx context.Context) ([]WeatherHistoryData, error) {
            var v []WeatherHistoryData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherHistoryData struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
UpdatedAt string `json:"updatedAt"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
        }

        type IDCardVerifyDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDCardVerifyDataEdgeExec) Node() *IDCardVerifyDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDCardVerifyData"},
                    "node",
                    []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

                  return &IDCardVerifyDataExec{ret}
                }

          func (instance IDCardVerifyDataEdgeExec) Exec(ctx context.Context) (*IDCardVerifyDataEdge, error) {
            var v IDCardVerifyDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDCardVerifyDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDCardVerifyDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDCardVerifyDataEdgeExecArray) Exec(ctx context.Context) ([]IDCardVerifyDataEdge, error) {
            var v []IDCardVerifyDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDCardVerifyDataEdge struct {
          Cursor string `json:"cursor"`
        }

        type IDCardVerifyDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDCardVerifyDataSubscriptionPayloadExec) Node() *IDCardVerifyDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDCardVerifyData"},
                    "node",
                    []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

                  return &IDCardVerifyDataExec{ret}
                }

                func (instance *IDCardVerifyDataSubscriptionPayloadExec) PreviousValues() *IDCardVerifyDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDCardVerifyDataPreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

                  return &IDCardVerifyDataPreviousValuesExec{ret}
                }

          func (instance IDCardVerifyDataSubscriptionPayloadExec) Exec(ctx context.Context) (*IDCardVerifyDataSubscriptionPayload, error) {
            var v IDCardVerifyDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDCardVerifyDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDCardVerifyDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDCardVerifyDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]IDCardVerifyDataSubscriptionPayload, error) {
            var v []IDCardVerifyDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDCardVerifyDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type IDCardVerifyDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance IDCardVerifyDataPreviousValuesExec) Exec(ctx context.Context) (*IDCardVerifyDataPreviousValues, error) {
            var v IDCardVerifyDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDCardVerifyDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDCardVerifyDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDCardVerifyDataPreviousValuesExecArray) Exec(ctx context.Context) ([]IDCardVerifyDataPreviousValues, error) {
            var v []IDCardVerifyDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDCardVerifyDataPreviousValues struct {
          ID string `json:"id"`
CreatedAt *string `json:"createdAt,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
        }

        type HistoryDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *HistoryDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *HistoryDataConnectionExec) Edges() *HistoryDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "HistoryDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &HistoryDataEdgeExec{ret}
                }

                  func (instance *HistoryDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateHistoryData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance HistoryDataConnectionExec) Exec(ctx context.Context) (*HistoryDataConnection, error) {
            var v HistoryDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance HistoryDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type HistoryDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance HistoryDataConnectionExecArray) Exec(ctx context.Context) ([]HistoryDataConnection, error) {
            var v []HistoryDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type HistoryDataConnection struct {
          
        }

        type WeatherAirHistoryExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirHistoryExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance WeatherAirHistoryExec) Exec(ctx context.Context) (*WeatherAirHistory, error) {
            var v WeatherAirHistory
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirHistoryExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirHistoryExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirHistoryExecArray) Exec(ctx context.Context) ([]WeatherAirHistory, error) {
            var v []WeatherAirHistory
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirHistory struct {
          ID string `json:"id"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type DataUnitEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *DataUnitEdgeExec) Node() *DataUnitExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "DataUnit"},
                    "node",
                    []string{"id","dataItem","unit"})

                  return &DataUnitExec{ret}
                }

          func (instance DataUnitEdgeExec) Exec(ctx context.Context) (*DataUnitEdge, error) {
            var v DataUnitEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance DataUnitEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type DataUnitEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance DataUnitEdgeExecArray) Exec(ctx context.Context) ([]DataUnitEdge, error) {
            var v []DataUnitEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type DataUnitEdge struct {
          Cursor string `json:"cursor"`
        }

        type IDVerifyDeviceInfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDVerifyDeviceInfoSubscriptionPayloadExec) Node() *IDVerifyDeviceInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDVerifyDeviceInfo"},
                    "node",
                    []string{"id","devNo","devName","devAddr"})

                  return &IDVerifyDeviceInfoExec{ret}
                }

                func (instance *IDVerifyDeviceInfoSubscriptionPayloadExec) PreviousValues() *IDVerifyDeviceInfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDVerifyDeviceInfoPreviousValues"},
                    "previousValues",
                    []string{"id","devNo","devName","devAddr"})

                  return &IDVerifyDeviceInfoPreviousValuesExec{ret}
                }

          func (instance IDVerifyDeviceInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*IDVerifyDeviceInfoSubscriptionPayload, error) {
            var v IDVerifyDeviceInfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDVerifyDeviceInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDVerifyDeviceInfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDVerifyDeviceInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]IDVerifyDeviceInfoSubscriptionPayload, error) {
            var v []IDVerifyDeviceInfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDVerifyDeviceInfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type DataUnitExec struct {
          exec *prisma.Exec
        }

        

          func (instance DataUnitExec) Exec(ctx context.Context) (*DataUnit, error) {
            var v DataUnit
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance DataUnitExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type DataUnitExecArray struct {
            exec *prisma.Exec
          }

          func (instance DataUnitExecArray) Exec(ctx context.Context) ([]DataUnit, error) {
            var v []DataUnit
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type DataUnit struct {
          ID string `json:"id"`
DataItem string `json:"dataItem"`
Unit string `json:"unit"`
        }

        type IDVerifyDeviceInfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance IDVerifyDeviceInfoPreviousValuesExec) Exec(ctx context.Context) (*IDVerifyDeviceInfoPreviousValues, error) {
            var v IDVerifyDeviceInfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDVerifyDeviceInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDVerifyDeviceInfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDVerifyDeviceInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]IDVerifyDeviceInfoPreviousValues, error) {
            var v []IDVerifyDeviceInfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDVerifyDeviceInfoPreviousValues struct {
          ID string `json:"id"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
        }

        type CityCodeInfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CityCodeInfoEdgeExec) Node() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "node",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance CityCodeInfoEdgeExec) Exec(ctx context.Context) (*CityCodeInfoEdge, error) {
            var v CityCodeInfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance CityCodeInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CityCodeInfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance CityCodeInfoEdgeExecArray) Exec(ctx context.Context) ([]CityCodeInfoEdge, error) {
            var v []CityCodeInfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type CityCodeInfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type IDVerifyDeviceInfoExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDVerifyDeviceInfoExec) LocationInfo() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "locationInfo",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

                type IDCardVerifyDatasParamsExec struct {
                  Where *IDCardVerifyDataWhereInput
OrderBy *IDCardVerifyDataOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *IDVerifyDeviceInfoExec) IDCardVerifyDatas(params *IDCardVerifyDatasParamsExec) *IDCardVerifyDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"IDCardVerifyDataWhereInput", "IDCardVerifyDataOrderByInput", "IDCardVerifyData"},
                    "idCardVerifyDatas",
                    []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

                  return &IDCardVerifyDataExecArray{ret}
                }

          func (instance IDVerifyDeviceInfoExec) Exec(ctx context.Context) (*IDVerifyDeviceInfo, error) {
            var v IDVerifyDeviceInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDVerifyDeviceInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDVerifyDeviceInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDVerifyDeviceInfoExecArray) Exec(ctx context.Context) ([]IDVerifyDeviceInfo, error) {
            var v []IDVerifyDeviceInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDVerifyDeviceInfo struct {
          ID string `json:"id"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
        }


        type LocationInfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LocationInfoSubscriptionPayloadExec) Node() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "node",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

                func (instance *LocationInfoSubscriptionPayloadExec) PreviousValues() *LocationInfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfoPreviousValues"},
                    "previousValues",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoPreviousValuesExec{ret}
                }

          func (instance LocationInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*LocationInfoSubscriptionPayload, error) {
            var v LocationInfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance LocationInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LocationInfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance LocationInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LocationInfoSubscriptionPayload, error) {
            var v []LocationInfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type LocationInfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type AttendanceRecordConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AttendanceRecordConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *AttendanceRecordConnectionExec) Edges() *AttendanceRecordEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AttendanceRecordEdge"},
                    "edges",
                    []string{"cursor"})

                  return &AttendanceRecordEdgeExec{ret}
                }

                  func (instance *AttendanceRecordConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateAttendanceRecord"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance AttendanceRecordConnectionExec) Exec(ctx context.Context) (*AttendanceRecordConnection, error) {
            var v AttendanceRecordConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AttendanceRecordConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AttendanceRecordConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance AttendanceRecordConnectionExecArray) Exec(ctx context.Context) ([]AttendanceRecordConnection, error) {
            var v []AttendanceRecordConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AttendanceRecordConnection struct {
          
        }

        type LocationInfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance LocationInfoPreviousValuesExec) Exec(ctx context.Context) (*LocationInfoPreviousValues, error) {
            var v LocationInfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance LocationInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LocationInfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance LocationInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]LocationInfoPreviousValues, error) {
            var v []LocationInfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type LocationInfoPreviousValues struct {
          ID string `json:"id"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
        }

        type WiFiProberinfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WiFiProberinfoSubscriptionPayloadExec) Node() *WiFiProberinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WiFiProberinfo"},
                    "node",
                    []string{"id","devNo","devMac","devMdoel"})

                  return &WiFiProberinfoExec{ret}
                }

                func (instance *WiFiProberinfoSubscriptionPayloadExec) PreviousValues() *WiFiProberinfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WiFiProberinfoPreviousValues"},
                    "previousValues",
                    []string{"id","devNo","devMac","devMdoel"})

                  return &WiFiProberinfoPreviousValuesExec{ret}
                }

          func (instance WiFiProberinfoSubscriptionPayloadExec) Exec(ctx context.Context) (*WiFiProberinfoSubscriptionPayload, error) {
            var v WiFiProberinfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WiFiProberinfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WiFiProberinfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance WiFiProberinfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WiFiProberinfoSubscriptionPayload, error) {
            var v []WiFiProberinfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WiFiProberinfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type WeatherAirLiveExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirLiveExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance WeatherAirLiveExec) Exec(ctx context.Context) (*WeatherAirLive, error) {
            var v WeatherAirLive
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirLiveExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirLiveExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirLiveExecArray) Exec(ctx context.Context) ([]WeatherAirLive, error) {
            var v []WeatherAirLive
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirLive struct {
          ID string `json:"id"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }


        type MacProbeDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeDataSubscriptionPayloadExec) Node() *MacProbeDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeData"},
                    "node",
                    []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

                  return &MacProbeDataExec{ret}
                }

                func (instance *MacProbeDataSubscriptionPayloadExec) PreviousValues() *MacProbeDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeDataPreviousValues"},
                    "previousValues",
                    []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

                  return &MacProbeDataPreviousValuesExec{ret}
                }

          func (instance MacProbeDataSubscriptionPayloadExec) Exec(ctx context.Context) (*MacProbeDataSubscriptionPayload, error) {
            var v MacProbeDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MacProbeDataSubscriptionPayload, error) {
            var v []MacProbeDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type MacProbeDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance MacProbeDataPreviousValuesExec) Exec(ctx context.Context) (*MacProbeDataPreviousValues, error) {
            var v MacProbeDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeDataPreviousValuesExecArray) Exec(ctx context.Context) ([]MacProbeDataPreviousValues, error) {
            var v []MacProbeDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeDataPreviousValues struct {
          ID string `json:"id"`
ProbeTime string `json:"probeTime"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
        }

        type RealTimeDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RealTimeDataEdgeExec) Node() *RealTimeDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RealTimeData"},
                    "node",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

                  return &RealTimeDataExec{ret}
                }

          func (instance RealTimeDataEdgeExec) Exec(ctx context.Context) (*RealTimeDataEdge, error) {
            var v RealTimeDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RealTimeDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RealTimeDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance RealTimeDataEdgeExecArray) Exec(ctx context.Context) ([]RealTimeDataEdge, error) {
            var v []RealTimeDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RealTimeDataEdge struct {
          Cursor string `json:"cursor"`
        }

        type WeatherLiveExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherLiveExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance WeatherLiveExec) Exec(ctx context.Context) (*WeatherLive, error) {
            var v WeatherLive
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherLiveExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherLiveExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherLiveExecArray) Exec(ctx context.Context) ([]WeatherLive, error) {
            var v []WeatherLive
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherLive struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
UpdatedAt string `json:"updatedAt"`
Windspeed *string `json:"windspeed,omitempty"`
Airpressure *string `json:"airpressure,omitempty"`
Phenomena *string `json:"phenomena,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Humidity *string `json:"humidity,omitempty"`
Updatetime *string `json:"updatetime,omitempty"`
Windpower *string `json:"windpower,omitempty"`
Feelst *string `json:"feelst,omitempty"`
Winddirect *string `json:"winddirect,omitempty"`
Rcode *int32 `json:"rcode,omitempty"`
Rain *string `json:"rain,omitempty"`
Temperature *string `json:"temperature,omitempty"`
        }

        type PersonInfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PersonInfoEdgeExec) Node() *PersonInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfo"},
                    "node",
                    []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

                  return &PersonInfoExec{ret}
                }

          func (instance PersonInfoEdgeExec) Exec(ctx context.Context) (*PersonInfoEdge, error) {
            var v PersonInfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PersonInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PersonInfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance PersonInfoEdgeExecArray) Exec(ctx context.Context) ([]PersonInfoEdge, error) {
            var v []PersonInfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PersonInfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type MacProbeRecordSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeRecordSubscriptionPayloadExec) Node() *MacProbeRecordExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeRecord"},
                    "node",
                    []string{"id","mac","devNo","entryTime","departureTime"})

                  return &MacProbeRecordExec{ret}
                }

                func (instance *MacProbeRecordSubscriptionPayloadExec) PreviousValues() *MacProbeRecordPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeRecordPreviousValues"},
                    "previousValues",
                    []string{"id","mac","devNo","entryTime","departureTime"})

                  return &MacProbeRecordPreviousValuesExec{ret}
                }

          func (instance MacProbeRecordSubscriptionPayloadExec) Exec(ctx context.Context) (*MacProbeRecordSubscriptionPayload, error) {
            var v MacProbeRecordSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeRecordSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeRecordSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeRecordSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MacProbeRecordSubscriptionPayload, error) {
            var v []MacProbeRecordSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeRecordSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type MonitorNodeEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MonitorNodeEdgeExec) Node() *MonitorNodeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNode"},
                    "node",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodeExec{ret}
                }

          func (instance MonitorNodeEdgeExec) Exec(ctx context.Context) (*MonitorNodeEdge, error) {
            var v MonitorNodeEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MonitorNodeEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MonitorNodeEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance MonitorNodeEdgeExecArray) Exec(ctx context.Context) ([]MonitorNodeEdge, error) {
            var v []MonitorNodeEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MonitorNodeEdge struct {
          Cursor string `json:"cursor"`
        }

        type MacProbeRecordPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance MacProbeRecordPreviousValuesExec) Exec(ctx context.Context) (*MacProbeRecordPreviousValues, error) {
            var v MacProbeRecordPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeRecordPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeRecordPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeRecordPreviousValuesExecArray) Exec(ctx context.Context) ([]MacProbeRecordPreviousValues, error) {
            var v []MacProbeRecordPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeRecordPreviousValues struct {
          ID string `json:"id"`
Mac string `json:"mac"`
DevNo string `json:"devNo"`
EntryTime *string `json:"entryTime,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
        }

        type MaCinfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MaCinfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *MaCinfoConnectionExec) Edges() *MaCinfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &MaCinfoEdgeExec{ret}
                }

                  func (instance *MaCinfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateMACinfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance MaCinfoConnectionExec) Exec(ctx context.Context) (*MaCinfoConnection, error) {
            var v MaCinfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MaCinfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MaCinfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance MaCinfoConnectionExecArray) Exec(ctx context.Context) ([]MaCinfoConnection, error) {
            var v []MaCinfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MaCinfoConnection struct {
          
        }

        type AirLiveExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AirLiveExec) CityInfo() *CityCodeInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfo"},
                    "cityInfo",
                    []string{"id","airCitycode","weatherCityCode","cityName"})

                  return &CityCodeInfoExec{ret}
                }

          func (instance AirLiveExec) Exec(ctx context.Context) (*AirLive, error) {
            var v AirLive
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AirLiveExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AirLiveExecArray struct {
            exec *prisma.Exec
          }

          func (instance AirLiveExecArray) Exec(ctx context.Context) ([]AirLive, error) {
            var v []AirLive
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AirLive struct {
          ID string `json:"id"`
Citycode string `json:"citycode"`
Pm25 *string `json:"PM25,omitempty"`
Time *string `json:"time,omitempty"`
Rdesc *string `json:"rdesc,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"o3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"primary,omitempty"`
Rcode *string `json:"rcode,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type MacProbeRecordExec struct {
          exec *prisma.Exec
        }

        

          func (instance MacProbeRecordExec) Exec(ctx context.Context) (*MacProbeRecord, error) {
            var v MacProbeRecord
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeRecordExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeRecordExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeRecordExecArray) Exec(ctx context.Context) ([]MacProbeRecord, error) {
            var v []MacProbeRecord
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeRecord struct {
          ID string `json:"id"`
Mac string `json:"mac"`
DevNo string `json:"devNo"`
EntryTime *string `json:"entryTime,omitempty"`
DepartureTime *string `json:"departureTime,omitempty"`
        }

        type MaCinfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MaCinfoSubscriptionPayloadExec) Node() *MaCinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfo"},
                    "node",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoExec{ret}
                }

                func (instance *MaCinfoSubscriptionPayloadExec) PreviousValues() *MaCinfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfoPreviousValues"},
                    "previousValues",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoPreviousValuesExec{ret}
                }

          func (instance MaCinfoSubscriptionPayloadExec) Exec(ctx context.Context) (*MaCinfoSubscriptionPayload, error) {
            var v MaCinfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MaCinfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MaCinfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance MaCinfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MaCinfoSubscriptionPayload, error) {
            var v []MaCinfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MaCinfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type MaCinfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance MaCinfoPreviousValuesExec) Exec(ctx context.Context) (*MaCinfoPreviousValues, error) {
            var v MaCinfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MaCinfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MaCinfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance MaCinfoPreviousValuesExecArray) Exec(ctx context.Context) ([]MaCinfoPreviousValues, error) {
            var v []MaCinfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MaCinfoPreviousValues struct {
          ID string `json:"id"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
LastProbeTime string `json:"lastProbeTime"`
IfOnline *int32 `json:"ifOnline,omitempty"`
        }

        type IDVerifyDeviceInfoEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDVerifyDeviceInfoEdgeExec) Node() *IDVerifyDeviceInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDVerifyDeviceInfo"},
                    "node",
                    []string{"id","devNo","devName","devAddr"})

                  return &IDVerifyDeviceInfoExec{ret}
                }

          func (instance IDVerifyDeviceInfoEdgeExec) Exec(ctx context.Context) (*IDVerifyDeviceInfoEdge, error) {
            var v IDVerifyDeviceInfoEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDVerifyDeviceInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDVerifyDeviceInfoEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDVerifyDeviceInfoEdgeExecArray) Exec(ctx context.Context) ([]IDVerifyDeviceInfoEdge, error) {
            var v []IDVerifyDeviceInfoEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDVerifyDeviceInfoEdge struct {
          Cursor string `json:"cursor"`
        }

        type AttendanceRecordExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AttendanceRecordExec) Mac() *MaCinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfo"},
                    "mac",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoExec{ret}
                }

          func (instance AttendanceRecordExec) Exec(ctx context.Context) (*AttendanceRecord, error) {
            var v AttendanceRecord
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AttendanceRecordExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AttendanceRecordExecArray struct {
            exec *prisma.Exec
          }

          func (instance AttendanceRecordExecArray) Exec(ctx context.Context) ([]AttendanceRecord, error) {
            var v []AttendanceRecord
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AttendanceRecord struct {
          ID string `json:"id"`
AttDate *string `json:"attDate,omitempty"`
TotalSecond *string `json:"totalSecond,omitempty"`
        }

        type IDCardVerifyDataConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDCardVerifyDataConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *IDCardVerifyDataConnectionExec) Edges() *IDCardVerifyDataEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDCardVerifyDataEdge"},
                    "edges",
                    []string{"cursor"})

                  return &IDCardVerifyDataEdgeExec{ret}
                }

                  func (instance *IDCardVerifyDataConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateIDCardVerifyData"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance IDCardVerifyDataConnectionExec) Exec(ctx context.Context) (*IDCardVerifyDataConnection, error) {
            var v IDCardVerifyDataConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDCardVerifyDataConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDCardVerifyDataConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDCardVerifyDataConnectionExecArray) Exec(ctx context.Context) ([]IDCardVerifyDataConnection, error) {
            var v []IDCardVerifyDataConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDCardVerifyDataConnection struct {
          
        }

        type MonitorNodeSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MonitorNodeSubscriptionPayloadExec) Node() *MonitorNodeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNode"},
                    "node",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodeExec{ret}
                }

                func (instance *MonitorNodeSubscriptionPayloadExec) PreviousValues() *MonitorNodePreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MonitorNodePreviousValues"},
                    "previousValues",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodePreviousValuesExec{ret}
                }

          func (instance MonitorNodeSubscriptionPayloadExec) Exec(ctx context.Context) (*MonitorNodeSubscriptionPayload, error) {
            var v MonitorNodeSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MonitorNodeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MonitorNodeSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance MonitorNodeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MonitorNodeSubscriptionPayload, error) {
            var v []MonitorNodeSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MonitorNodeSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type MonitorNodePreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance MonitorNodePreviousValuesExec) Exec(ctx context.Context) (*MonitorNodePreviousValues, error) {
            var v MonitorNodePreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MonitorNodePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MonitorNodePreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance MonitorNodePreviousValuesExecArray) Exec(ctx context.Context) ([]MonitorNodePreviousValues, error) {
            var v []MonitorNodePreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MonitorNodePreviousValues struct {
          ID string `json:"id"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }


        type WiFiProberinfoExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WiFiProberinfoExec) LocationInfo() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "locationInfo",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

                type MacProbeDatasParamsExec struct {
                  Where *MacProbeDataWhereInput
OrderBy *MacProbeDataOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *WiFiProberinfoExec) MacProbeDatas(params *MacProbeDatasParamsExec) *MacProbeDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"MACProbeDataWhereInput", "MACProbeDataOrderByInput", "MACProbeData"},
                    "macProbeDatas",
                    []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

                  return &MacProbeDataExecArray{ret}
                }

          func (instance WiFiProberinfoExec) Exec(ctx context.Context) (*WiFiProberinfo, error) {
            var v WiFiProberinfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WiFiProberinfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WiFiProberinfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance WiFiProberinfoExecArray) Exec(ctx context.Context) ([]WiFiProberinfo, error) {
            var v []WiFiProberinfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WiFiProberinfo struct {
          ID string `json:"id"`
DevNo string `json:"devNo"`
DevMac *string `json:"devMac,omitempty"`
DevMdoel *string `json:"devMdoel,omitempty"`
        }

        type AttendanceRecordEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *AttendanceRecordEdgeExec) Node() *AttendanceRecordExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "AttendanceRecord"},
                    "node",
                    []string{"id","attDate","totalSecond"})

                  return &AttendanceRecordExec{ret}
                }

          func (instance AttendanceRecordEdgeExec) Exec(ctx context.Context) (*AttendanceRecordEdge, error) {
            var v AttendanceRecordEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance AttendanceRecordEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type AttendanceRecordEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance AttendanceRecordEdgeExecArray) Exec(ctx context.Context) ([]AttendanceRecordEdge, error) {
            var v []AttendanceRecordEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type AttendanceRecordEdge struct {
          Cursor string `json:"cursor"`
        }

        type PersonInfoSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PersonInfoSubscriptionPayloadExec) Node() *PersonInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfo"},
                    "node",
                    []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

                  return &PersonInfoExec{ret}
                }

                func (instance *PersonInfoSubscriptionPayloadExec) PreviousValues() *PersonInfoPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfoPreviousValues"},
                    "previousValues",
                    []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

                  return &PersonInfoPreviousValuesExec{ret}
                }

          func (instance PersonInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonInfoSubscriptionPayload, error) {
            var v PersonInfoSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PersonInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PersonInfoSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance PersonInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonInfoSubscriptionPayload, error) {
            var v []PersonInfoSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PersonInfoSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type WeatherHistoryDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherHistoryDataEdgeExec) Node() *WeatherHistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherHistoryData"},
                    "node",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherHistoryDataExec{ret}
                }

          func (instance WeatherHistoryDataEdgeExec) Exec(ctx context.Context) (*WeatherHistoryDataEdge, error) {
            var v WeatherHistoryDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherHistoryDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherHistoryDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherHistoryDataEdgeExecArray) Exec(ctx context.Context) ([]WeatherHistoryDataEdge, error) {
            var v []WeatherHistoryDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherHistoryDataEdge struct {
          Cursor string `json:"cursor"`
        }

        type PersonInfoPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance PersonInfoPreviousValuesExec) Exec(ctx context.Context) (*PersonInfoPreviousValues, error) {
            var v PersonInfoPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PersonInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PersonInfoPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance PersonInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonInfoPreviousValues, error) {
            var v []PersonInfoPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PersonInfoPreviousValues struct {
          ID string `json:"id"`
IDCard string `json:"idCard"`
CardType string `json:"cardType"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
        }

        type WeatherAirHistoryConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirHistoryConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *WeatherAirHistoryConnectionExec) Edges() *WeatherAirHistoryEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirHistoryEdge"},
                    "edges",
                    []string{"cursor"})

                  return &WeatherAirHistoryEdgeExec{ret}
                }

                  func (instance *WeatherAirHistoryConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateWeatherAirHistory"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance WeatherAirHistoryConnectionExec) Exec(ctx context.Context) (*WeatherAirHistoryConnection, error) {
            var v WeatherAirHistoryConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirHistoryConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirHistoryConnectionExecArray) Exec(ctx context.Context) ([]WeatherAirHistoryConnection, error) {
            var v []WeatherAirHistoryConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirHistoryConnection struct {
          
        }

        type MacProbeDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeDataExec) Mac() *MaCinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACinfo"},
                    "mac",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoExec{ret}
                }

                func (instance *MacProbeDataExec) WifiProber() *WiFiProberinfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WiFiProberinfo"},
                    "wifiProber",
                    []string{"id","devNo","devMac","devMdoel"})

                  return &WiFiProberinfoExec{ret}
                }

          func (instance MacProbeDataExec) Exec(ctx context.Context) (*MacProbeData, error) {
            var v MacProbeData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeDataExecArray) Exec(ctx context.Context) ([]MacProbeData, error) {
            var v []MacProbeData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeData struct {
          ID string `json:"id"`
ProbeTime string `json:"probeTime"`
IsConnet *string `json:"isConnet,omitempty"`
RouterMac *string `json:"routerMAC,omitempty"`
RouterSsid *string `json:"routerSSID,omitempty"`
Destance *string `json:"destance,omitempty"`
        }

        type MonitorNodeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MonitorNodeExec) Location() *LocationInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfo"},
                    "location",
                    []string{"id","describe","longitude","latitude","province","city","county","street","indoorLocal","outdoorLocal"})

                  return &LocationInfoExec{ret}
                }

                func (instance *MonitorNodeExec) RealTimeData() *RealTimeDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RealTimeData"},
                    "realTimeData",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

                  return &RealTimeDataExec{ret}
                }

                type HistoryDatasParamsExec struct {
                  Where *HistoryDataWhereInput
OrderBy *HistoryDataOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *MonitorNodeExec) HistoryDatas(params *HistoryDatasParamsExec) *HistoryDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"HistoryDataWhereInput", "HistoryDataOrderByInput", "HistoryData"},
                    "historyDatas",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

                  return &HistoryDataExecArray{ret}
                }

          func (instance MonitorNodeExec) Exec(ctx context.Context) (*MonitorNode, error) {
            var v MonitorNode
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MonitorNodeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MonitorNodeExecArray struct {
            exec *prisma.Exec
          }

          func (instance MonitorNodeExecArray) Exec(ctx context.Context) ([]MonitorNode, error) {
            var v []MonitorNode
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MonitorNode struct {
          ID string `json:"id"`
MonitorSn string `json:"monitorSN"`
MonitorName string `json:"monitorName"`
MonitorType string `json:"monitorType"`
MonitorStatus string `json:"monitorStatus"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
        }

        type RealTimeDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RealTimeDataSubscriptionPayloadExec) Node() *RealTimeDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RealTimeData"},
                    "node",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

                  return &RealTimeDataExec{ret}
                }

                func (instance *RealTimeDataSubscriptionPayloadExec) PreviousValues() *RealTimeDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RealTimeDataPreviousValues"},
                    "previousValues",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","updatedAt"})

                  return &RealTimeDataPreviousValuesExec{ret}
                }

          func (instance RealTimeDataSubscriptionPayloadExec) Exec(ctx context.Context) (*RealTimeDataSubscriptionPayload, error) {
            var v RealTimeDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RealTimeDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RealTimeDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance RealTimeDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RealTimeDataSubscriptionPayload, error) {
            var v []RealTimeDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RealTimeDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type MacProbeRecordEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeRecordEdgeExec) Node() *MacProbeRecordExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeRecord"},
                    "node",
                    []string{"id","mac","devNo","entryTime","departureTime"})

                  return &MacProbeRecordExec{ret}
                }

          func (instance MacProbeRecordEdgeExec) Exec(ctx context.Context) (*MacProbeRecordEdge, error) {
            var v MacProbeRecordEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeRecordEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeRecordEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeRecordEdgeExecArray) Exec(ctx context.Context) ([]MacProbeRecordEdge, error) {
            var v []MacProbeRecordEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeRecordEdge struct {
          Cursor string `json:"cursor"`
        }

        type RealTimeDataPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance RealTimeDataPreviousValuesExec) Exec(ctx context.Context) (*RealTimeDataPreviousValues, error) {
            var v RealTimeDataPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RealTimeDataPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RealTimeDataPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance RealTimeDataPreviousValuesExecArray) Exec(ctx context.Context) ([]RealTimeDataPreviousValues, error) {
            var v []RealTimeDataPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RealTimeDataPreviousValues struct {
          ID string `json:"id"`
RcvTime *string `json:"rcvTime,omitempty"`
WindSpeed *float64 `json:"windSpeed,omitempty"`
WindDirection *string `json:"windDirection,omitempty"`
Temperature *float64 `json:"temperature,omitempty"`
Humidity *float64 `json:"humidity,omitempty"`
Noise *float64 `json:"noise,omitempty"`
Pm2 *float64 `json:"pm2,omitempty"`
Pm10 *float64 `json:"pm10,omitempty"`
Co *float64 `json:"co,omitempty"`
Co2 *float64 `json:"co2,omitempty"`
AirPressure *float64 `json:"airPressure,omitempty"`
SunLight *float64 `json:"sunLight,omitempty"`
UpdatedAt string `json:"updatedAt"`
        }

        type LocationInfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *LocationInfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *LocationInfoConnectionExec) Edges() *LocationInfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "LocationInfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &LocationInfoEdgeExec{ret}
                }

                  func (instance *LocationInfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateLocationInfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance LocationInfoConnectionExec) Exec(ctx context.Context) (*LocationInfoConnection, error) {
            var v LocationInfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance LocationInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LocationInfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance LocationInfoConnectionExecArray) Exec(ctx context.Context) ([]LocationInfoConnection, error) {
            var v []LocationInfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type LocationInfoConnection struct {
          
        }

        type MaCinfoExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MaCinfoExec) Person() *PersonInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfo"},
                    "person",
                    []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

                  return &PersonInfoExec{ret}
                }

                func (instance *MaCinfoExec) MacProbeDatas(params *MacProbeDatasParamsExec) *MacProbeDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"MACProbeDataWhereInput", "MACProbeDataOrderByInput", "MACProbeData"},
                    "macProbeDatas",
                    []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

                  return &MacProbeDataExecArray{ret}
                }

                type AttendanceRecordsParamsExec struct {
                  Where *AttendanceRecordWhereInput
OrderBy *AttendanceRecordOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *MaCinfoExec) AttendanceRecords(params *AttendanceRecordsParamsExec) *AttendanceRecordExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"AttendanceRecordWhereInput", "AttendanceRecordOrderByInput", "AttendanceRecord"},
                    "attendanceRecords",
                    []string{"id","attDate","totalSecond"})

                  return &AttendanceRecordExecArray{ret}
                }

          func (instance MaCinfoExec) Exec(ctx context.Context) (*MaCinfo, error) {
            var v MaCinfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MaCinfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MaCinfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance MaCinfoExecArray) Exec(ctx context.Context) ([]MaCinfo, error) {
            var v []MaCinfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MaCinfo struct {
          ID string `json:"id"`
Mac string `json:"mac"`
DevType *string `json:"devType,omitempty"`
ProbeCount *int32 `json:"probeCount,omitempty"`
LastProbeTime string `json:"lastProbeTime"`
IfOnline *int32 `json:"ifOnline,omitempty"`
        }

        type HistoryDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *HistoryDataEdgeExec) Node() *HistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "HistoryData"},
                    "node",
                    []string{"id","rcvTime","windSpeed","windDirection","temperature","humidity","noise","pm2","pm10","co","co2","airPressure","sunLight","createdAt"})

                  return &HistoryDataExec{ret}
                }

          func (instance HistoryDataEdgeExec) Exec(ctx context.Context) (*HistoryDataEdge, error) {
            var v HistoryDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance HistoryDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type HistoryDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance HistoryDataEdgeExecArray) Exec(ctx context.Context) ([]HistoryDataEdge, error) {
            var v []HistoryDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type HistoryDataEdge struct {
          Cursor string `json:"cursor"`
        }

        type WeatherAirHistorySubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirHistorySubscriptionPayloadExec) Node() *WeatherAirHistoryExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirHistory"},
                    "node",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirHistoryExec{ret}
                }

                func (instance *WeatherAirHistorySubscriptionPayloadExec) PreviousValues() *WeatherAirHistoryPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirHistoryPreviousValues"},
                    "previousValues",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirHistoryPreviousValuesExec{ret}
                }

          func (instance WeatherAirHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*WeatherAirHistorySubscriptionPayload, error) {
            var v WeatherAirHistorySubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirHistorySubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WeatherAirHistorySubscriptionPayload, error) {
            var v []WeatherAirHistorySubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirHistorySubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type CityCodeInfoConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *CityCodeInfoConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *CityCodeInfoConnectionExec) Edges() *CityCodeInfoEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "CityCodeInfoEdge"},
                    "edges",
                    []string{"cursor"})

                  return &CityCodeInfoEdgeExec{ret}
                }

                  func (instance *CityCodeInfoConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateCityCodeInfo"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance CityCodeInfoConnectionExec) Exec(ctx context.Context) (*CityCodeInfoConnection, error) {
            var v CityCodeInfoConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance CityCodeInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type CityCodeInfoConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance CityCodeInfoConnectionExecArray) Exec(ctx context.Context) ([]CityCodeInfoConnection, error) {
            var v []CityCodeInfoConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type CityCodeInfoConnection struct {
          
        }

        type WeatherAirHistoryPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance WeatherAirHistoryPreviousValuesExec) Exec(ctx context.Context) (*WeatherAirHistoryPreviousValues, error) {
            var v WeatherAirHistoryPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirHistoryPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]WeatherAirHistoryPreviousValues, error) {
            var v []WeatherAirHistoryPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirHistoryPreviousValues struct {
          ID string `json:"id"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type WeatherAirLiveConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirLiveConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *WeatherAirLiveConnectionExec) Edges() *WeatherAirLiveEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirLiveEdge"},
                    "edges",
                    []string{"cursor"})

                  return &WeatherAirLiveEdgeExec{ret}
                }

                  func (instance *WeatherAirLiveConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateWeatherAirLive"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance WeatherAirLiveConnectionExec) Exec(ctx context.Context) (*WeatherAirLiveConnection, error) {
            var v WeatherAirLiveConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirLiveConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirLiveConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirLiveConnectionExecArray) Exec(ctx context.Context) ([]WeatherAirLiveConnection, error) {
            var v []WeatherAirLiveConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirLiveConnection struct {
          
        }

        type PersonInfoExec struct {
          exec *prisma.Exec
        }

        
                func (instance *PersonInfoExec) IDCardVerifyDatas(params *IDCardVerifyDatasParamsExec) *IDCardVerifyDataExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"IDCardVerifyDataWhereInput", "IDCardVerifyDataOrderByInput", "IDCardVerifyData"},
                    "idCardVerifyDatas",
                    []string{"id","createdAt","devNo","devName","devAddr","idCard","personType","score","status","faceImgUri"})

                  return &IDCardVerifyDataExecArray{ret}
                }

                type MacinfosParamsExec struct {
                  Where *MaCinfoWhereInput
OrderBy *MaCinfoOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *PersonInfoExec) Macinfos(params *MacinfosParamsExec) *MaCinfoExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"MACinfoWhereInput", "MACinfoOrderByInput", "MACinfo"},
                    "macinfos",
                    []string{"id","mac","devType","probeCount","lastProbeTime","ifOnline"})

                  return &MaCinfoExecArray{ret}
                }

          func (instance PersonInfoExec) Exec(ctx context.Context) (*PersonInfo, error) {
            var v PersonInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PersonInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PersonInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PersonInfoExecArray) Exec(ctx context.Context) ([]PersonInfo, error) {
            var v []PersonInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PersonInfo struct {
          ID string `json:"id"`
IDCard string `json:"idCard"`
CardType string `json:"cardType"`
Validity *string `json:"validity,omitempty"`
Birthday *string `json:"birthday,omitempty"`
PersonName *string `json:"personName,omitempty"`
Address *string `json:"address,omitempty"`
Nation *string `json:"nation,omitempty"`
Authority *string `json:"authority,omitempty"`
Gender *string `json:"gender,omitempty"`
Class *string `json:"class,omitempty"`
StudentNumber *string `json:"studentNumber,omitempty"`
Phone *string `json:"phone,omitempty"`
Remark *string `json:"remark,omitempty"`
BaseFaceImgUri *string `json:"baseFaceImgUri,omitempty"`
        }



        type WeatherHistoryDataSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherHistoryDataSubscriptionPayloadExec) Node() *WeatherHistoryDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherHistoryData"},
                    "node",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherHistoryDataExec{ret}
                }

                func (instance *WeatherHistoryDataSubscriptionPayloadExec) PreviousValues() *WeatherHistoryDataPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherHistoryDataPreviousValues"},
                    "previousValues",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherHistoryDataPreviousValuesExec{ret}
                }

          func (instance WeatherHistoryDataSubscriptionPayloadExec) Exec(ctx context.Context) (*WeatherHistoryDataSubscriptionPayload, error) {
            var v WeatherHistoryDataSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherHistoryDataSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherHistoryDataSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherHistoryDataSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WeatherHistoryDataSubscriptionPayload, error) {
            var v []WeatherHistoryDataSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherHistoryDataSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type IDCardVerifyDataExec struct {
          exec *prisma.Exec
        }

        
                func (instance *IDCardVerifyDataExec) Person() *PersonInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PersonInfo"},
                    "person",
                    []string{"id","idCard","cardType","validity","birthday","personName","address","nation","authority","gender","class","studentNumber","phone","remark","baseFaceImgUri"})

                  return &PersonInfoExec{ret}
                }

                func (instance *IDCardVerifyDataExec) IDVerifyDevice() *IDVerifyDeviceInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "IDVerifyDeviceInfo"},
                    "idVerifyDevice",
                    []string{"id","devNo","devName","devAddr"})

                  return &IDVerifyDeviceInfoExec{ret}
                }

          func (instance IDCardVerifyDataExec) Exec(ctx context.Context) (*IDCardVerifyData, error) {
            var v IDCardVerifyData
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance IDCardVerifyDataExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type IDCardVerifyDataExecArray struct {
            exec *prisma.Exec
          }

          func (instance IDCardVerifyDataExecArray) Exec(ctx context.Context) ([]IDCardVerifyData, error) {
            var v []IDCardVerifyData
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type IDCardVerifyData struct {
          ID string `json:"id"`
CreatedAt *string `json:"createdAt,omitempty"`
DevNo *string `json:"devNo,omitempty"`
DevName *string `json:"devName,omitempty"`
DevAddr *string `json:"devAddr,omitempty"`
IDCard *string `json:"idCard,omitempty"`
PersonType *string `json:"personType,omitempty"`
Score *string `json:"score,omitempty"`
Status *string `json:"status,omitempty"`
FaceImgUri *string `json:"faceImgUri,omitempty"`
        }

        type WeatherAirLivePreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance WeatherAirLivePreviousValuesExec) Exec(ctx context.Context) (*WeatherAirLivePreviousValues, error) {
            var v WeatherAirLivePreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirLivePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirLivePreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirLivePreviousValuesExecArray) Exec(ctx context.Context) ([]WeatherAirLivePreviousValues, error) {
            var v []WeatherAirLivePreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirLivePreviousValues struct {
          ID string `json:"id"`
WindSpeed *string `json:"WindSpeed,omitempty"`
CityName *string `json:"CityName,omitempty"`
Airpressure *string `json:"Airpressure,omitempty"`
Phenomena *string `json:"Phenomena,omitempty"`
Rdesc *string `json:"Rdesc,omitempty"`
Humidity *string `json:"Humidity,omitempty"`
Updatetime *string `json:"Updatetime,omitempty"`
Windpower *string `json:"Windpower,omitempty"`
Feelst *string `json:"Feelst,omitempty"`
Winddirect *string `json:"Winddirect,omitempty"`
Rcode *int32 `json:"Rcode,omitempty"`
Rain *string `json:"Rain,omitempty"`
Temperature *string `json:"Temperature,omitempty"`
Citycode *string `json:"Citycode,omitempty"`
Pm25 *string `json:"PM25,omitempty"`
Pm10 *string `json:"PM10,omitempty"`
So2 *string `json:"SO2,omitempty"`
O3 *string `json:"O3,omitempty"`
No2 *string `json:"NO2,omitempty"`
Primary *string `json:"Primary,omitempty"`
Co *string `json:"CO,omitempty"`
Aqi *string `json:"AQI,omitempty"`
        }

        type WeatherAirLiveSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherAirLiveSubscriptionPayloadExec) Node() *WeatherAirLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirLive"},
                    "node",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirLiveExec{ret}
                }

                func (instance *WeatherAirLiveSubscriptionPayloadExec) PreviousValues() *WeatherAirLivePreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherAirLivePreviousValues"},
                    "previousValues",
                    []string{"id","WindSpeed","CityName","Airpressure","Phenomena","Rdesc","Humidity","Updatetime","Windpower","Feelst","Winddirect","Rcode","Rain","Temperature","Citycode","PM25","PM10","SO2","O3","NO2","Primary","CO","AQI"})

                  return &WeatherAirLivePreviousValuesExec{ret}
                }

          func (instance WeatherAirLiveSubscriptionPayloadExec) Exec(ctx context.Context) (*WeatherAirLiveSubscriptionPayload, error) {
            var v WeatherAirLiveSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherAirLiveSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherAirLiveSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherAirLiveSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WeatherAirLiveSubscriptionPayload, error) {
            var v []WeatherAirLiveSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherAirLiveSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type DataUnitConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *DataUnitConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *DataUnitConnectionExec) Edges() *DataUnitEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "DataUnitEdge"},
                    "edges",
                    []string{"cursor"})

                  return &DataUnitEdgeExec{ret}
                }

                  func (instance *DataUnitConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateDataUnit"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance DataUnitConnectionExec) Exec(ctx context.Context) (*DataUnitConnection, error) {
            var v DataUnitConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance DataUnitConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type DataUnitConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance DataUnitConnectionExecArray) Exec(ctx context.Context) ([]DataUnitConnection, error) {
            var v []DataUnitConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type DataUnitConnection struct {
          
        }

        type MacProbeDataEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *MacProbeDataEdgeExec) Node() *MacProbeDataExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "MACProbeData"},
                    "node",
                    []string{"id","probeTime","isConnet","routerMAC","routerSSID","destance"})

                  return &MacProbeDataExec{ret}
                }

          func (instance MacProbeDataEdgeExec) Exec(ctx context.Context) (*MacProbeDataEdge, error) {
            var v MacProbeDataEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance MacProbeDataEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type MacProbeDataEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance MacProbeDataEdgeExecArray) Exec(ctx context.Context) ([]MacProbeDataEdge, error) {
            var v []MacProbeDataEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type MacProbeDataEdge struct {
          Cursor string `json:"cursor"`
        }

        type LocationInfoExec struct {
          exec *prisma.Exec
        }

        
                type MonitorNodesParamsExec struct {
                  Where *MonitorNodeWhereInput
OrderBy *MonitorNodeOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *LocationInfoExec) MonitorNodes(params *MonitorNodesParamsExec) *MonitorNodeExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"MonitorNodeWhereInput", "MonitorNodeOrderByInput", "MonitorNode"},
                    "monitorNodes",
                    []string{"id","monitorSN","monitorName","monitorType","monitorStatus","createdAt","updatedAt"})

                  return &MonitorNodeExecArray{ret}
                }

                type IDVerifyDevicesParamsExec struct {
                  Where *IDVerifyDeviceInfoWhereInput
OrderBy *IDVerifyDeviceInfoOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *LocationInfoExec) IDVerifyDevices(params *IDVerifyDevicesParamsExec) *IDVerifyDeviceInfoExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"IDVerifyDeviceInfoWhereInput", "IDVerifyDeviceInfoOrderByInput", "IDVerifyDeviceInfo"},
                    "idVerifyDevices",
                    []string{"id","devNo","devName","devAddr"})

                  return &IDVerifyDeviceInfoExecArray{ret}
                }

                type WifiProbersParamsExec struct {
                  Where *WiFiProberinfoWhereInput
OrderBy *WiFiProberinfoOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *LocationInfoExec) WifiProbers(params *WifiProbersParamsExec) *WiFiProberinfoExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"WiFiProberinfoWhereInput", "WiFiProberinfoOrderByInput", "WiFiProberinfo"},
                    "wifiProbers",
                    []string{"id","devNo","devMac","devMdoel"})

                  return &WiFiProberinfoExecArray{ret}
                }

          func (instance LocationInfoExec) Exec(ctx context.Context) (*LocationInfo, error) {
            var v LocationInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance LocationInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type LocationInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance LocationInfoExecArray) Exec(ctx context.Context) ([]LocationInfo, error) {
            var v []LocationInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type LocationInfo struct {
          ID string `json:"id"`
Describe string `json:"describe"`
Longitude float64 `json:"longitude"`
Latitude float64 `json:"latitude"`
Province *string `json:"province,omitempty"`
City *string `json:"city,omitempty"`
County *string `json:"county,omitempty"`
Street *string `json:"street,omitempty"`
IndoorLocal *string `json:"indoorLocal,omitempty"`
OutdoorLocal *string `json:"outdoorLocal,omitempty"`
        }

        type WeatherLiveEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *WeatherLiveEdgeExec) Node() *WeatherLiveExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "WeatherLive"},
                    "node",
                    []string{"id","citycode","updatedAt","windspeed","airpressure","phenomena","rdesc","humidity","updatetime","windpower","feelst","winddirect","rcode","rain","temperature"})

                  return &WeatherLiveExec{ret}
                }

          func (instance WeatherLiveEdgeExec) Exec(ctx context.Context) (*WeatherLiveEdge, error) {
            var v WeatherLiveEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance WeatherLiveEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type WeatherLiveEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance WeatherLiveEdgeExecArray) Exec(ctx context.Context) ([]WeatherLiveEdge, error) {
            var v []WeatherLiveEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type WeatherLiveEdge struct {
          Cursor string `json:"cursor"`
        }







        